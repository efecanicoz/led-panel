
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4821      	ldr	r0, [pc, #132]	; (8000148 <endfiniloop+0x4>)
 80000c4:	f380 8809 	msr	PSP, r0
 80000c8:	2002      	movs	r0, #2
 80000ca:	f380 8814 	msr	CONTROL, r0
 80000ce:	f3bf 8f6f 	isb	sy
 80000d2:	f001 fc25 	bl	8001920 <__core_init>
 80000d6:	f000 fd53 	bl	8000b80 <__early_init>
 80000da:	481c      	ldr	r0, [pc, #112]	; (800014c <endfiniloop+0x8>)
 80000dc:	491c      	ldr	r1, [pc, #112]	; (8000150 <endfiniloop+0xc>)
 80000de:	4a1d      	ldr	r2, [pc, #116]	; (8000154 <endfiniloop+0x10>)

080000e0 <msloop>:
 80000e0:	4291      	cmp	r1, r2
 80000e2:	da02      	bge.n	80000ea <endmsloop>
 80000e4:	6008      	str	r0, [r1, #0]
 80000e6:	3104      	adds	r1, #4
 80000e8:	e7fa      	b.n	80000e0 <msloop>

080000ea <endmsloop>:
 80000ea:	491b      	ldr	r1, [pc, #108]	; (8000158 <endfiniloop+0x14>)
 80000ec:	4a16      	ldr	r2, [pc, #88]	; (8000148 <endfiniloop+0x4>)

080000ee <psloop>:
 80000ee:	4291      	cmp	r1, r2
 80000f0:	da02      	bge.n	80000f8 <endpsloop>
 80000f2:	6008      	str	r0, [r1, #0]
 80000f4:	3104      	adds	r1, #4
 80000f6:	e7fa      	b.n	80000ee <psloop>

080000f8 <endpsloop>:
 80000f8:	4918      	ldr	r1, [pc, #96]	; (800015c <endfiniloop+0x18>)
 80000fa:	4a19      	ldr	r2, [pc, #100]	; (8000160 <endfiniloop+0x1c>)
 80000fc:	4b19      	ldr	r3, [pc, #100]	; (8000164 <endfiniloop+0x20>)

080000fe <dloop>:
 80000fe:	429a      	cmp	r2, r3
 8000100:	da04      	bge.n	800010c <enddloop>
 8000102:	6808      	ldr	r0, [r1, #0]
 8000104:	6010      	str	r0, [r2, #0]
 8000106:	3104      	adds	r1, #4
 8000108:	3204      	adds	r2, #4
 800010a:	e7f8      	b.n	80000fe <dloop>

0800010c <enddloop>:
 800010c:	2000      	movs	r0, #0
 800010e:	4916      	ldr	r1, [pc, #88]	; (8000168 <endfiniloop+0x24>)
 8000110:	4a16      	ldr	r2, [pc, #88]	; (800016c <endfiniloop+0x28>)

08000112 <bloop>:
 8000112:	4291      	cmp	r1, r2
 8000114:	da02      	bge.n	800011c <endbloop>
 8000116:	6008      	str	r0, [r1, #0]
 8000118:	3104      	adds	r1, #4
 800011a:	e7fa      	b.n	8000112 <bloop>

0800011c <endbloop>:
 800011c:	f001 fc08 	bl	8001930 <__late_init>
 8000120:	4c13      	ldr	r4, [pc, #76]	; (8000170 <endfiniloop+0x2c>)
 8000122:	4d14      	ldr	r5, [pc, #80]	; (8000174 <endfiniloop+0x30>)

08000124 <initloop>:
 8000124:	42ac      	cmp	r4, r5
 8000126:	da03      	bge.n	8000130 <endinitloop>
 8000128:	6821      	ldr	r1, [r4, #0]
 800012a:	4788      	blx	r1
 800012c:	3404      	adds	r4, #4
 800012e:	e7f9      	b.n	8000124 <initloop>

08000130 <endinitloop>:
 8000130:	f000 fdee 	bl	8000d10 <main>
 8000134:	4c10      	ldr	r4, [pc, #64]	; (8000178 <endfiniloop+0x34>)
 8000136:	4d11      	ldr	r5, [pc, #68]	; (800017c <endfiniloop+0x38>)

08000138 <finiloop>:
 8000138:	42ac      	cmp	r4, r5
 800013a:	da03      	bge.n	8000144 <endfiniloop>
 800013c:	6821      	ldr	r1, [r4, #0]
 800013e:	4788      	blx	r1
 8000140:	3404      	adds	r4, #4
 8000142:	e7f9      	b.n	8000138 <finiloop>

08000144 <endfiniloop>:
 8000144:	490e      	ldr	r1, [pc, #56]	; (8000180 <endfiniloop+0x3c>)
 8000146:	4708      	bx	r1
 8000148:	20000300 	.word	0x20000300
 800014c:	55555555 	.word	0x55555555
 8000150:	20000000 	.word	0x20000000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000200 	.word	0x20000200
 800015c:	080027f0 	.word	0x080027f0
 8000160:	20000300 	.word	0x20000300
 8000164:	20000300 	.word	0x20000300
 8000168:	20000300 	.word	0x20000300
 800016c:	200006cc 	.word	0x200006cc
 8000170:	080000c0 	.word	0x080000c0
 8000174:	080000c0 	.word	0x080000c0
 8000178:	080000c0 	.word	0x080000c0
 800017c:	080000c0 	.word	0x080000c0
 8000180:	08001941 	.word	0x08001941
	...

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	b662      	cpsie	i
 80001b2:	1c28      	adds	r0, r5, #0
 80001b4:	47a0      	blx	r4
 80001b6:	2000      	movs	r0, #0
 80001b8:	f002 f9fa 	bl	80025b0 <chThdExit>

080001bc <_port_switch_from_isr>:
 80001bc:	f002 f918 	bl	80023f0 <chSchDoReschedule>

080001c0 <_port_exit_from_isr>:
 80001c0:	4a01      	ldr	r2, [pc, #4]	; (80001c8 <_port_exit_from_isr+0x8>)
 80001c2:	4b02      	ldr	r3, [pc, #8]	; (80001cc <_port_exit_from_isr+0xc>)
 80001c4:	6013      	str	r3, [r2, #0]
 80001c6:	e7fe      	b.n	80001c6 <_port_exit_from_isr+0x6>
 80001c8:	e000ed04 	.word	0xe000ed04
 80001cc:	80000000 	.word	0x80000000

080001d0 <__aeabi_uidiv>:
 80001d0:	2900      	cmp	r1, #0
 80001d2:	d034      	beq.n	800023e <.udivsi3_skip_div0_test+0x6a>

080001d4 <.udivsi3_skip_div0_test>:
 80001d4:	2301      	movs	r3, #1
 80001d6:	2200      	movs	r2, #0
 80001d8:	b410      	push	{r4}
 80001da:	4288      	cmp	r0, r1
 80001dc:	d32c      	bcc.n	8000238 <.udivsi3_skip_div0_test+0x64>
 80001de:	2401      	movs	r4, #1
 80001e0:	0724      	lsls	r4, r4, #28
 80001e2:	42a1      	cmp	r1, r4
 80001e4:	d204      	bcs.n	80001f0 <.udivsi3_skip_div0_test+0x1c>
 80001e6:	4281      	cmp	r1, r0
 80001e8:	d202      	bcs.n	80001f0 <.udivsi3_skip_div0_test+0x1c>
 80001ea:	0109      	lsls	r1, r1, #4
 80001ec:	011b      	lsls	r3, r3, #4
 80001ee:	e7f8      	b.n	80001e2 <.udivsi3_skip_div0_test+0xe>
 80001f0:	00e4      	lsls	r4, r4, #3
 80001f2:	42a1      	cmp	r1, r4
 80001f4:	d204      	bcs.n	8000200 <.udivsi3_skip_div0_test+0x2c>
 80001f6:	4281      	cmp	r1, r0
 80001f8:	d202      	bcs.n	8000200 <.udivsi3_skip_div0_test+0x2c>
 80001fa:	0049      	lsls	r1, r1, #1
 80001fc:	005b      	lsls	r3, r3, #1
 80001fe:	e7f8      	b.n	80001f2 <.udivsi3_skip_div0_test+0x1e>
 8000200:	4288      	cmp	r0, r1
 8000202:	d301      	bcc.n	8000208 <.udivsi3_skip_div0_test+0x34>
 8000204:	1a40      	subs	r0, r0, r1
 8000206:	431a      	orrs	r2, r3
 8000208:	084c      	lsrs	r4, r1, #1
 800020a:	42a0      	cmp	r0, r4
 800020c:	d302      	bcc.n	8000214 <.udivsi3_skip_div0_test+0x40>
 800020e:	1b00      	subs	r0, r0, r4
 8000210:	085c      	lsrs	r4, r3, #1
 8000212:	4322      	orrs	r2, r4
 8000214:	088c      	lsrs	r4, r1, #2
 8000216:	42a0      	cmp	r0, r4
 8000218:	d302      	bcc.n	8000220 <.udivsi3_skip_div0_test+0x4c>
 800021a:	1b00      	subs	r0, r0, r4
 800021c:	089c      	lsrs	r4, r3, #2
 800021e:	4322      	orrs	r2, r4
 8000220:	08cc      	lsrs	r4, r1, #3
 8000222:	42a0      	cmp	r0, r4
 8000224:	d302      	bcc.n	800022c <.udivsi3_skip_div0_test+0x58>
 8000226:	1b00      	subs	r0, r0, r4
 8000228:	08dc      	lsrs	r4, r3, #3
 800022a:	4322      	orrs	r2, r4
 800022c:	2800      	cmp	r0, #0
 800022e:	d003      	beq.n	8000238 <.udivsi3_skip_div0_test+0x64>
 8000230:	091b      	lsrs	r3, r3, #4
 8000232:	d001      	beq.n	8000238 <.udivsi3_skip_div0_test+0x64>
 8000234:	0909      	lsrs	r1, r1, #4
 8000236:	e7e3      	b.n	8000200 <.udivsi3_skip_div0_test+0x2c>
 8000238:	1c10      	adds	r0, r2, #0
 800023a:	bc10      	pop	{r4}
 800023c:	4770      	bx	lr
 800023e:	2800      	cmp	r0, #0
 8000240:	d001      	beq.n	8000246 <.udivsi3_skip_div0_test+0x72>
 8000242:	2000      	movs	r0, #0
 8000244:	43c0      	mvns	r0, r0
 8000246:	b407      	push	{r0, r1, r2}
 8000248:	4802      	ldr	r0, [pc, #8]	; (8000254 <.udivsi3_skip_div0_test+0x80>)
 800024a:	a102      	add	r1, pc, #8	; (adr r1, 8000254 <.udivsi3_skip_div0_test+0x80>)
 800024c:	1840      	adds	r0, r0, r1
 800024e:	9002      	str	r0, [sp, #8]
 8000250:	bd03      	pop	{r0, r1, pc}
 8000252:	46c0      	nop			; (mov r8, r8)
 8000254:	0000001d 	.word	0x0000001d

08000258 <__aeabi_uidivmod>:
 8000258:	2900      	cmp	r1, #0
 800025a:	d0f0      	beq.n	800023e <.udivsi3_skip_div0_test+0x6a>
 800025c:	b503      	push	{r0, r1, lr}
 800025e:	f7ff ffb9 	bl	80001d4 <.udivsi3_skip_div0_test>
 8000262:	bc0e      	pop	{r1, r2, r3}
 8000264:	4342      	muls	r2, r0
 8000266:	1a89      	subs	r1, r1, r2
 8000268:	4718      	bx	r3
 800026a:	46c0      	nop			; (mov r8, r8)
 800026c:	0000      	movs	r0, r0
	...

08000270 <__aeabi_idiv0>:
 8000270:	4770      	bx	lr
 8000272:	46c0      	nop			; (mov r8, r8)
	...

08000280 <sdIncomingDataI.4334>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000280:	b500      	push	{lr}
 8000282:	b083      	sub	sp, #12
 8000284:	9001      	str	r0, [sp, #4]
 8000286:	1c0a      	adds	r2, r1, #0
 8000288:	466b      	mov	r3, sp
 800028a:	3303      	adds	r3, #3
 800028c:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800028e:	9b01      	ldr	r3, [sp, #4]
 8000290:	695b      	ldr	r3, [r3, #20]
 8000292:	2b00      	cmp	r3, #0
 8000294:	d105      	bne.n	80002a2 <sdIncomingDataI.4334+0x22>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8000296:	9b01      	ldr	r3, [sp, #4]
 8000298:	3304      	adds	r3, #4
 800029a:	1c18      	adds	r0, r3, #0
 800029c:	2104      	movs	r1, #4
 800029e:	f001 fa0f 	bl	80016c0 <osalEventBroadcastFlagsI.6300>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 80002a2:	9b01      	ldr	r3, [sp, #4]
 80002a4:	1c1a      	adds	r2, r3, #0
 80002a6:	320c      	adds	r2, #12
 80002a8:	466b      	mov	r3, sp
 80002aa:	3303      	adds	r3, #3
 80002ac:	781b      	ldrb	r3, [r3, #0]
 80002ae:	1c10      	adds	r0, r2, #0
 80002b0:	1c19      	adds	r1, r3, #0
 80002b2:	f000 ffe5 	bl	8001280 <iqPutI>
 80002b6:	1c03      	adds	r3, r0, #0
 80002b8:	2b00      	cmp	r3, #0
 80002ba:	da05      	bge.n	80002c8 <sdIncomingDataI.4334+0x48>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80002bc:	9b01      	ldr	r3, [sp, #4]
 80002be:	3304      	adds	r3, #4
 80002c0:	1c18      	adds	r0, r3, #0
 80002c2:	2180      	movs	r1, #128	; 0x80
 80002c4:	f001 f9fc 	bl	80016c0 <osalEventBroadcastFlagsI.6300>
}
 80002c8:	b003      	add	sp, #12
 80002ca:	bd00      	pop	{pc}
 80002cc:	46c0      	nop			; (mov r8, r8)
 80002ce:	46c0      	nop			; (mov r8, r8)

080002d0 <nvicEnableVector.4320>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80002d0:	b530      	push	{r4, r5, lr}
 80002d2:	b083      	sub	sp, #12
 80002d4:	9001      	str	r0, [sp, #4]
 80002d6:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80002d8:	4b1d      	ldr	r3, [pc, #116]	; (8000350 <nvicEnableVector.4320+0x80>)
 80002da:	9a01      	ldr	r2, [sp, #4]
 80002dc:	0892      	lsrs	r2, r2, #2
 80002de:	491c      	ldr	r1, [pc, #112]	; (8000350 <nvicEnableVector.4320+0x80>)
 80002e0:	9801      	ldr	r0, [sp, #4]
 80002e2:	0880      	lsrs	r0, r0, #2
 80002e4:	30c0      	adds	r0, #192	; 0xc0
 80002e6:	0080      	lsls	r0, r0, #2
 80002e8:	5841      	ldr	r1, [r0, r1]
 80002ea:	9c01      	ldr	r4, [sp, #4]
 80002ec:	2003      	movs	r0, #3
 80002ee:	4020      	ands	r0, r4
 80002f0:	00c0      	lsls	r0, r0, #3
 80002f2:	24ff      	movs	r4, #255	; 0xff
 80002f4:	1c25      	adds	r5, r4, #0
 80002f6:	4085      	lsls	r5, r0
 80002f8:	1c28      	adds	r0, r5, #0
 80002fa:	43c0      	mvns	r0, r0
 80002fc:	4008      	ands	r0, r1
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 80002fe:	9900      	ldr	r1, [sp, #0]
 8000300:	018c      	lsls	r4, r1, #6
 8000302:	9d01      	ldr	r5, [sp, #4]
 8000304:	2103      	movs	r1, #3
 8000306:	4029      	ands	r1, r5
 8000308:	00c9      	lsls	r1, r1, #3
 800030a:	1c25      	adds	r5, r4, #0
 800030c:	408d      	lsls	r5, r1
 800030e:	1c29      	adds	r1, r5, #0
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000310:	4301      	orrs	r1, r0
 8000312:	32c0      	adds	r2, #192	; 0xc0
 8000314:	0092      	lsls	r2, r2, #2
 8000316:	50d1      	str	r1, [r2, r3]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000318:	4b0d      	ldr	r3, [pc, #52]	; (8000350 <nvicEnableVector.4320+0x80>)
 800031a:	9a01      	ldr	r2, [sp, #4]
 800031c:	0952      	lsrs	r2, r2, #5
 800031e:	9801      	ldr	r0, [sp, #4]
 8000320:	211f      	movs	r1, #31
 8000322:	4001      	ands	r1, r0
 8000324:	2001      	movs	r0, #1
 8000326:	1c04      	adds	r4, r0, #0
 8000328:	408c      	lsls	r4, r1
 800032a:	1c21      	adds	r1, r4, #0
 800032c:	3260      	adds	r2, #96	; 0x60
 800032e:	0092      	lsls	r2, r2, #2
 8000330:	50d1      	str	r1, [r2, r3]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000332:	4b07      	ldr	r3, [pc, #28]	; (8000350 <nvicEnableVector.4320+0x80>)
 8000334:	9a01      	ldr	r2, [sp, #4]
 8000336:	0952      	lsrs	r2, r2, #5
 8000338:	9801      	ldr	r0, [sp, #4]
 800033a:	211f      	movs	r1, #31
 800033c:	4001      	ands	r1, r0
 800033e:	2001      	movs	r0, #1
 8000340:	1c05      	adds	r5, r0, #0
 8000342:	408d      	lsls	r5, r1
 8000344:	1c29      	adds	r1, r5, #0
 8000346:	0092      	lsls	r2, r2, #2
 8000348:	50d1      	str	r1, [r2, r3]
}
 800034a:	b003      	add	sp, #12
 800034c:	bd30      	pop	{r4, r5, pc}
 800034e:	46c0      	nop			; (mov r8, r8)
 8000350:	e000e100 	.word	0xe000e100
 8000354:	46c0      	nop			; (mov r8, r8)
 8000356:	46c0      	nop			; (mov r8, r8)
 8000358:	46c0      	nop			; (mov r8, r8)
 800035a:	46c0      	nop			; (mov r8, r8)
 800035c:	46c0      	nop			; (mov r8, r8)
 800035e:	46c0      	nop			; (mov r8, r8)

08000360 <hal_lld_backup_domain_init.6570.4307>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000360:	4b15      	ldr	r3, [pc, #84]	; (80003b8 <hal_lld_backup_domain_init.6570.4307+0x58>)
 8000362:	4a15      	ldr	r2, [pc, #84]	; (80003b8 <hal_lld_backup_domain_init.6570.4307+0x58>)
 8000364:	6812      	ldr	r2, [r2, #0]
 8000366:	2180      	movs	r1, #128	; 0x80
 8000368:	0049      	lsls	r1, r1, #1
 800036a:	430a      	orrs	r2, r1
 800036c:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 800036e:	4b13      	ldr	r3, [pc, #76]	; (80003bc <hal_lld_backup_domain_init.6570.4307+0x5c>)
 8000370:	6a1a      	ldr	r2, [r3, #32]
 8000372:	23c0      	movs	r3, #192	; 0xc0
 8000374:	009b      	lsls	r3, r3, #2
 8000376:	401a      	ands	r2, r3
 8000378:	2380      	movs	r3, #128	; 0x80
 800037a:	009b      	lsls	r3, r3, #2
 800037c:	429a      	cmp	r2, r3
 800037e:	d006      	beq.n	800038e <hal_lld_backup_domain_init.6570.4307+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000380:	4b0e      	ldr	r3, [pc, #56]	; (80003bc <hal_lld_backup_domain_init.6570.4307+0x5c>)
 8000382:	2280      	movs	r2, #128	; 0x80
 8000384:	0252      	lsls	r2, r2, #9
 8000386:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8000388:	4b0c      	ldr	r3, [pc, #48]	; (80003bc <hal_lld_backup_domain_init.6570.4307+0x5c>)
 800038a:	2200      	movs	r2, #0
 800038c:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800038e:	4b0b      	ldr	r3, [pc, #44]	; (80003bc <hal_lld_backup_domain_init.6570.4307+0x5c>)
 8000390:	6a1a      	ldr	r2, [r3, #32]
 8000392:	2380      	movs	r3, #128	; 0x80
 8000394:	021b      	lsls	r3, r3, #8
 8000396:	4013      	ands	r3, r2
 8000398:	d10d      	bne.n	80003b6 <hal_lld_backup_domain_init.6570.4307+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 800039a:	4b08      	ldr	r3, [pc, #32]	; (80003bc <hal_lld_backup_domain_init.6570.4307+0x5c>)
 800039c:	4a07      	ldr	r2, [pc, #28]	; (80003bc <hal_lld_backup_domain_init.6570.4307+0x5c>)
 800039e:	6a12      	ldr	r2, [r2, #32]
 80003a0:	2180      	movs	r1, #128	; 0x80
 80003a2:	0089      	lsls	r1, r1, #2
 80003a4:	430a      	orrs	r2, r1
 80003a6:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 80003a8:	4b04      	ldr	r3, [pc, #16]	; (80003bc <hal_lld_backup_domain_init.6570.4307+0x5c>)
 80003aa:	4a04      	ldr	r2, [pc, #16]	; (80003bc <hal_lld_backup_domain_init.6570.4307+0x5c>)
 80003ac:	6a12      	ldr	r2, [r2, #32]
 80003ae:	2180      	movs	r1, #128	; 0x80
 80003b0:	0209      	lsls	r1, r1, #8
 80003b2:	430a      	orrs	r2, r1
 80003b4:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 80003b6:	4770      	bx	lr
 80003b8:	40007000 	.word	0x40007000
 80003bc:	40021000 	.word	0x40021000

080003c0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80003c0:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80003c2:	4b12      	ldr	r3, [pc, #72]	; (800040c <hal_lld_init+0x4c>)
 80003c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80003c6:	4b11      	ldr	r3, [pc, #68]	; (800040c <hal_lld_init+0x4c>)
 80003c8:	2201      	movs	r2, #1
 80003ca:	4252      	negs	r2, r2
 80003cc:	629a      	str	r2, [r3, #40]	; 0x28
 80003ce:	4b0f      	ldr	r3, [pc, #60]	; (800040c <hal_lld_init+0x4c>)
 80003d0:	2200      	movs	r2, #0
 80003d2:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 80003d4:	4b0d      	ldr	r3, [pc, #52]	; (800040c <hal_lld_init+0x4c>)
 80003d6:	691b      	ldr	r3, [r3, #16]
 80003d8:	4b0c      	ldr	r3, [pc, #48]	; (800040c <hal_lld_init+0x4c>)
 80003da:	2201      	movs	r2, #1
 80003dc:	4252      	negs	r2, r2
 80003de:	611a      	str	r2, [r3, #16]
 80003e0:	4b0a      	ldr	r3, [pc, #40]	; (800040c <hal_lld_init+0x4c>)
 80003e2:	2200      	movs	r2, #0
 80003e4:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80003e6:	4b09      	ldr	r3, [pc, #36]	; (800040c <hal_lld_init+0x4c>)
 80003e8:	4a08      	ldr	r2, [pc, #32]	; (800040c <hal_lld_init+0x4c>)
 80003ea:	68d2      	ldr	r2, [r2, #12]
 80003ec:	4908      	ldr	r1, [pc, #32]	; (8000410 <hal_lld_init+0x50>)
 80003ee:	430a      	orrs	r2, r1
 80003f0:	60da      	str	r2, [r3, #12]
 80003f2:	4b06      	ldr	r3, [pc, #24]	; (800040c <hal_lld_init+0x4c>)
 80003f4:	2200      	movs	r2, #0
 80003f6:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80003f8:	4b04      	ldr	r3, [pc, #16]	; (800040c <hal_lld_init+0x4c>)
 80003fa:	4a04      	ldr	r2, [pc, #16]	; (800040c <hal_lld_init+0x4c>)
 80003fc:	69d2      	ldr	r2, [r2, #28]
 80003fe:	2180      	movs	r1, #128	; 0x80
 8000400:	0549      	lsls	r1, r1, #21
 8000402:	430a      	orrs	r2, r1
 8000404:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8000406:	f7ff ffab 	bl	8000360 <hal_lld_backup_domain_init.6570.4307>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800040a:	bd08      	pop	{r3, pc}
 800040c:	40021000 	.word	0x40021000
 8000410:	ffbfffff 	.word	0xffbfffff
 8000414:	46c0      	nop			; (mov r8, r8)
 8000416:	46c0      	nop			; (mov r8, r8)
 8000418:	46c0      	nop			; (mov r8, r8)
 800041a:	46c0      	nop			; (mov r8, r8)
 800041c:	46c0      	nop			; (mov r8, r8)
 800041e:	46c0      	nop			; (mov r8, r8)

08000420 <stm32_clock_init.4302>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000420:	4b32      	ldr	r3, [pc, #200]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000422:	4a32      	ldr	r2, [pc, #200]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000424:	6812      	ldr	r2, [r2, #0]
 8000426:	2101      	movs	r1, #1
 8000428:	430a      	orrs	r2, r1
 800042a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800042c:	4b2f      	ldr	r3, [pc, #188]	; (80004ec <stm32_clock_init.4302+0xcc>)
 800042e:	681a      	ldr	r2, [r3, #0]
 8000430:	2302      	movs	r3, #2
 8000432:	4013      	ands	r3, r2
 8000434:	d0fa      	beq.n	800042c <stm32_clock_init.4302+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000436:	4b2d      	ldr	r3, [pc, #180]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000438:	4a2c      	ldr	r2, [pc, #176]	; (80004ec <stm32_clock_init.4302+0xcc>)
 800043a:	6852      	ldr	r2, [r2, #4]
 800043c:	2103      	movs	r1, #3
 800043e:	438a      	bics	r2, r1
 8000440:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8000442:	4b2a      	ldr	r3, [pc, #168]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000444:	4a29      	ldr	r2, [pc, #164]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000446:	6852      	ldr	r2, [r2, #4]
 8000448:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800044a:	4b28      	ldr	r3, [pc, #160]	; (80004ec <stm32_clock_init.4302+0xcc>)
 800044c:	685a      	ldr	r2, [r3, #4]
 800044e:	230c      	movs	r3, #12
 8000450:	4013      	ands	r3, r2
 8000452:	d1fa      	bne.n	800044a <stm32_clock_init.4302+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000454:	4b25      	ldr	r3, [pc, #148]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000456:	4a25      	ldr	r2, [pc, #148]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000458:	6811      	ldr	r1, [r2, #0]
 800045a:	22f9      	movs	r2, #249	; 0xf9
 800045c:	400a      	ands	r2, r1
 800045e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000460:	4b22      	ldr	r3, [pc, #136]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000462:	2200      	movs	r2, #0
 8000464:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8000466:	4b21      	ldr	r3, [pc, #132]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000468:	4a20      	ldr	r2, [pc, #128]	; (80004ec <stm32_clock_init.4302+0xcc>)
 800046a:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800046c:	2101      	movs	r1, #1
 800046e:	430a      	orrs	r2, r1
 8000470:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8000472:	4b1e      	ldr	r3, [pc, #120]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000474:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000476:	2302      	movs	r3, #2
 8000478:	4013      	ands	r3, r2
 800047a:	d0fa      	beq.n	8000472 <stm32_clock_init.4302+0x52>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800047c:	4b1b      	ldr	r3, [pc, #108]	; (80004ec <stm32_clock_init.4302+0xcc>)
 800047e:	4a1b      	ldr	r2, [pc, #108]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000480:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000482:	2101      	movs	r1, #1
 8000484:	430a      	orrs	r2, r1
 8000486:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000488:	4b18      	ldr	r3, [pc, #96]	; (80004ec <stm32_clock_init.4302+0xcc>)
 800048a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800048c:	2302      	movs	r3, #2
 800048e:	4013      	ands	r3, r2
 8000490:	d0fa      	beq.n	8000488 <stm32_clock_init.4302+0x68>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8000492:	4b16      	ldr	r3, [pc, #88]	; (80004ec <stm32_clock_init.4302+0xcc>)
 8000494:	22a0      	movs	r2, #160	; 0xa0
 8000496:	0392      	lsls	r2, r2, #14
 8000498:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 800049a:	4b14      	ldr	r3, [pc, #80]	; (80004ec <stm32_clock_init.4302+0xcc>)
 800049c:	2200      	movs	r2, #0
 800049e:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 80004a0:	4b12      	ldr	r3, [pc, #72]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004a2:	2200      	movs	r2, #0
 80004a4:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80004a6:	4b11      	ldr	r3, [pc, #68]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004a8:	4a10      	ldr	r2, [pc, #64]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004aa:	6812      	ldr	r2, [r2, #0]
 80004ac:	2180      	movs	r1, #128	; 0x80
 80004ae:	0449      	lsls	r1, r1, #17
 80004b0:	430a      	orrs	r2, r1
 80004b2:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80004b4:	4b0d      	ldr	r3, [pc, #52]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004b6:	681a      	ldr	r2, [r3, #0]
 80004b8:	2380      	movs	r3, #128	; 0x80
 80004ba:	049b      	lsls	r3, r3, #18
 80004bc:	4013      	ands	r3, r2
 80004be:	d0f9      	beq.n	80004b4 <stm32_clock_init.4302+0x94>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80004c0:	4b0b      	ldr	r3, [pc, #44]	; (80004f0 <stm32_clock_init.4302+0xd0>)
 80004c2:	2211      	movs	r2, #17
 80004c4:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80004c6:	4b09      	ldr	r3, [pc, #36]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004c8:	4a08      	ldr	r2, [pc, #32]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004ca:	6852      	ldr	r2, [r2, #4]
 80004cc:	2102      	movs	r1, #2
 80004ce:	430a      	orrs	r2, r1
 80004d0:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80004d2:	4b06      	ldr	r3, [pc, #24]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004d4:	685a      	ldr	r2, [r3, #4]
 80004d6:	230c      	movs	r3, #12
 80004d8:	4013      	ands	r3, r2
 80004da:	2b08      	cmp	r3, #8
 80004dc:	d1f9      	bne.n	80004d2 <stm32_clock_init.4302+0xb2>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80004de:	4b03      	ldr	r3, [pc, #12]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004e0:	4a02      	ldr	r2, [pc, #8]	; (80004ec <stm32_clock_init.4302+0xcc>)
 80004e2:	6992      	ldr	r2, [r2, #24]
 80004e4:	2101      	movs	r1, #1
 80004e6:	430a      	orrs	r2, r1
 80004e8:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 80004ea:	4770      	bx	lr
 80004ec:	40021000 	.word	0x40021000
 80004f0:	40022000 	.word	0x40022000
 80004f4:	46c0      	nop			; (mov r8, r8)
 80004f6:	46c0      	nop			; (mov r8, r8)
 80004f8:	46c0      	nop			; (mov r8, r8)
 80004fa:	46c0      	nop			; (mov r8, r8)
 80004fc:	46c0      	nop			; (mov r8, r8)
 80004fe:	46c0      	nop			; (mov r8, r8)

08000500 <port_lock.6611.4300>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000500:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000502:	4770      	bx	lr
 8000504:	46c0      	nop			; (mov r8, r8)
 8000506:	46c0      	nop			; (mov r8, r8)
 8000508:	46c0      	nop			; (mov r8, r8)
 800050a:	46c0      	nop			; (mov r8, r8)
 800050c:	46c0      	nop			; (mov r8, r8)
 800050e:	46c0      	nop			; (mov r8, r8)

08000510 <port_unlock.6614.4298>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000510:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000512:	4770      	bx	lr
 8000514:	46c0      	nop			; (mov r8, r8)
 8000516:	46c0      	nop			; (mov r8, r8)
 8000518:	46c0      	nop			; (mov r8, r8)
 800051a:	46c0      	nop			; (mov r8, r8)
 800051c:	46c0      	nop			; (mov r8, r8)
 800051e:	46c0      	nop			; (mov r8, r8)

08000520 <port_lock_from_isr.6616.4296>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000520:	b508      	push	{r3, lr}

  port_lock();
 8000522:	f7ff ffed 	bl	8000500 <port_lock.6611.4300>
}
 8000526:	bd08      	pop	{r3, pc}
 8000528:	46c0      	nop			; (mov r8, r8)
 800052a:	46c0      	nop			; (mov r8, r8)
 800052c:	46c0      	nop			; (mov r8, r8)
 800052e:	46c0      	nop			; (mov r8, r8)

08000530 <port_unlock_from_isr.6618.4294>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000530:	b508      	push	{r3, lr}

  port_unlock();
 8000532:	f7ff ffed 	bl	8000510 <port_unlock.6614.4298>
}
 8000536:	bd08      	pop	{r3, pc}
 8000538:	46c0      	nop			; (mov r8, r8)
 800053a:	46c0      	nop			; (mov r8, r8)
 800053c:	46c0      	nop			; (mov r8, r8)
 800053e:	46c0      	nop			; (mov r8, r8)

08000540 <chSysLockFromISR.6620.4292>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000540:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000542:	f7ff ffed 	bl	8000520 <port_lock_from_isr.6616.4296>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000546:	bd08      	pop	{r3, pc}
 8000548:	46c0      	nop			; (mov r8, r8)
 800054a:	46c0      	nop			; (mov r8, r8)
 800054c:	46c0      	nop			; (mov r8, r8)
 800054e:	46c0      	nop			; (mov r8, r8)

08000550 <chSysUnlockFromISR.6622.4290>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000550:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000552:	f7ff ffed 	bl	8000530 <port_unlock_from_isr.6618.4294>
}
 8000556:	bd08      	pop	{r3, pc}
 8000558:	46c0      	nop			; (mov r8, r8)
 800055a:	46c0      	nop			; (mov r8, r8)
 800055c:	46c0      	nop			; (mov r8, r8)
 800055e:	46c0      	nop			; (mov r8, r8)

08000560 <osalSysLockFromISR.6624.4288>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000560:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8000562:	f7ff ffed 	bl	8000540 <chSysLockFromISR.6620.4292>
}
 8000566:	bd08      	pop	{r3, pc}
 8000568:	46c0      	nop			; (mov r8, r8)
 800056a:	46c0      	nop			; (mov r8, r8)
 800056c:	46c0      	nop			; (mov r8, r8)
 800056e:	46c0      	nop			; (mov r8, r8)

08000570 <osalSysUnlockFromISR.6626.4286>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000570:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8000572:	f7ff ffed 	bl	8000550 <chSysUnlockFromISR.6622.4290>
}
 8000576:	bd08      	pop	{r3, pc}
 8000578:	46c0      	nop			; (mov r8, r8)
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	46c0      	nop			; (mov r8, r8)
 800057e:	46c0      	nop			; (mov r8, r8)

08000580 <osalOsTimerHandlerI.6628.4284>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8000580:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8000582:	f001 fbb5 	bl	8001cf0 <chSysTimerHandlerI>
}
 8000586:	bd08      	pop	{r3, pc}
 8000588:	46c0      	nop			; (mov r8, r8)
 800058a:	46c0      	nop			; (mov r8, r8)
 800058c:	46c0      	nop			; (mov r8, r8)
 800058e:	46c0      	nop			; (mov r8, r8)

08000590 <Vector80.4282>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000590:	b500      	push	{lr}
 8000592:	b083      	sub	sp, #12
 8000594:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000596:	9301      	str	r3, [sp, #4]

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000598:	4b09      	ldr	r3, [pc, #36]	; (80005c0 <Vector80.4282+0x30>)
 800059a:	691a      	ldr	r2, [r3, #16]
 800059c:	2302      	movs	r3, #2
 800059e:	4013      	ands	r3, r2
 80005a0:	d008      	beq.n	80005b4 <Vector80.4282+0x24>
    STM32_ST_TIM->SR = 0U;
 80005a2:	4b07      	ldr	r3, [pc, #28]	; (80005c0 <Vector80.4282+0x30>)
 80005a4:	2200      	movs	r2, #0
 80005a6:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80005a8:	f7ff ffda 	bl	8000560 <osalSysLockFromISR.6624.4288>
    osalOsTimerHandlerI();
 80005ac:	f7ff ffe8 	bl	8000580 <osalOsTimerHandlerI.6628.4284>
    osalSysUnlockFromISR();
 80005b0:	f7ff ffde 	bl	8000570 <osalSysUnlockFromISR.6626.4286>
  }

  OSAL_IRQ_EPILOGUE();
 80005b4:	9b01      	ldr	r3, [sp, #4]
 80005b6:	1c18      	adds	r0, r3, #0
 80005b8:	f000 fd02 	bl	8000fc0 <_port_irq_epilogue>
}
 80005bc:	b003      	add	sp, #12
 80005be:	bd00      	pop	{pc}
 80005c0:	40000400 	.word	0x40000400
 80005c4:	46c0      	nop			; (mov r8, r8)
 80005c6:	46c0      	nop			; (mov r8, r8)
 80005c8:	46c0      	nop			; (mov r8, r8)
 80005ca:	46c0      	nop			; (mov r8, r8)
 80005cc:	46c0      	nop			; (mov r8, r8)
 80005ce:	46c0      	nop			; (mov r8, r8)

080005d0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80005d0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80005d2:	4b14      	ldr	r3, [pc, #80]	; (8000624 <st_lld_init+0x54>)
 80005d4:	4a13      	ldr	r2, [pc, #76]	; (8000624 <st_lld_init+0x54>)
 80005d6:	69d2      	ldr	r2, [r2, #28]
 80005d8:	2102      	movs	r1, #2
 80005da:	430a      	orrs	r2, r1
 80005dc:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80005de:	4b12      	ldr	r3, [pc, #72]	; (8000628 <st_lld_init+0x58>)
 80005e0:	4a11      	ldr	r2, [pc, #68]	; (8000628 <st_lld_init+0x58>)
 80005e2:	6892      	ldr	r2, [r2, #8]
 80005e4:	2102      	movs	r1, #2
 80005e6:	430a      	orrs	r2, r1
 80005e8:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80005ea:	4b10      	ldr	r3, [pc, #64]	; (800062c <st_lld_init+0x5c>)
 80005ec:	4a10      	ldr	r2, [pc, #64]	; (8000630 <st_lld_init+0x60>)
 80005ee:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80005f0:	4b0e      	ldr	r3, [pc, #56]	; (800062c <st_lld_init+0x5c>)
 80005f2:	4a10      	ldr	r2, [pc, #64]	; (8000634 <st_lld_init+0x64>)
 80005f4:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80005f6:	4b0d      	ldr	r3, [pc, #52]	; (800062c <st_lld_init+0x5c>)
 80005f8:	2200      	movs	r2, #0
 80005fa:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80005fc:	4b0b      	ldr	r3, [pc, #44]	; (800062c <st_lld_init+0x5c>)
 80005fe:	2200      	movs	r2, #0
 8000600:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8000602:	4b0a      	ldr	r3, [pc, #40]	; (800062c <st_lld_init+0x5c>)
 8000604:	2200      	movs	r2, #0
 8000606:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000608:	4b08      	ldr	r3, [pc, #32]	; (800062c <st_lld_init+0x5c>)
 800060a:	2200      	movs	r2, #0
 800060c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800060e:	4b07      	ldr	r3, [pc, #28]	; (800062c <st_lld_init+0x5c>)
 8000610:	2201      	movs	r2, #1
 8000612:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000614:	4b05      	ldr	r3, [pc, #20]	; (800062c <st_lld_init+0x5c>)
 8000616:	2201      	movs	r2, #1
 8000618:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800061a:	2010      	movs	r0, #16
 800061c:	2102      	movs	r1, #2
 800061e:	f7ff fe57 	bl	80002d0 <nvicEnableVector.4320>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8000622:	bd08      	pop	{r3, pc}
 8000624:	40021000 	.word	0x40021000
 8000628:	40015800 	.word	0x40015800
 800062c:	40000400 	.word	0x40000400
 8000630:	000012bf 	.word	0x000012bf
 8000634:	0000ffff 	.word	0x0000ffff
 8000638:	46c0      	nop			; (mov r8, r8)
 800063a:	46c0      	nop			; (mov r8, r8)
 800063c:	46c0      	nop			; (mov r8, r8)
 800063e:	46c0      	nop			; (mov r8, r8)

08000640 <initgpio.6689.4274>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8000640:	b082      	sub	sp, #8
 8000642:	9001      	str	r0, [sp, #4]
 8000644:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8000646:	9b00      	ldr	r3, [sp, #0]
 8000648:	685a      	ldr	r2, [r3, #4]
 800064a:	9b01      	ldr	r3, [sp, #4]
 800064c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800064e:	9b00      	ldr	r3, [sp, #0]
 8000650:	689a      	ldr	r2, [r3, #8]
 8000652:	9b01      	ldr	r3, [sp, #4]
 8000654:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000656:	9b00      	ldr	r3, [sp, #0]
 8000658:	68da      	ldr	r2, [r3, #12]
 800065a:	9b01      	ldr	r3, [sp, #4]
 800065c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800065e:	9b00      	ldr	r3, [sp, #0]
 8000660:	691a      	ldr	r2, [r3, #16]
 8000662:	9b01      	ldr	r3, [sp, #4]
 8000664:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000666:	9b00      	ldr	r3, [sp, #0]
 8000668:	695a      	ldr	r2, [r3, #20]
 800066a:	9b01      	ldr	r3, [sp, #4]
 800066c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800066e:	9b00      	ldr	r3, [sp, #0]
 8000670:	699a      	ldr	r2, [r3, #24]
 8000672:	9b01      	ldr	r3, [sp, #4]
 8000674:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000676:	9b00      	ldr	r3, [sp, #0]
 8000678:	681a      	ldr	r2, [r3, #0]
 800067a:	9b01      	ldr	r3, [sp, #4]
 800067c:	601a      	str	r2, [r3, #0]
}
 800067e:	b002      	add	sp, #8
 8000680:	4770      	bx	lr
 8000682:	46c0      	nop			; (mov r8, r8)
 8000684:	46c0      	nop			; (mov r8, r8)
 8000686:	46c0      	nop			; (mov r8, r8)
 8000688:	46c0      	nop			; (mov r8, r8)
 800068a:	46c0      	nop			; (mov r8, r8)
 800068c:	46c0      	nop			; (mov r8, r8)
 800068e:	46c0      	nop			; (mov r8, r8)

08000690 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8000690:	b500      	push	{lr}
 8000692:	b083      	sub	sp, #12
 8000694:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000696:	4b12      	ldr	r3, [pc, #72]	; (80006e0 <_pal_lld_init+0x50>)
 8000698:	4a11      	ldr	r2, [pc, #68]	; (80006e0 <_pal_lld_init+0x50>)
 800069a:	6952      	ldr	r2, [r2, #20]
 800069c:	219c      	movs	r1, #156	; 0x9c
 800069e:	03c9      	lsls	r1, r1, #15
 80006a0:	430a      	orrs	r2, r1
 80006a2:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 80006a4:	9b01      	ldr	r3, [sp, #4]
 80006a6:	2290      	movs	r2, #144	; 0x90
 80006a8:	05d2      	lsls	r2, r2, #23
 80006aa:	1c10      	adds	r0, r2, #0
 80006ac:	1c19      	adds	r1, r3, #0
 80006ae:	f7ff ffc7 	bl	8000640 <initgpio.6689.4274>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 80006b2:	9b01      	ldr	r3, [sp, #4]
 80006b4:	331c      	adds	r3, #28
 80006b6:	4a0b      	ldr	r2, [pc, #44]	; (80006e4 <_pal_lld_init+0x54>)
 80006b8:	1c10      	adds	r0, r2, #0
 80006ba:	1c19      	adds	r1, r3, #0
 80006bc:	f7ff ffc0 	bl	8000640 <initgpio.6689.4274>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80006c0:	9b01      	ldr	r3, [sp, #4]
 80006c2:	3338      	adds	r3, #56	; 0x38
 80006c4:	4a08      	ldr	r2, [pc, #32]	; (80006e8 <_pal_lld_init+0x58>)
 80006c6:	1c10      	adds	r0, r2, #0
 80006c8:	1c19      	adds	r1, r3, #0
 80006ca:	f7ff ffb9 	bl	8000640 <initgpio.6689.4274>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 80006ce:	9b01      	ldr	r3, [sp, #4]
 80006d0:	3354      	adds	r3, #84	; 0x54
 80006d2:	4a06      	ldr	r2, [pc, #24]	; (80006ec <_pal_lld_init+0x5c>)
 80006d4:	1c10      	adds	r0, r2, #0
 80006d6:	1c19      	adds	r1, r3, #0
 80006d8:	f7ff ffb2 	bl	8000640 <initgpio.6689.4274>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 80006dc:	b003      	add	sp, #12
 80006de:	bd00      	pop	{pc}
 80006e0:	40021000 	.word	0x40021000
 80006e4:	48000400 	.word	0x48000400
 80006e8:	48000800 	.word	0x48000800
 80006ec:	48001400 	.word	0x48001400

080006f0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80006f0:	b08e      	sub	sp, #56	; 0x38
 80006f2:	9003      	str	r0, [sp, #12]
 80006f4:	9102      	str	r1, [sp, #8]
 80006f6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80006f8:	9a01      	ldr	r2, [sp, #4]
 80006fa:	2303      	movs	r3, #3
 80006fc:	4013      	ands	r3, r2
 80006fe:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000700:	9a01      	ldr	r2, [sp, #4]
 8000702:	2304      	movs	r3, #4
 8000704:	4013      	ands	r3, r2
 8000706:	089b      	lsrs	r3, r3, #2
 8000708:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800070a:	9a01      	ldr	r2, [sp, #4]
 800070c:	2318      	movs	r3, #24
 800070e:	4013      	ands	r3, r2
 8000710:	08db      	lsrs	r3, r3, #3
 8000712:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8000714:	9a01      	ldr	r2, [sp, #4]
 8000716:	2360      	movs	r3, #96	; 0x60
 8000718:	4013      	ands	r3, r2
 800071a:	095b      	lsrs	r3, r3, #5
 800071c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800071e:	9a01      	ldr	r2, [sp, #4]
 8000720:	23f0      	movs	r3, #240	; 0xf0
 8000722:	00db      	lsls	r3, r3, #3
 8000724:	4013      	ands	r3, r2
 8000726:	09db      	lsrs	r3, r3, #7
 8000728:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 800072a:	2300      	movs	r3, #0
 800072c:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800072e:	9a02      	ldr	r2, [sp, #8]
 8000730:	2301      	movs	r3, #1
 8000732:	4013      	ands	r3, r2
 8000734:	d058      	beq.n	80007e8 <_pal_lld_setgroupmode+0xf8>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000736:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8000738:	2307      	movs	r3, #7
 800073a:	4013      	ands	r3, r2
 800073c:	009b      	lsls	r3, r3, #2
 800073e:	9a08      	ldr	r2, [sp, #32]
 8000740:	1c11      	adds	r1, r2, #0
 8000742:	4099      	lsls	r1, r3
 8000744:	1c0b      	adds	r3, r1, #0
 8000746:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
 8000748:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800074a:	2307      	movs	r3, #7
 800074c:	4013      	ands	r3, r2
 800074e:	009b      	lsls	r3, r3, #2
 8000750:	220f      	movs	r2, #15
 8000752:	1c11      	adds	r1, r2, #0
 8000754:	4099      	lsls	r1, r3
 8000756:	1c0b      	adds	r3, r1, #0
 8000758:	9306      	str	r3, [sp, #24]
      if (bit < 8)
 800075a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800075c:	2b07      	cmp	r3, #7
 800075e:	d809      	bhi.n	8000774 <_pal_lld_setgroupmode+0x84>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000760:	9b03      	ldr	r3, [sp, #12]
 8000762:	6a1b      	ldr	r3, [r3, #32]
 8000764:	9a06      	ldr	r2, [sp, #24]
 8000766:	43d2      	mvns	r2, r2
 8000768:	401a      	ands	r2, r3
 800076a:	9b07      	ldr	r3, [sp, #28]
 800076c:	431a      	orrs	r2, r3
 800076e:	9b03      	ldr	r3, [sp, #12]
 8000770:	621a      	str	r2, [r3, #32]
 8000772:	e008      	b.n	8000786 <_pal_lld_setgroupmode+0x96>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000774:	9b03      	ldr	r3, [sp, #12]
 8000776:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000778:	9a06      	ldr	r2, [sp, #24]
 800077a:	43d2      	mvns	r2, r2
 800077c:	401a      	ands	r2, r3
 800077e:	9b07      	ldr	r3, [sp, #28]
 8000780:	431a      	orrs	r2, r3
 8000782:	9b03      	ldr	r3, [sp, #12]
 8000784:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
 8000786:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000788:	2201      	movs	r2, #1
 800078a:	1c11      	adds	r1, r2, #0
 800078c:	4099      	lsls	r1, r3
 800078e:	1c0b      	adds	r3, r1, #0
 8000790:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000792:	9b03      	ldr	r3, [sp, #12]
 8000794:	685b      	ldr	r3, [r3, #4]
 8000796:	9a05      	ldr	r2, [sp, #20]
 8000798:	43d2      	mvns	r2, r2
 800079a:	401a      	ands	r2, r3
 800079c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800079e:	431a      	orrs	r2, r3
 80007a0:	9b03      	ldr	r3, [sp, #12]
 80007a2:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
 80007a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80007a6:	005b      	lsls	r3, r3, #1
 80007a8:	2203      	movs	r2, #3
 80007aa:	1c11      	adds	r1, r2, #0
 80007ac:	4099      	lsls	r1, r3
 80007ae:	1c0b      	adds	r3, r1, #0
 80007b0:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80007b2:	9b03      	ldr	r3, [sp, #12]
 80007b4:	689b      	ldr	r3, [r3, #8]
 80007b6:	9a04      	ldr	r2, [sp, #16]
 80007b8:	43d2      	mvns	r2, r2
 80007ba:	401a      	ands	r2, r3
 80007bc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80007be:	431a      	orrs	r2, r3
 80007c0:	9b03      	ldr	r3, [sp, #12]
 80007c2:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80007c4:	9b03      	ldr	r3, [sp, #12]
 80007c6:	68db      	ldr	r3, [r3, #12]
 80007c8:	9a04      	ldr	r2, [sp, #16]
 80007ca:	43d2      	mvns	r2, r2
 80007cc:	401a      	ands	r2, r3
 80007ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80007d0:	431a      	orrs	r2, r3
 80007d2:	9b03      	ldr	r3, [sp, #12]
 80007d4:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 80007d6:	9b03      	ldr	r3, [sp, #12]
 80007d8:	681b      	ldr	r3, [r3, #0]
 80007da:	9a04      	ldr	r2, [sp, #16]
 80007dc:	43d2      	mvns	r2, r2
 80007de:	401a      	ands	r2, r3
 80007e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80007e2:	431a      	orrs	r2, r3
 80007e4:	9b03      	ldr	r3, [sp, #12]
 80007e6:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
 80007e8:	9b02      	ldr	r3, [sp, #8]
 80007ea:	085b      	lsrs	r3, r3, #1
 80007ec:	9302      	str	r3, [sp, #8]
    if (!mask)
 80007ee:	9b02      	ldr	r3, [sp, #8]
 80007f0:	2b00      	cmp	r3, #0
 80007f2:	d00f      	beq.n	8000814 <_pal_lld_setgroupmode+0x124>
      return;
    otyper <<= 1;
 80007f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80007f6:	005b      	lsls	r3, r3, #1
 80007f8:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 80007fa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80007fc:	009b      	lsls	r3, r3, #2
 80007fe:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8000800:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000802:	009b      	lsls	r3, r3, #2
 8000804:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8000806:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8000808:	009b      	lsls	r3, r3, #2
 800080a:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800080c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800080e:	3301      	adds	r3, #1
 8000810:	9309      	str	r3, [sp, #36]	; 0x24
 8000812:	e78c      	b.n	800072e <_pal_lld_setgroupmode+0x3e>
  }
}
 8000814:	b00e      	add	sp, #56	; 0x38
 8000816:	4770      	bx	lr
 8000818:	46c0      	nop			; (mov r8, r8)
 800081a:	46c0      	nop			; (mov r8, r8)
 800081c:	46c0      	nop			; (mov r8, r8)
 800081e:	46c0      	nop			; (mov r8, r8)

08000820 <port_lock.6760.4224>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000820:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000822:	4770      	bx	lr
 8000824:	46c0      	nop			; (mov r8, r8)
 8000826:	46c0      	nop			; (mov r8, r8)
 8000828:	46c0      	nop			; (mov r8, r8)
 800082a:	46c0      	nop			; (mov r8, r8)
 800082c:	46c0      	nop			; (mov r8, r8)
 800082e:	46c0      	nop			; (mov r8, r8)

08000830 <port_unlock.6763.4222>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000830:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000832:	4770      	bx	lr
 8000834:	46c0      	nop			; (mov r8, r8)
 8000836:	46c0      	nop			; (mov r8, r8)
 8000838:	46c0      	nop			; (mov r8, r8)
 800083a:	46c0      	nop			; (mov r8, r8)
 800083c:	46c0      	nop			; (mov r8, r8)
 800083e:	46c0      	nop			; (mov r8, r8)

08000840 <port_lock_from_isr.6765.4220>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000840:	b508      	push	{r3, lr}

  port_lock();
 8000842:	f7ff ffed 	bl	8000820 <port_lock.6760.4224>
}
 8000846:	bd08      	pop	{r3, pc}
 8000848:	46c0      	nop			; (mov r8, r8)
 800084a:	46c0      	nop			; (mov r8, r8)
 800084c:	46c0      	nop			; (mov r8, r8)
 800084e:	46c0      	nop			; (mov r8, r8)

08000850 <port_unlock_from_isr.6767.4218>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000850:	b508      	push	{r3, lr}

  port_unlock();
 8000852:	f7ff ffed 	bl	8000830 <port_unlock.6763.4222>
}
 8000856:	bd08      	pop	{r3, pc}
 8000858:	46c0      	nop			; (mov r8, r8)
 800085a:	46c0      	nop			; (mov r8, r8)
 800085c:	46c0      	nop			; (mov r8, r8)
 800085e:	46c0      	nop			; (mov r8, r8)

08000860 <chSysLockFromISR.6769.4216>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000860:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000862:	f7ff ffed 	bl	8000840 <port_lock_from_isr.6765.4220>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000866:	bd08      	pop	{r3, pc}
 8000868:	46c0      	nop			; (mov r8, r8)
 800086a:	46c0      	nop			; (mov r8, r8)
 800086c:	46c0      	nop			; (mov r8, r8)
 800086e:	46c0      	nop			; (mov r8, r8)

08000870 <chSysUnlockFromISR.6771.4214>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000870:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000872:	f7ff ffed 	bl	8000850 <port_unlock_from_isr.6767.4218>
}
 8000876:	bd08      	pop	{r3, pc}
 8000878:	46c0      	nop			; (mov r8, r8)
 800087a:	46c0      	nop			; (mov r8, r8)
 800087c:	46c0      	nop			; (mov r8, r8)
 800087e:	46c0      	nop			; (mov r8, r8)

08000880 <osalSysLockFromISR.6773.4212>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000880:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8000882:	f7ff ffed 	bl	8000860 <chSysLockFromISR.6769.4216>
}
 8000886:	bd08      	pop	{r3, pc}
 8000888:	46c0      	nop			; (mov r8, r8)
 800088a:	46c0      	nop			; (mov r8, r8)
 800088c:	46c0      	nop			; (mov r8, r8)
 800088e:	46c0      	nop			; (mov r8, r8)

08000890 <osalSysUnlockFromISR.6775.4210>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000890:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8000892:	f7ff ffed 	bl	8000870 <chSysUnlockFromISR.6771.4214>
}
 8000896:	bd08      	pop	{r3, pc}
 8000898:	46c0      	nop			; (mov r8, r8)
 800089a:	46c0      	nop			; (mov r8, r8)
 800089c:	46c0      	nop			; (mov r8, r8)
 800089e:	46c0      	nop			; (mov r8, r8)

080008a0 <osalEventBroadcastFlagsI.6777.4206>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80008a0:	b082      	sub	sp, #8
 80008a2:	9001      	str	r0, [sp, #4]
 80008a4:	9100      	str	r1, [sp, #0]

  esp->flags |= flags;
 80008a6:	9b01      	ldr	r3, [sp, #4]
 80008a8:	681a      	ldr	r2, [r3, #0]
 80008aa:	9b00      	ldr	r3, [sp, #0]
 80008ac:	431a      	orrs	r2, r3
 80008ae:	9b01      	ldr	r3, [sp, #4]
 80008b0:	601a      	str	r2, [r3, #0]
}
 80008b2:	b002      	add	sp, #8
 80008b4:	4770      	bx	lr
 80008b6:	46c0      	nop			; (mov r8, r8)
 80008b8:	46c0      	nop			; (mov r8, r8)
 80008ba:	46c0      	nop			; (mov r8, r8)
 80008bc:	46c0      	nop			; (mov r8, r8)
 80008be:	46c0      	nop			; (mov r8, r8)

080008c0 <usart_init.6863.4202>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 80008c0:	b500      	push	{lr}
 80008c2:	b085      	sub	sp, #20
 80008c4:	9001      	str	r0, [sp, #4]
 80008c6:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 80008c8:	9b01      	ldr	r3, [sp, #4]
 80008ca:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80008cc:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 80008ce:	9b01      	ldr	r3, [sp, #4]
 80008d0:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80008d2:	9b00      	ldr	r3, [sp, #0]
 80008d4:	681b      	ldr	r3, [r3, #0]
 80008d6:	1c10      	adds	r0, r2, #0
 80008d8:	1c19      	adds	r1, r3, #0
 80008da:	f7ff fc79 	bl	80001d0 <__aeabi_uidiv>
 80008de:	1c03      	adds	r3, r0, #0
 80008e0:	1c1a      	adds	r2, r3, #0
 80008e2:	9b03      	ldr	r3, [sp, #12]
 80008e4:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80008e6:	9b00      	ldr	r3, [sp, #0]
 80008e8:	689b      	ldr	r3, [r3, #8]
 80008ea:	2240      	movs	r2, #64	; 0x40
 80008ec:	431a      	orrs	r2, r3
 80008ee:	9b03      	ldr	r3, [sp, #12]
 80008f0:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80008f2:	9b00      	ldr	r3, [sp, #0]
 80008f4:	68db      	ldr	r3, [r3, #12]
 80008f6:	2201      	movs	r2, #1
 80008f8:	431a      	orrs	r2, r3
 80008fa:	9b03      	ldr	r3, [sp, #12]
 80008fc:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80008fe:	9b00      	ldr	r3, [sp, #0]
 8000900:	685b      	ldr	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8000902:	222e      	movs	r2, #46	; 0x2e
 8000904:	32ff      	adds	r2, #255	; 0xff
 8000906:	431a      	orrs	r2, r3
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000908:	9b03      	ldr	r3, [sp, #12]
 800090a:	601a      	str	r2, [r3, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800090c:	9b03      	ldr	r3, [sp, #12]
 800090e:	2201      	movs	r2, #1
 8000910:	4252      	negs	r2, r2
 8000912:	621a      	str	r2, [r3, #32]
}
 8000914:	b005      	add	sp, #20
 8000916:	bd00      	pop	{pc}
 8000918:	46c0      	nop			; (mov r8, r8)
 800091a:	46c0      	nop			; (mov r8, r8)
 800091c:	46c0      	nop			; (mov r8, r8)
 800091e:	46c0      	nop			; (mov r8, r8)

08000920 <set_error.6918.4195>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 8000920:	b500      	push	{lr}
 8000922:	b085      	sub	sp, #20
 8000924:	9001      	str	r0, [sp, #4]
 8000926:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 8000928:	2300      	movs	r3, #0
 800092a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 800092c:	9a00      	ldr	r2, [sp, #0]
 800092e:	2308      	movs	r3, #8
 8000930:	4013      	ands	r3, r2
 8000932:	d003      	beq.n	800093c <set_error.6918.4195+0x1c>
    sts |= SD_OVERRUN_ERROR;
 8000934:	9b03      	ldr	r3, [sp, #12]
 8000936:	2280      	movs	r2, #128	; 0x80
 8000938:	4313      	orrs	r3, r2
 800093a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 800093c:	9a00      	ldr	r2, [sp, #0]
 800093e:	2301      	movs	r3, #1
 8000940:	4013      	ands	r3, r2
 8000942:	d003      	beq.n	800094c <set_error.6918.4195+0x2c>
    sts |= SD_PARITY_ERROR;
 8000944:	9b03      	ldr	r3, [sp, #12]
 8000946:	2220      	movs	r2, #32
 8000948:	4313      	orrs	r3, r2
 800094a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 800094c:	9a00      	ldr	r2, [sp, #0]
 800094e:	2302      	movs	r3, #2
 8000950:	4013      	ands	r3, r2
 8000952:	d003      	beq.n	800095c <set_error.6918.4195+0x3c>
    sts |= SD_FRAMING_ERROR;
 8000954:	9b03      	ldr	r3, [sp, #12]
 8000956:	2240      	movs	r2, #64	; 0x40
 8000958:	4313      	orrs	r3, r2
 800095a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 800095c:	9a00      	ldr	r2, [sp, #0]
 800095e:	2304      	movs	r3, #4
 8000960:	4013      	ands	r3, r2
 8000962:	d004      	beq.n	800096e <set_error.6918.4195+0x4e>
    sts |= SD_NOISE_ERROR;
 8000964:	9b03      	ldr	r3, [sp, #12]
 8000966:	2280      	movs	r2, #128	; 0x80
 8000968:	0052      	lsls	r2, r2, #1
 800096a:	4313      	orrs	r3, r2
 800096c:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 800096e:	f7ff ff87 	bl	8000880 <osalSysLockFromISR.6773.4212>
  chnAddFlagsI(sdp, sts);
 8000972:	9b01      	ldr	r3, [sp, #4]
 8000974:	1d1a      	adds	r2, r3, #4
 8000976:	9b03      	ldr	r3, [sp, #12]
 8000978:	1c10      	adds	r0, r2, #0
 800097a:	1c19      	adds	r1, r3, #0
 800097c:	f7ff ff90 	bl	80008a0 <osalEventBroadcastFlagsI.6777.4206>
  osalSysUnlockFromISR();
 8000980:	f7ff ff86 	bl	8000890 <osalSysUnlockFromISR.6775.4210>
}
 8000984:	b005      	add	sp, #20
 8000986:	bd00      	pop	{pc}
 8000988:	46c0      	nop			; (mov r8, r8)
 800098a:	46c0      	nop			; (mov r8, r8)
 800098c:	46c0      	nop			; (mov r8, r8)
 800098e:	46c0      	nop			; (mov r8, r8)

08000990 <serve_interrupt.6922.4192>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000990:	b500      	push	{lr}
 8000992:	b087      	sub	sp, #28
 8000994:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8000996:	9b01      	ldr	r3, [sp, #4]
 8000998:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800099a:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 800099c:	9b05      	ldr	r3, [sp, #20]
 800099e:	681b      	ldr	r3, [r3, #0]
 80009a0:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80009a2:	9b05      	ldr	r3, [sp, #20]
 80009a4:	69db      	ldr	r3, [r3, #28]
 80009a6:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 80009a8:	9b05      	ldr	r3, [sp, #20]
 80009aa:	9a03      	ldr	r2, [sp, #12]
 80009ac:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80009ae:	9a03      	ldr	r2, [sp, #12]
 80009b0:	230f      	movs	r3, #15
 80009b2:	4013      	ands	r3, r2
 80009b4:	d005      	beq.n	80009c2 <serve_interrupt.6922.4192+0x32>
    set_error(sdp, isr);
 80009b6:	9a01      	ldr	r2, [sp, #4]
 80009b8:	9b03      	ldr	r3, [sp, #12]
 80009ba:	1c10      	adds	r0, r2, #0
 80009bc:	1c19      	adds	r1, r3, #0
 80009be:	f7ff ffaf 	bl	8000920 <set_error.6918.4195>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80009c2:	9a03      	ldr	r2, [sp, #12]
 80009c4:	2380      	movs	r3, #128	; 0x80
 80009c6:	005b      	lsls	r3, r3, #1
 80009c8:	4013      	ands	r3, r2
 80009ca:	d00b      	beq.n	80009e4 <serve_interrupt.6922.4192+0x54>
    osalSysLockFromISR();
 80009cc:	f7ff ff58 	bl	8000880 <osalSysLockFromISR.6773.4212>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 80009d0:	9b01      	ldr	r3, [sp, #4]
 80009d2:	1d1a      	adds	r2, r3, #4
 80009d4:	2380      	movs	r3, #128	; 0x80
 80009d6:	009b      	lsls	r3, r3, #2
 80009d8:	1c10      	adds	r0, r2, #0
 80009da:	1c19      	adds	r1, r3, #0
 80009dc:	f7ff ff60 	bl	80008a0 <osalEventBroadcastFlagsI.6777.4206>
    osalSysUnlockFromISR();
 80009e0:	f7ff ff56 	bl	8000890 <osalSysUnlockFromISR.6775.4210>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 80009e4:	9a03      	ldr	r2, [sp, #12]
 80009e6:	2320      	movs	r3, #32
 80009e8:	4013      	ands	r3, r2
 80009ea:	d00c      	beq.n	8000a06 <serve_interrupt.6922.4192+0x76>
    osalSysLockFromISR();
 80009ec:	f7ff ff48 	bl	8000880 <osalSysLockFromISR.6773.4212>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 80009f0:	9b05      	ldr	r3, [sp, #20]
 80009f2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80009f4:	b29b      	uxth	r3, r3
 80009f6:	b2db      	uxtb	r3, r3
 80009f8:	9a01      	ldr	r2, [sp, #4]
 80009fa:	1c10      	adds	r0, r2, #0
 80009fc:	1c19      	adds	r1, r3, #0
 80009fe:	f7ff fc3f 	bl	8000280 <sdIncomingDataI.4334>
    osalSysUnlockFromISR();
 8000a02:	f7ff ff45 	bl	8000890 <osalSysUnlockFromISR.6775.4210>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000a06:	9a04      	ldr	r2, [sp, #16]
 8000a08:	2380      	movs	r3, #128	; 0x80
 8000a0a:	4013      	ands	r3, r2
 8000a0c:	d023      	beq.n	8000a56 <serve_interrupt.6922.4192+0xc6>
 8000a0e:	9a03      	ldr	r2, [sp, #12]
 8000a10:	2380      	movs	r3, #128	; 0x80
 8000a12:	4013      	ands	r3, r2
 8000a14:	d01f      	beq.n	8000a56 <serve_interrupt.6922.4192+0xc6>
    msg_t b;
    osalSysLockFromISR();
 8000a16:	f7ff ff33 	bl	8000880 <osalSysLockFromISR.6773.4212>
    b = oqGetI(&sdp->oqueue);
 8000a1a:	9b01      	ldr	r3, [sp, #4]
 8000a1c:	3330      	adds	r3, #48	; 0x30
 8000a1e:	1c18      	adds	r0, r3, #0
 8000a20:	f000 fd7e 	bl	8001520 <oqGetI>
 8000a24:	1c03      	adds	r3, r0, #0
 8000a26:	9302      	str	r3, [sp, #8]
    if (b < Q_OK) {
 8000a28:	9b02      	ldr	r3, [sp, #8]
 8000a2a:	2b00      	cmp	r3, #0
 8000a2c:	da0d      	bge.n	8000a4a <serve_interrupt.6922.4192+0xba>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000a2e:	9b01      	ldr	r3, [sp, #4]
 8000a30:	3304      	adds	r3, #4
 8000a32:	1c18      	adds	r0, r3, #0
 8000a34:	2108      	movs	r1, #8
 8000a36:	f7ff ff33 	bl	80008a0 <osalEventBroadcastFlagsI.6777.4206>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000a3a:	9b04      	ldr	r3, [sp, #16]
 8000a3c:	22c0      	movs	r2, #192	; 0xc0
 8000a3e:	4393      	bics	r3, r2
 8000a40:	2240      	movs	r2, #64	; 0x40
 8000a42:	431a      	orrs	r2, r3
 8000a44:	9b05      	ldr	r3, [sp, #20]
 8000a46:	601a      	str	r2, [r3, #0]
 8000a48:	e003      	b.n	8000a52 <serve_interrupt.6922.4192+0xc2>
    }
    else
      u->TDR = b;
 8000a4a:	9b02      	ldr	r3, [sp, #8]
 8000a4c:	b29a      	uxth	r2, r3
 8000a4e:	9b05      	ldr	r3, [sp, #20]
 8000a50:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 8000a52:	f7ff ff1d 	bl	8000890 <osalSysUnlockFromISR.6775.4210>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000a56:	9a03      	ldr	r2, [sp, #12]
 8000a58:	2340      	movs	r3, #64	; 0x40
 8000a5a:	4013      	ands	r3, r2
 8000a5c:	d023      	beq.n	8000aa6 <serve_interrupt.6922.4192+0x116>
    osalSysLockFromISR();
 8000a5e:	f7ff ff0f 	bl	8000880 <osalSysLockFromISR.6773.4212>
    if (oqIsEmptyI(&sdp->oqueue))
 8000a62:	9b01      	ldr	r3, [sp, #4]
 8000a64:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000a66:	9b01      	ldr	r3, [sp, #4]
 8000a68:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000a6a:	429a      	cmp	r2, r3
 8000a6c:	d105      	bne.n	8000a7a <serve_interrupt.6922.4192+0xea>
 8000a6e:	9b01      	ldr	r3, [sp, #4]
 8000a70:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000a72:	2b00      	cmp	r3, #0
 8000a74:	d001      	beq.n	8000a7a <serve_interrupt.6922.4192+0xea>
 8000a76:	2301      	movs	r3, #1
 8000a78:	e000      	b.n	8000a7c <serve_interrupt.6922.4192+0xec>
 8000a7a:	2300      	movs	r3, #0
 8000a7c:	1c1a      	adds	r2, r3, #0
 8000a7e:	2301      	movs	r3, #1
 8000a80:	4013      	ands	r3, r2
 8000a82:	b2db      	uxtb	r3, r3
 8000a84:	2b00      	cmp	r3, #0
 8000a86:	d005      	beq.n	8000a94 <serve_interrupt.6922.4192+0x104>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000a88:	9b01      	ldr	r3, [sp, #4]
 8000a8a:	3304      	adds	r3, #4
 8000a8c:	1c18      	adds	r0, r3, #0
 8000a8e:	2110      	movs	r1, #16
 8000a90:	f7ff ff06 	bl	80008a0 <osalEventBroadcastFlagsI.6777.4206>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000a94:	9b04      	ldr	r3, [sp, #16]
 8000a96:	2240      	movs	r2, #64	; 0x40
 8000a98:	1c19      	adds	r1, r3, #0
 8000a9a:	4391      	bics	r1, r2
 8000a9c:	1c0a      	adds	r2, r1, #0
 8000a9e:	9b05      	ldr	r3, [sp, #20]
 8000aa0:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8000aa2:	f7ff fef5 	bl	8000890 <osalSysUnlockFromISR.6775.4210>
  }
}
 8000aa6:	b007      	add	sp, #28
 8000aa8:	bd00      	pop	{pc}
 8000aaa:	46c0      	nop			; (mov r8, r8)
 8000aac:	46c0      	nop			; (mov r8, r8)
 8000aae:	46c0      	nop			; (mov r8, r8)

08000ab0 <notify1.6787.4187>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 8000ab0:	b082      	sub	sp, #8
 8000ab2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000ab4:	4b03      	ldr	r3, [pc, #12]	; (8000ac4 <notify1.6787.4187+0x14>)
 8000ab6:	4a03      	ldr	r2, [pc, #12]	; (8000ac4 <notify1.6787.4187+0x14>)
 8000ab8:	6812      	ldr	r2, [r2, #0]
 8000aba:	2180      	movs	r1, #128	; 0x80
 8000abc:	430a      	orrs	r2, r1
 8000abe:	601a      	str	r2, [r3, #0]
}
 8000ac0:	b002      	add	sp, #8
 8000ac2:	4770      	bx	lr
 8000ac4:	40013800 	.word	0x40013800
 8000ac8:	46c0      	nop			; (mov r8, r8)
 8000aca:	46c0      	nop			; (mov r8, r8)
 8000acc:	46c0      	nop			; (mov r8, r8)
 8000ace:	46c0      	nop			; (mov r8, r8)

08000ad0 <VectorAC.4190>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000ad0:	b500      	push	{lr}
 8000ad2:	b083      	sub	sp, #12
 8000ad4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000ad6:	9301      	str	r3, [sp, #4]

  serve_interrupt(&SD1);
 8000ad8:	4b04      	ldr	r3, [pc, #16]	; (8000aec <VectorAC.4190+0x1c>)
 8000ada:	1c18      	adds	r0, r3, #0
 8000adc:	f7ff ff58 	bl	8000990 <serve_interrupt.6922.4192>

  OSAL_IRQ_EPILOGUE();
 8000ae0:	9b01      	ldr	r3, [sp, #4]
 8000ae2:	1c18      	adds	r0, r3, #0
 8000ae4:	f000 fa6c 	bl	8000fc0 <_port_irq_epilogue>
}
 8000ae8:	b003      	add	sp, #12
 8000aea:	bd00      	pop	{pc}
 8000aec:	20000450 	.word	0x20000450

08000af0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8000af0:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8000af2:	4a09      	ldr	r2, [pc, #36]	; (8000b18 <sd_lld_init+0x28>)
 8000af4:	4b09      	ldr	r3, [pc, #36]	; (8000b1c <sd_lld_init+0x2c>)
 8000af6:	1c10      	adds	r0, r2, #0
 8000af8:	2100      	movs	r1, #0
 8000afa:	1c1a      	adds	r2, r3, #0
 8000afc:	f000 fec8 	bl	8001890 <sdObjectInit>
  SD1.usart = USART1;
 8000b00:	4b05      	ldr	r3, [pc, #20]	; (8000b18 <sd_lld_init+0x28>)
 8000b02:	4a07      	ldr	r2, [pc, #28]	; (8000b20 <sd_lld_init+0x30>)
 8000b04:	675a      	str	r2, [r3, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 8000b06:	4b04      	ldr	r3, [pc, #16]	; (8000b18 <sd_lld_init+0x28>)
 8000b08:	4a06      	ldr	r2, [pc, #24]	; (8000b24 <sd_lld_init+0x34>)
 8000b0a:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_USART1_NUMBER)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8000b0c:	201b      	movs	r0, #27
 8000b0e:	2103      	movs	r1, #3
 8000b10:	f7ff fbde 	bl	80002d0 <nvicEnableVector.4320>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8000b14:	bd08      	pop	{r3, pc}
 8000b16:	46c0      	nop			; (mov r8, r8)
 8000b18:	20000450 	.word	0x20000450
 8000b1c:	08000ab1 	.word	0x08000ab1
 8000b20:	40013800 	.word	0x40013800
 8000b24:	02dc6c00 	.word	0x02dc6c00
 8000b28:	46c0      	nop			; (mov r8, r8)
 8000b2a:	46c0      	nop			; (mov r8, r8)
 8000b2c:	46c0      	nop			; (mov r8, r8)
 8000b2e:	46c0      	nop			; (mov r8, r8)

08000b30 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8000b30:	b500      	push	{lr}
 8000b32:	b083      	sub	sp, #12
 8000b34:	9001      	str	r0, [sp, #4]
 8000b36:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8000b38:	9b00      	ldr	r3, [sp, #0]
 8000b3a:	2b00      	cmp	r3, #0
 8000b3c:	d101      	bne.n	8000b42 <sd_lld_start+0x12>
    config = &default_config;
 8000b3e:	4b0c      	ldr	r3, [pc, #48]	; (8000b70 <sd_lld_start+0x40>)
 8000b40:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8000b42:	9b01      	ldr	r3, [sp, #4]
 8000b44:	7a1b      	ldrb	r3, [r3, #8]
 8000b46:	2b01      	cmp	r3, #1
 8000b48:	d10a      	bne.n	8000b60 <sd_lld_start+0x30>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 8000b4a:	9a01      	ldr	r2, [sp, #4]
 8000b4c:	4b09      	ldr	r3, [pc, #36]	; (8000b74 <sd_lld_start+0x44>)
 8000b4e:	429a      	cmp	r2, r3
 8000b50:	d106      	bne.n	8000b60 <sd_lld_start+0x30>
      rccEnableUSART1(FALSE);
 8000b52:	4b09      	ldr	r3, [pc, #36]	; (8000b78 <sd_lld_start+0x48>)
 8000b54:	4a08      	ldr	r2, [pc, #32]	; (8000b78 <sd_lld_start+0x48>)
 8000b56:	6992      	ldr	r2, [r2, #24]
 8000b58:	2180      	movs	r1, #128	; 0x80
 8000b5a:	01c9      	lsls	r1, r1, #7
 8000b5c:	430a      	orrs	r2, r1
 8000b5e:	619a      	str	r2, [r3, #24]
    if (&SD8 == sdp) {
      rccEnableUART8(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
 8000b60:	9a01      	ldr	r2, [sp, #4]
 8000b62:	9b00      	ldr	r3, [sp, #0]
 8000b64:	1c10      	adds	r0, r2, #0
 8000b66:	1c19      	adds	r1, r3, #0
 8000b68:	f7ff feaa 	bl	80008c0 <usart_init.6863.4202>
}
 8000b6c:	b003      	add	sp, #12
 8000b6e:	bd00      	pop	{pc}
 8000b70:	08002750 	.word	0x08002750
 8000b74:	20000450 	.word	0x20000450
 8000b78:	40021000 	.word	0x40021000
 8000b7c:	46c0      	nop			; (mov r8, r8)
 8000b7e:	46c0      	nop			; (mov r8, r8)

08000b80 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8000b80:	b508      	push	{r3, lr}

  stm32_clock_init();
 8000b82:	f7ff fc4d 	bl	8000420 <stm32_clock_init.4302>
}
 8000b86:	bd08      	pop	{r3, pc}
 8000b88:	46c0      	nop			; (mov r8, r8)
 8000b8a:	46c0      	nop			; (mov r8, r8)
 8000b8c:	46c0      	nop			; (mov r8, r8)
 8000b8e:	46c0      	nop			; (mov r8, r8)

08000b90 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8000b90:	4770      	bx	lr
 8000b92:	46c0      	nop			; (mov r8, r8)
 8000b94:	46c0      	nop			; (mov r8, r8)
 8000b96:	46c0      	nop			; (mov r8, r8)
 8000b98:	46c0      	nop			; (mov r8, r8)
 8000b9a:	46c0      	nop			; (mov r8, r8)
 8000b9c:	46c0      	nop			; (mov r8, r8)
 8000b9e:	46c0      	nop			; (mov r8, r8)

08000ba0 <reflect.6989.4035>:
 * Returns:		The reflection of the original data.
 *
 *********************************************************************/
static unsigned long
reflect(unsigned long data, unsigned char nBits)
{
 8000ba0:	b084      	sub	sp, #16
 8000ba2:	9001      	str	r0, [sp, #4]
 8000ba4:	1c0a      	adds	r2, r1, #0
 8000ba6:	466b      	mov	r3, sp
 8000ba8:	3303      	adds	r3, #3
 8000baa:	701a      	strb	r2, [r3, #0]
	unsigned long  reflection = 0x00000000;
 8000bac:	2300      	movs	r3, #0
 8000bae:	9303      	str	r3, [sp, #12]
	unsigned char  bit;

	/*
	 * Reflect the data about the center bit.
	 */
	for (bit = 0; bit < nBits; ++bit)
 8000bb0:	466b      	mov	r3, sp
 8000bb2:	330b      	adds	r3, #11
 8000bb4:	2200      	movs	r2, #0
 8000bb6:	701a      	strb	r2, [r3, #0]
 8000bb8:	e01c      	b.n	8000bf4 <reflect.6989.4035+0x54>
	{
		/*
		 * If the LSB bit is set, set the reflection of it.
		 */
		if (data & 0x01)
 8000bba:	9a01      	ldr	r2, [sp, #4]
 8000bbc:	2301      	movs	r3, #1
 8000bbe:	4013      	ands	r3, r2
 8000bc0:	d00e      	beq.n	8000be0 <reflect.6989.4035+0x40>
		{
			reflection |= (1 << ((nBits - 1) - bit));
 8000bc2:	466b      	mov	r3, sp
 8000bc4:	3303      	adds	r3, #3
 8000bc6:	781b      	ldrb	r3, [r3, #0]
 8000bc8:	1e5a      	subs	r2, r3, #1
 8000bca:	466b      	mov	r3, sp
 8000bcc:	330b      	adds	r3, #11
 8000bce:	781b      	ldrb	r3, [r3, #0]
 8000bd0:	1ad3      	subs	r3, r2, r3
 8000bd2:	2201      	movs	r2, #1
 8000bd4:	1c11      	adds	r1, r2, #0
 8000bd6:	4099      	lsls	r1, r3
 8000bd8:	1c0b      	adds	r3, r1, #0
 8000bda:	9a03      	ldr	r2, [sp, #12]
 8000bdc:	4313      	orrs	r3, r2
 8000bde:	9303      	str	r3, [sp, #12]
		}

		data = (data >> 1);
 8000be0:	9b01      	ldr	r3, [sp, #4]
 8000be2:	085b      	lsrs	r3, r3, #1
 8000be4:	9301      	str	r3, [sp, #4]
	unsigned char  bit;

	/*
	 * Reflect the data about the center bit.
	 */
	for (bit = 0; bit < nBits; ++bit)
 8000be6:	466b      	mov	r3, sp
 8000be8:	330b      	adds	r3, #11
 8000bea:	466a      	mov	r2, sp
 8000bec:	320b      	adds	r2, #11
 8000bee:	7812      	ldrb	r2, [r2, #0]
 8000bf0:	3201      	adds	r2, #1
 8000bf2:	701a      	strb	r2, [r3, #0]
 8000bf4:	466a      	mov	r2, sp
 8000bf6:	320b      	adds	r2, #11
 8000bf8:	466b      	mov	r3, sp
 8000bfa:	3303      	adds	r3, #3
 8000bfc:	7812      	ldrb	r2, [r2, #0]
 8000bfe:	781b      	ldrb	r3, [r3, #0]
 8000c00:	429a      	cmp	r2, r3
 8000c02:	d3da      	bcc.n	8000bba <reflect.6989.4035+0x1a>
		}

		data = (data >> 1);
	}

	return (reflection);
 8000c04:	9b03      	ldr	r3, [sp, #12]

}	/* reflect() */
 8000c06:	1c18      	adds	r0, r3, #0
 8000c08:	b004      	add	sp, #16
 8000c0a:	4770      	bx	lr
 8000c0c:	46c0      	nop			; (mov r8, r8)
 8000c0e:	46c0      	nop			; (mov r8, r8)

08000c10 <crcFast.4023>:
 * Returns:		The CRC of the message.
 *
 *********************************************************************/
crc
crcFast(unsigned char  message[], int nBytes)
{
 8000c10:	b500      	push	{lr}
 8000c12:	b087      	sub	sp, #28
 8000c14:	9001      	str	r0, [sp, #4]
 8000c16:	9100      	str	r1, [sp, #0]
    crc	           remainder = INITIAL_REMAINDER;
 8000c18:	466b      	mov	r3, sp
 8000c1a:	3316      	adds	r3, #22
 8000c1c:	2200      	movs	r2, #0
 8000c1e:	801a      	strh	r2, [r3, #0]


    /*
     * Divide the message by the polynomial, a byte at a time.
     */
    for (byte = 0; byte < nBytes; ++byte)
 8000c20:	2300      	movs	r3, #0
 8000c22:	9304      	str	r3, [sp, #16]
 8000c24:	e027      	b.n	8000c76 <crcFast.4023+0x66>
    {
        data = REFLECT_DATA(message[byte]) ^ (remainder >> (WIDTH - 8));
 8000c26:	9b04      	ldr	r3, [sp, #16]
 8000c28:	9a01      	ldr	r2, [sp, #4]
 8000c2a:	18d3      	adds	r3, r2, r3
 8000c2c:	781b      	ldrb	r3, [r3, #0]
 8000c2e:	1c18      	adds	r0, r3, #0
 8000c30:	2108      	movs	r1, #8
 8000c32:	f7ff ffb5 	bl	8000ba0 <reflect.6989.4035>
 8000c36:	1c03      	adds	r3, r0, #0
 8000c38:	b2d9      	uxtb	r1, r3
 8000c3a:	466b      	mov	r3, sp
 8000c3c:	3316      	adds	r3, #22
 8000c3e:	881b      	ldrh	r3, [r3, #0]
 8000c40:	0a1b      	lsrs	r3, r3, #8
 8000c42:	b29b      	uxth	r3, r3
 8000c44:	b2da      	uxtb	r2, r3
 8000c46:	466b      	mov	r3, sp
 8000c48:	330f      	adds	r3, #15
 8000c4a:	404a      	eors	r2, r1
 8000c4c:	701a      	strb	r2, [r3, #0]
  		remainder = crcTable[data] ^ (remainder << 8);
 8000c4e:	466b      	mov	r3, sp
 8000c50:	330f      	adds	r3, #15
 8000c52:	781a      	ldrb	r2, [r3, #0]
 8000c54:	4b10      	ldr	r3, [pc, #64]	; (8000c98 <crcFast.4023+0x88>)
 8000c56:	0052      	lsls	r2, r2, #1
 8000c58:	5ad3      	ldrh	r3, [r2, r3]
 8000c5a:	b29a      	uxth	r2, r3
 8000c5c:	466b      	mov	r3, sp
 8000c5e:	3316      	adds	r3, #22
 8000c60:	881b      	ldrh	r3, [r3, #0]
 8000c62:	021b      	lsls	r3, r3, #8
 8000c64:	b29b      	uxth	r3, r3
 8000c66:	4053      	eors	r3, r2
 8000c68:	b29a      	uxth	r2, r3
 8000c6a:	466b      	mov	r3, sp
 8000c6c:	3316      	adds	r3, #22
 8000c6e:	801a      	strh	r2, [r3, #0]


    /*
     * Divide the message by the polynomial, a byte at a time.
     */
    for (byte = 0; byte < nBytes; ++byte)
 8000c70:	9b04      	ldr	r3, [sp, #16]
 8000c72:	3301      	adds	r3, #1
 8000c74:	9304      	str	r3, [sp, #16]
 8000c76:	9a04      	ldr	r2, [sp, #16]
 8000c78:	9b00      	ldr	r3, [sp, #0]
 8000c7a:	429a      	cmp	r2, r3
 8000c7c:	dbd3      	blt.n	8000c26 <crcFast.4023+0x16>
    }

    /*
     * The final remainder is the CRC.
     */
    return (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
 8000c7e:	466b      	mov	r3, sp
 8000c80:	3316      	adds	r3, #22
 8000c82:	881b      	ldrh	r3, [r3, #0]
 8000c84:	1c18      	adds	r0, r3, #0
 8000c86:	2110      	movs	r1, #16
 8000c88:	f7ff ff8a 	bl	8000ba0 <reflect.6989.4035>
 8000c8c:	1c03      	adds	r3, r0, #0
 8000c8e:	b29b      	uxth	r3, r3

}   /* crcFast() */
 8000c90:	1c18      	adds	r0, r3, #0
 8000c92:	b007      	add	sp, #28
 8000c94:	bd00      	pop	{pc}
 8000c96:	46c0      	nop			; (mov r8, r8)
 8000c98:	200004cc 	.word	0x200004cc
 8000c9c:	46c0      	nop			; (mov r8, r8)
 8000c9e:	46c0      	nop			; (mov r8, r8)

08000ca0 <prepareForSend.7009.4016>:
#define ID  0xF0
#define TO	0x10


static void prepareForSend(uint8_t *packet, uint8_t msg)
{
 8000ca0:	b510      	push	{r4, lr}
 8000ca2:	b084      	sub	sp, #16
 8000ca4:	9001      	str	r0, [sp, #4]
 8000ca6:	1c0a      	adds	r2, r1, #0
 8000ca8:	466b      	mov	r3, sp
 8000caa:	3303      	adds	r3, #3
 8000cac:	701a      	strb	r2, [r3, #0]
	uint16_t crcRes = crcFast(packet, 4);
 8000cae:	466c      	mov	r4, sp
 8000cb0:	340e      	adds	r4, #14
 8000cb2:	9b01      	ldr	r3, [sp, #4]
 8000cb4:	1c18      	adds	r0, r3, #0
 8000cb6:	2104      	movs	r1, #4
 8000cb8:	f7ff ffaa 	bl	8000c10 <crcFast.4023>
 8000cbc:	1c03      	adds	r3, r0, #0
 8000cbe:	8023      	strh	r3, [r4, #0]
	packet[0] = SOH;
 8000cc0:	9b01      	ldr	r3, [sp, #4]
 8000cc2:	2201      	movs	r2, #1
 8000cc4:	701a      	strb	r2, [r3, #0]
	packet[1] = ID;
 8000cc6:	9b01      	ldr	r3, [sp, #4]
 8000cc8:	3301      	adds	r3, #1
 8000cca:	22f0      	movs	r2, #240	; 0xf0
 8000ccc:	701a      	strb	r2, [r3, #0]
	packet[2] = TO;
 8000cce:	9b01      	ldr	r3, [sp, #4]
 8000cd0:	3302      	adds	r3, #2
 8000cd2:	2210      	movs	r2, #16
 8000cd4:	701a      	strb	r2, [r3, #0]
	packet[3] = msg;
 8000cd6:	9b01      	ldr	r3, [sp, #4]
 8000cd8:	3303      	adds	r3, #3
 8000cda:	466a      	mov	r2, sp
 8000cdc:	3203      	adds	r2, #3
 8000cde:	7812      	ldrb	r2, [r2, #0]
 8000ce0:	701a      	strb	r2, [r3, #0]
	packet[4] = crcRes >> 8;//high byte
 8000ce2:	9b01      	ldr	r3, [sp, #4]
 8000ce4:	3304      	adds	r3, #4
 8000ce6:	466a      	mov	r2, sp
 8000ce8:	320e      	adds	r2, #14
 8000cea:	8812      	ldrh	r2, [r2, #0]
 8000cec:	0a12      	lsrs	r2, r2, #8
 8000cee:	b292      	uxth	r2, r2
 8000cf0:	b2d2      	uxtb	r2, r2
 8000cf2:	701a      	strb	r2, [r3, #0]
	packet[5] = crcRes;//low byte
 8000cf4:	9b01      	ldr	r3, [sp, #4]
 8000cf6:	3305      	adds	r3, #5
 8000cf8:	466a      	mov	r2, sp
 8000cfa:	320e      	adds	r2, #14
 8000cfc:	8812      	ldrh	r2, [r2, #0]
 8000cfe:	b2d2      	uxtb	r2, r2
 8000d00:	701a      	strb	r2, [r3, #0]
	packet[6] = EOT;
 8000d02:	9b01      	ldr	r3, [sp, #4]
 8000d04:	3306      	adds	r3, #6
 8000d06:	2204      	movs	r2, #4
 8000d08:	701a      	strb	r2, [r3, #0]
	return;
}
 8000d0a:	b004      	add	sp, #16
 8000d0c:	bd10      	pop	{r4, pc}
 8000d0e:	46c0      	nop			; (mov r8, r8)

08000d10 <main>:
int main(void)
{
 8000d10:	b500      	push	{lr}
 8000d12:	b087      	sub	sp, #28
	halInit();
 8000d14:	f000 f98c 	bl	8001030 <halInit>
	chSysInit();
 8000d18:	f000 ffaa 	bl	8001c70 <chSysInit>
	uint16_t rawSample = 0;
 8000d1c:	466b      	mov	r3, sp
 8000d1e:	3316      	adds	r3, #22
 8000d20:	2200      	movs	r2, #0
 8000d22:	801a      	strh	r2, [r3, #0]
	uint8_t portSample;
	uint8_t packet[7];
    palSetGroupMode(GPIOA, A1TO10, 0, PAL_MODE_INPUT_PULLDOWN);
 8000d24:	2390      	movs	r3, #144	; 0x90
 8000d26:	05da      	lsls	r2, r3, #23
 8000d28:	4b3b      	ldr	r3, [pc, #236]	; (8000e18 <main+0x108>)
 8000d2a:	1c10      	adds	r0, r2, #0
 8000d2c:	1c19      	adds	r1, r3, #0
 8000d2e:	2240      	movs	r2, #64	; 0x40
 8000d30:	f7ff fcde 	bl	80006f0 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, GPIOA_USART_TX, PAL_MODE_ALTERNATE(1)); // used function : USART1_TX
 8000d34:	2390      	movs	r3, #144	; 0x90
 8000d36:	05db      	lsls	r3, r3, #23
 8000d38:	1c18      	adds	r0, r3, #0
 8000d3a:	2104      	movs	r1, #4
 8000d3c:	2282      	movs	r2, #130	; 0x82
 8000d3e:	f7ff fcd7 	bl	80006f0 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, GPIOA_USART_RX, PAL_MODE_ALTERNATE(1)); // used function : USART1_RX
 8000d42:	2390      	movs	r3, #144	; 0x90
 8000d44:	05db      	lsls	r3, r3, #23
 8000d46:	1c18      	adds	r0, r3, #0
 8000d48:	2108      	movs	r1, #8
 8000d4a:	2282      	movs	r2, #130	; 0x82
 8000d4c:	f7ff fcd0 	bl	80006f0 <_pal_lld_setgroupmode>
	sdStart(&SD1, NULL);
 8000d50:	4b32      	ldr	r3, [pc, #200]	; (8000e1c <main+0x10c>)
 8000d52:	1c18      	adds	r0, r3, #0
 8000d54:	2100      	movs	r1, #0
 8000d56:	f000 fdcb 	bl	80018f0 <sdStart>

	volatile long i,j;
	while(!0)
	{
		portSample = 0;
 8000d5a:	466b      	mov	r3, sp
 8000d5c:	3315      	adds	r3, #21
 8000d5e:	2200      	movs	r2, #0
 8000d60:	701a      	strb	r2, [r3, #0]
		rawSample = palReadGroup(GPIOA, A1TO10, 0);
 8000d62:	2390      	movs	r3, #144	; 0x90
 8000d64:	05db      	lsls	r3, r3, #23
 8000d66:	691b      	ldr	r3, [r3, #16]
 8000d68:	b299      	uxth	r1, r3
 8000d6a:	466b      	mov	r3, sp
 8000d6c:	3316      	adds	r3, #22
 8000d6e:	4a2a      	ldr	r2, [pc, #168]	; (8000e18 <main+0x108>)
 8000d70:	400a      	ands	r2, r1
 8000d72:	801a      	strh	r2, [r3, #0]
		portSample |= (MASKA0A1 & rawSample);
 8000d74:	466b      	mov	r3, sp
 8000d76:	3316      	adds	r3, #22
 8000d78:	881b      	ldrh	r3, [r3, #0]
 8000d7a:	b2da      	uxtb	r2, r3
 8000d7c:	2303      	movs	r3, #3
 8000d7e:	4013      	ands	r3, r2
 8000d80:	b2d9      	uxtb	r1, r3
 8000d82:	466b      	mov	r3, sp
 8000d84:	3315      	adds	r3, #21
 8000d86:	466a      	mov	r2, sp
 8000d88:	3215      	adds	r2, #21
 8000d8a:	7812      	ldrb	r2, [r2, #0]
 8000d8c:	430a      	orrs	r2, r1
 8000d8e:	701a      	strb	r2, [r3, #0]
		portSample |= (MASKA4A7 & rawSample) >> 2;
 8000d90:	466b      	mov	r3, sp
 8000d92:	3316      	adds	r3, #22
 8000d94:	881a      	ldrh	r2, [r3, #0]
 8000d96:	23f0      	movs	r3, #240	; 0xf0
 8000d98:	4013      	ands	r3, r2
 8000d9a:	b29b      	uxth	r3, r3
 8000d9c:	089b      	lsrs	r3, r3, #2
 8000d9e:	b29b      	uxth	r3, r3
 8000da0:	b2d9      	uxtb	r1, r3
 8000da2:	466b      	mov	r3, sp
 8000da4:	3315      	adds	r3, #21
 8000da6:	466a      	mov	r2, sp
 8000da8:	3215      	adds	r2, #21
 8000daa:	7812      	ldrb	r2, [r2, #0]
 8000dac:	430a      	orrs	r2, r1
 8000dae:	701a      	strb	r2, [r3, #0]
		portSample |= (MASKA9A10 & rawSample) >> 3;
 8000db0:	466b      	mov	r3, sp
 8000db2:	3316      	adds	r3, #22
 8000db4:	881a      	ldrh	r2, [r3, #0]
 8000db6:	23c0      	movs	r3, #192	; 0xc0
 8000db8:	00db      	lsls	r3, r3, #3
 8000dba:	4013      	ands	r3, r2
 8000dbc:	b29b      	uxth	r3, r3
 8000dbe:	08db      	lsrs	r3, r3, #3
 8000dc0:	b29b      	uxth	r3, r3
 8000dc2:	b2d9      	uxtb	r1, r3
 8000dc4:	466b      	mov	r3, sp
 8000dc6:	3315      	adds	r3, #21
 8000dc8:	466a      	mov	r2, sp
 8000dca:	3215      	adds	r2, #21
 8000dcc:	7812      	ldrb	r2, [r2, #0]
 8000dce:	430a      	orrs	r2, r1
 8000dd0:	701a      	strb	r2, [r3, #0]
		if(portSample != 0x00)//if its different send
 8000dd2:	466b      	mov	r3, sp
 8000dd4:	3315      	adds	r3, #21
 8000dd6:	781b      	ldrb	r3, [r3, #0]
 8000dd8:	2b00      	cmp	r3, #0
 8000dda:	d0be      	beq.n	8000d5a <main+0x4a>
		{
			prepareForSend(packet, portSample);
 8000ddc:	aa03      	add	r2, sp, #12
 8000dde:	466b      	mov	r3, sp
 8000de0:	3315      	adds	r3, #21
 8000de2:	781b      	ldrb	r3, [r3, #0]
 8000de4:	1c10      	adds	r0, r2, #0
 8000de6:	1c19      	adds	r1, r3, #0
 8000de8:	f7ff ff5a 	bl	8000ca0 <prepareForSend.7009.4016>
			sdWrite(&SD1, (uint8_t *)packet, 7);
 8000dec:	490c      	ldr	r1, [pc, #48]	; (8000e20 <main+0x110>)
 8000dee:	aa03      	add	r2, sp, #12
 8000df0:	4b0c      	ldr	r3, [pc, #48]	; (8000e24 <main+0x114>)
 8000df2:	1c08      	adds	r0, r1, #0
 8000df4:	1c11      	adds	r1, r2, #0
 8000df6:	2207      	movs	r2, #7
 8000df8:	f000 fbd2 	bl	80015a0 <oqWriteTimeout>
			//chThdSleepMilliseconds(100);
			for(i = 0; i < 100000; i++)
 8000dfc:	2300      	movs	r3, #0
 8000dfe:	9302      	str	r3, [sp, #8]
 8000e00:	e005      	b.n	8000e0e <main+0xfe>
				j++;
 8000e02:	9b01      	ldr	r3, [sp, #4]
 8000e04:	3301      	adds	r3, #1
 8000e06:	9301      	str	r3, [sp, #4]
		if(portSample != 0x00)//if its different send
		{
			prepareForSend(packet, portSample);
			sdWrite(&SD1, (uint8_t *)packet, 7);
			//chThdSleepMilliseconds(100);
			for(i = 0; i < 100000; i++)
 8000e08:	9b02      	ldr	r3, [sp, #8]
 8000e0a:	3301      	adds	r3, #1
 8000e0c:	9302      	str	r3, [sp, #8]
 8000e0e:	9a02      	ldr	r2, [sp, #8]
 8000e10:	4b05      	ldr	r3, [pc, #20]	; (8000e28 <main+0x118>)
 8000e12:	429a      	cmp	r2, r3
 8000e14:	ddf5      	ble.n	8000e02 <main+0xf2>
 8000e16:	e7a0      	b.n	8000d5a <main+0x4a>
 8000e18:	000006f3 	.word	0x000006f3
 8000e1c:	20000450 	.word	0x20000450
 8000e20:	20000480 	.word	0x20000480
 8000e24:	0000ffff 	.word	0x0000ffff
 8000e28:	0001869f 	.word	0x0001869f
 8000e2c:	46c0      	nop			; (mov r8, r8)
 8000e2e:	46c0      	nop			; (mov r8, r8)

08000e30 <port_lock.5714.4441>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e30:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000e32:	4770      	bx	lr
 8000e34:	46c0      	nop			; (mov r8, r8)
 8000e36:	46c0      	nop			; (mov r8, r8)
 8000e38:	46c0      	nop			; (mov r8, r8)
 8000e3a:	46c0      	nop			; (mov r8, r8)
 8000e3c:	46c0      	nop			; (mov r8, r8)
 8000e3e:	46c0      	nop			; (mov r8, r8)

08000e40 <port_unlock.5717.4439>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e40:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000e42:	4770      	bx	lr
 8000e44:	46c0      	nop			; (mov r8, r8)
 8000e46:	46c0      	nop			; (mov r8, r8)
 8000e48:	46c0      	nop			; (mov r8, r8)
 8000e4a:	46c0      	nop			; (mov r8, r8)
 8000e4c:	46c0      	nop			; (mov r8, r8)
 8000e4e:	46c0      	nop			; (mov r8, r8)

08000e50 <chSysLock.5719.4437>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8000e50:	b508      	push	{r3, lr}

  port_lock();
 8000e52:	f7ff ffed 	bl	8000e30 <port_lock.5714.4441>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8000e56:	bd08      	pop	{r3, pc}
 8000e58:	46c0      	nop			; (mov r8, r8)
 8000e5a:	46c0      	nop			; (mov r8, r8)
 8000e5c:	46c0      	nop			; (mov r8, r8)
 8000e5e:	46c0      	nop			; (mov r8, r8)

08000e60 <chSysUnlock.5721.4435>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000e60:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8000e62:	f7ff ffed 	bl	8000e40 <port_unlock.5717.4439>
}
 8000e66:	bd08      	pop	{r3, pc}
 8000e68:	46c0      	nop			; (mov r8, r8)
 8000e6a:	46c0      	nop			; (mov r8, r8)
 8000e6c:	46c0      	nop			; (mov r8, r8)
 8000e6e:	46c0      	nop			; (mov r8, r8)

08000e70 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000e70:	4b06      	ldr	r3, [pc, #24]	; (8000e8c <_core_init+0x1c>)
 8000e72:	3307      	adds	r3, #7
 8000e74:	2207      	movs	r2, #7
 8000e76:	4393      	bics	r3, r2
 8000e78:	1c1a      	adds	r2, r3, #0
 8000e7a:	4b05      	ldr	r3, [pc, #20]	; (8000e90 <_core_init+0x20>)
 8000e7c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000e7e:	4b05      	ldr	r3, [pc, #20]	; (8000e94 <_core_init+0x24>)
 8000e80:	2207      	movs	r2, #7
 8000e82:	4393      	bics	r3, r2
 8000e84:	1c1a      	adds	r2, r3, #0
 8000e86:	4b04      	ldr	r3, [pc, #16]	; (8000e98 <_core_init+0x28>)
 8000e88:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 8000e8a:	4770      	bx	lr
 8000e8c:	200006d0 	.word	0x200006d0
 8000e90:	20000428 	.word	0x20000428
 8000e94:	20001000 	.word	0x20001000
 8000e98:	2000042c 	.word	0x2000042c
 8000e9c:	46c0      	nop			; (mov r8, r8)
 8000e9e:	46c0      	nop			; (mov r8, r8)

08000ea0 <chCoreAlloc.4425>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8000ea0:	b500      	push	{lr}
 8000ea2:	b085      	sub	sp, #20
 8000ea4:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8000ea6:	f7ff ffd3 	bl	8000e50 <chSysLock.5719.4437>
  p = chCoreAllocI(size);
 8000eaa:	9b01      	ldr	r3, [sp, #4]
 8000eac:	1c18      	adds	r0, r3, #0
 8000eae:	f000 f80f 	bl	8000ed0 <chCoreAllocI.4430>
 8000eb2:	1c03      	adds	r3, r0, #0
 8000eb4:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8000eb6:	f7ff ffd3 	bl	8000e60 <chSysUnlock.5721.4435>

  return p;
 8000eba:	9b03      	ldr	r3, [sp, #12]
}
 8000ebc:	1c18      	adds	r0, r3, #0
 8000ebe:	b005      	add	sp, #20
 8000ec0:	bd00      	pop	{pc}
 8000ec2:	46c0      	nop			; (mov r8, r8)
 8000ec4:	46c0      	nop			; (mov r8, r8)
 8000ec6:	46c0      	nop			; (mov r8, r8)
 8000ec8:	46c0      	nop			; (mov r8, r8)
 8000eca:	46c0      	nop			; (mov r8, r8)
 8000ecc:	46c0      	nop			; (mov r8, r8)
 8000ece:	46c0      	nop			; (mov r8, r8)

08000ed0 <chCoreAllocI.4430>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8000ed0:	b084      	sub	sp, #16
 8000ed2:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000ed4:	9b01      	ldr	r3, [sp, #4]
 8000ed6:	3307      	adds	r3, #7
 8000ed8:	2207      	movs	r2, #7
 8000eda:	4393      	bics	r3, r2
 8000edc:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000ede:	4b0c      	ldr	r3, [pc, #48]	; (8000f10 <chCoreAllocI.4430+0x40>)
 8000ee0:	681b      	ldr	r3, [r3, #0]
 8000ee2:	1c1a      	adds	r2, r3, #0
 8000ee4:	4b0b      	ldr	r3, [pc, #44]	; (8000f14 <chCoreAllocI.4430+0x44>)
 8000ee6:	681b      	ldr	r3, [r3, #0]
 8000ee8:	1ad3      	subs	r3, r2, r3
 8000eea:	1c1a      	adds	r2, r3, #0
 8000eec:	9b01      	ldr	r3, [sp, #4]
 8000eee:	429a      	cmp	r2, r3
 8000ef0:	d201      	bcs.n	8000ef6 <chCoreAllocI.4430+0x26>
  /*lint -restore*/
    return NULL;
 8000ef2:	2300      	movs	r3, #0
 8000ef4:	e009      	b.n	8000f0a <chCoreAllocI.4430+0x3a>
  }
  p = nextmem;
 8000ef6:	4b07      	ldr	r3, [pc, #28]	; (8000f14 <chCoreAllocI.4430+0x44>)
 8000ef8:	681b      	ldr	r3, [r3, #0]
 8000efa:	9303      	str	r3, [sp, #12]
  nextmem += size;
 8000efc:	4b05      	ldr	r3, [pc, #20]	; (8000f14 <chCoreAllocI.4430+0x44>)
 8000efe:	681a      	ldr	r2, [r3, #0]
 8000f00:	9b01      	ldr	r3, [sp, #4]
 8000f02:	18d2      	adds	r2, r2, r3
 8000f04:	4b03      	ldr	r3, [pc, #12]	; (8000f14 <chCoreAllocI.4430+0x44>)
 8000f06:	601a      	str	r2, [r3, #0]

  return p;
 8000f08:	9b03      	ldr	r3, [sp, #12]
}
 8000f0a:	1c18      	adds	r0, r3, #0
 8000f0c:	b004      	add	sp, #16
 8000f0e:	4770      	bx	lr
 8000f10:	2000042c 	.word	0x2000042c
 8000f14:	20000428 	.word	0x20000428
 8000f18:	46c0      	nop			; (mov r8, r8)
 8000f1a:	46c0      	nop			; (mov r8, r8)
 8000f1c:	46c0      	nop			; (mov r8, r8)
 8000f1e:	46c0      	nop			; (mov r8, r8)

08000f20 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8000f20:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 8000f22:	4b07      	ldr	r3, [pc, #28]	; (8000f40 <_heap_init+0x20>)
 8000f24:	4a07      	ldr	r2, [pc, #28]	; (8000f44 <_heap_init+0x24>)
 8000f26:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8000f28:	4b05      	ldr	r3, [pc, #20]	; (8000f40 <_heap_init+0x20>)
 8000f2a:	2200      	movs	r2, #0
 8000f2c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8000f2e:	4b04      	ldr	r3, [pc, #16]	; (8000f40 <_heap_init+0x20>)
 8000f30:	2200      	movs	r2, #0
 8000f32:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8000f34:	4b04      	ldr	r3, [pc, #16]	; (8000f48 <_heap_init+0x28>)
 8000f36:	1c18      	adds	r0, r3, #0
 8000f38:	f001 fbd2 	bl	80026e0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 8000f3c:	bd08      	pop	{r3, pc}
 8000f3e:	46c0      	nop			; (mov r8, r8)
 8000f40:	20000430 	.word	0x20000430
 8000f44:	08000ea1 	.word	0x08000ea1
 8000f48:	20000440 	.word	0x20000440
 8000f4c:	46c0      	nop			; (mov r8, r8)
 8000f4e:	46c0      	nop			; (mov r8, r8)

08000f50 <port_lock.5920.4385>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f50:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000f52:	4770      	bx	lr
 8000f54:	46c0      	nop			; (mov r8, r8)
 8000f56:	46c0      	nop			; (mov r8, r8)
 8000f58:	46c0      	nop			; (mov r8, r8)
 8000f5a:	46c0      	nop			; (mov r8, r8)
 8000f5c:	46c0      	nop			; (mov r8, r8)
 8000f5e:	46c0      	nop			; (mov r8, r8)

08000f60 <port_unlock.5923.4383>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000f60:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000f62:	4770      	bx	lr
 8000f64:	46c0      	nop			; (mov r8, r8)
 8000f66:	46c0      	nop			; (mov r8, r8)
 8000f68:	46c0      	nop			; (mov r8, r8)
 8000f6a:	46c0      	nop			; (mov r8, r8)
 8000f6c:	46c0      	nop			; (mov r8, r8)
 8000f6e:	46c0      	nop			; (mov r8, r8)

08000f70 <port_lock_from_isr.5925.4381>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000f70:	b508      	push	{r3, lr}

  port_lock();
 8000f72:	f7ff ffed 	bl	8000f50 <port_lock.5920.4385>
}
 8000f76:	bd08      	pop	{r3, pc}
 8000f78:	46c0      	nop			; (mov r8, r8)
 8000f7a:	46c0      	nop			; (mov r8, r8)
 8000f7c:	46c0      	nop			; (mov r8, r8)
 8000f7e:	46c0      	nop			; (mov r8, r8)

08000f80 <port_unlock_from_isr.5927.4379>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000f80:	b508      	push	{r3, lr}

  port_unlock();
 8000f82:	f7ff ffed 	bl	8000f60 <port_unlock.5923.4383>
}
 8000f86:	bd08      	pop	{r3, pc}
 8000f88:	46c0      	nop			; (mov r8, r8)
 8000f8a:	46c0      	nop			; (mov r8, r8)
 8000f8c:	46c0      	nop			; (mov r8, r8)
 8000f8e:	46c0      	nop			; (mov r8, r8)

08000f90 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8000f90:	b510      	push	{r4, lr}
 8000f92:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000f94:	f3ef 8309 	mrs	r3, PSP
 8000f98:	1c1c      	adds	r4, r3, #0
  return(result);
 8000f9a:	1c23      	adds	r3, r4, #0
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 8000f9c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000f9e:	9b01      	ldr	r3, [sp, #4]
 8000fa0:	3320      	adds	r3, #32
 8000fa2:	9301      	str	r3, [sp, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8000fa4:	9b01      	ldr	r3, [sp, #4]
 8000fa6:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000fa8:	9b00      	ldr	r3, [sp, #0]
 8000faa:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8000fae:	f7ff ffe7 	bl	8000f80 <port_unlock_from_isr.5927.4379>
}
 8000fb2:	b002      	add	sp, #8
 8000fb4:	bd10      	pop	{r4, pc}
 8000fb6:	46c0      	nop			; (mov r8, r8)
 8000fb8:	46c0      	nop			; (mov r8, r8)
 8000fba:	46c0      	nop			; (mov r8, r8)
 8000fbc:	46c0      	nop			; (mov r8, r8)
 8000fbe:	46c0      	nop			; (mov r8, r8)

08000fc0 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 8000fc0:	b510      	push	{r4, lr}
 8000fc2:	b084      	sub	sp, #16
 8000fc4:	9001      	str	r0, [sp, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000fc6:	9b01      	ldr	r3, [sp, #4]
 8000fc8:	1c1a      	adds	r2, r3, #0
 8000fca:	320f      	adds	r2, #15
 8000fcc:	d01e      	beq.n	800100c <_port_irq_epilogue+0x4c>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 8000fce:	f7ff ffcf 	bl	8000f70 <port_lock_from_isr.5925.4381>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000fd2:	f3ef 8309 	mrs	r3, PSP
 8000fd6:	1c1c      	adds	r4, r3, #0
  return(result);
 8000fd8:	1c23      	adds	r3, r4, #0

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8000fda:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000fdc:	9b03      	ldr	r3, [sp, #12]
 8000fde:	3b20      	subs	r3, #32
 8000fe0:	9303      	str	r3, [sp, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8000fe2:	9b03      	ldr	r3, [sp, #12]
 8000fe4:	9302      	str	r3, [sp, #8]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000fe6:	9b02      	ldr	r3, [sp, #8]
 8000fe8:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000fec:	9b03      	ldr	r3, [sp, #12]
 8000fee:	2280      	movs	r2, #128	; 0x80
 8000ff0:	0452      	lsls	r2, r2, #17
 8000ff2:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000ff4:	f001 f9ac 	bl	8002350 <chSchIsPreemptionRequired>
 8000ff8:	1c03      	adds	r3, r0, #0
 8000ffa:	2b00      	cmp	r3, #0
 8000ffc:	d003      	beq.n	8001006 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000ffe:	9b03      	ldr	r3, [sp, #12]
 8001000:	4a03      	ldr	r2, [pc, #12]	; (8001010 <_port_irq_epilogue+0x50>)
 8001002:	619a      	str	r2, [r3, #24]
 8001004:	e002      	b.n	800100c <_port_irq_epilogue+0x4c>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001006:	9b03      	ldr	r3, [sp, #12]
 8001008:	4a02      	ldr	r2, [pc, #8]	; (8001014 <_port_irq_epilogue+0x54>)
 800100a:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 800100c:	b004      	add	sp, #16
 800100e:	bd10      	pop	{r4, pc}
 8001010:	080001bd 	.word	0x080001bd
 8001014:	080001c0 	.word	0x080001c0
 8001018:	46c0      	nop			; (mov r8, r8)
 800101a:	46c0      	nop			; (mov r8, r8)
 800101c:	46c0      	nop			; (mov r8, r8)
 800101e:	46c0      	nop			; (mov r8, r8)

08001020 <osalInit.5962.4369>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8001020:	4770      	bx	lr
 8001022:	46c0      	nop			; (mov r8, r8)
 8001024:	46c0      	nop			; (mov r8, r8)
 8001026:	46c0      	nop			; (mov r8, r8)
 8001028:	46c0      	nop			; (mov r8, r8)
 800102a:	46c0      	nop			; (mov r8, r8)
 800102c:	46c0      	nop			; (mov r8, r8)
 800102e:	46c0      	nop			; (mov r8, r8)

08001030 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001030:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8001032:	f7ff fff5 	bl	8001020 <osalInit.5962.4369>

  /* Platform low level initializations.*/
  hal_lld_init();
 8001036:	f7ff f9c3 	bl	80003c0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 800103a:	4b05      	ldr	r3, [pc, #20]	; (8001050 <halInit+0x20>)
 800103c:	1c18      	adds	r0, r3, #0
 800103e:	f7ff fb27 	bl	8000690 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8001042:	f000 fc1d 	bl	8001880 <sdInit.4161>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8001046:	f7ff fda3 	bl	8000b90 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 800104a:	f000 f839 	bl	80010c0 <stInit.4354>
#endif
}
 800104e:	bd08      	pop	{r3, pc}
 8001050:	08002760 	.word	0x08002760
 8001054:	46c0      	nop			; (mov r8, r8)
 8001056:	46c0      	nop			; (mov r8, r8)
 8001058:	46c0      	nop			; (mov r8, r8)
 800105a:	46c0      	nop			; (mov r8, r8)
 800105c:	46c0      	nop			; (mov r8, r8)
 800105e:	46c0      	nop			; (mov r8, r8)

08001060 <st_lld_start_alarm.5990.4363>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8001060:	b082      	sub	sp, #8
 8001062:	1c02      	adds	r2, r0, #0
 8001064:	466b      	mov	r3, sp
 8001066:	3306      	adds	r3, #6
 8001068:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800106a:	4b06      	ldr	r3, [pc, #24]	; (8001084 <st_lld_start_alarm.5990.4363+0x24>)
 800106c:	466a      	mov	r2, sp
 800106e:	3206      	adds	r2, #6
 8001070:	8812      	ldrh	r2, [r2, #0]
 8001072:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001074:	4b03      	ldr	r3, [pc, #12]	; (8001084 <st_lld_start_alarm.5990.4363+0x24>)
 8001076:	2200      	movs	r2, #0
 8001078:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800107a:	4b02      	ldr	r3, [pc, #8]	; (8001084 <st_lld_start_alarm.5990.4363+0x24>)
 800107c:	2202      	movs	r2, #2
 800107e:	60da      	str	r2, [r3, #12]
}
 8001080:	b002      	add	sp, #8
 8001082:	4770      	bx	lr
 8001084:	40000400 	.word	0x40000400
 8001088:	46c0      	nop			; (mov r8, r8)
 800108a:	46c0      	nop			; (mov r8, r8)
 800108c:	46c0      	nop			; (mov r8, r8)
 800108e:	46c0      	nop			; (mov r8, r8)

08001090 <st_lld_stop_alarm.5997.4361>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001090:	4b01      	ldr	r3, [pc, #4]	; (8001098 <st_lld_stop_alarm.5997.4361+0x8>)
 8001092:	2200      	movs	r2, #0
 8001094:	60da      	str	r2, [r3, #12]
}
 8001096:	4770      	bx	lr
 8001098:	40000400 	.word	0x40000400
 800109c:	46c0      	nop			; (mov r8, r8)
 800109e:	46c0      	nop			; (mov r8, r8)

080010a0 <st_lld_set_alarm.5999.4358>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 80010a0:	b082      	sub	sp, #8
 80010a2:	1c02      	adds	r2, r0, #0
 80010a4:	466b      	mov	r3, sp
 80010a6:	3306      	adds	r3, #6
 80010a8:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80010aa:	4b03      	ldr	r3, [pc, #12]	; (80010b8 <st_lld_set_alarm.5999.4358+0x18>)
 80010ac:	466a      	mov	r2, sp
 80010ae:	3206      	adds	r2, #6
 80010b0:	8812      	ldrh	r2, [r2, #0]
 80010b2:	635a      	str	r2, [r3, #52]	; 0x34
}
 80010b4:	b002      	add	sp, #8
 80010b6:	4770      	bx	lr
 80010b8:	40000400 	.word	0x40000400
 80010bc:	46c0      	nop			; (mov r8, r8)
 80010be:	46c0      	nop			; (mov r8, r8)

080010c0 <stInit.4354>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 80010c0:	b508      	push	{r3, lr}

  st_lld_init();
 80010c2:	f7ff fa85 	bl	80005d0 <st_lld_init>
}
 80010c6:	bd08      	pop	{r3, pc}
 80010c8:	46c0      	nop			; (mov r8, r8)
 80010ca:	46c0      	nop			; (mov r8, r8)
 80010cc:	46c0      	nop			; (mov r8, r8)
 80010ce:	46c0      	nop			; (mov r8, r8)

080010d0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 80010d0:	b500      	push	{lr}
 80010d2:	b083      	sub	sp, #12
 80010d4:	1c02      	adds	r2, r0, #0
 80010d6:	466b      	mov	r3, sp
 80010d8:	3306      	adds	r3, #6
 80010da:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 80010dc:	466b      	mov	r3, sp
 80010de:	3306      	adds	r3, #6
 80010e0:	881b      	ldrh	r3, [r3, #0]
 80010e2:	1c18      	adds	r0, r3, #0
 80010e4:	f7ff ffbc 	bl	8001060 <st_lld_start_alarm.5990.4363>
}
 80010e8:	b003      	add	sp, #12
 80010ea:	bd00      	pop	{pc}
 80010ec:	46c0      	nop			; (mov r8, r8)
 80010ee:	46c0      	nop			; (mov r8, r8)

080010f0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 80010f0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 80010f2:	f7ff ffcd 	bl	8001090 <st_lld_stop_alarm.5997.4361>
}
 80010f6:	bd08      	pop	{r3, pc}
 80010f8:	46c0      	nop			; (mov r8, r8)
 80010fa:	46c0      	nop			; (mov r8, r8)
 80010fc:	46c0      	nop			; (mov r8, r8)
 80010fe:	46c0      	nop			; (mov r8, r8)

08001100 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8001100:	b500      	push	{lr}
 8001102:	b083      	sub	sp, #12
 8001104:	1c02      	adds	r2, r0, #0
 8001106:	466b      	mov	r3, sp
 8001108:	3306      	adds	r3, #6
 800110a:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 800110c:	466b      	mov	r3, sp
 800110e:	3306      	adds	r3, #6
 8001110:	881b      	ldrh	r3, [r3, #0]
 8001112:	1c18      	adds	r0, r3, #0
 8001114:	f7ff ffc4 	bl	80010a0 <st_lld_set_alarm.5999.4358>
}
 8001118:	b003      	add	sp, #12
 800111a:	bd00      	pop	{pc}
 800111c:	46c0      	nop			; (mov r8, r8)
 800111e:	46c0      	nop			; (mov r8, r8)

08001120 <port_lock.6048.4341>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001120:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001122:	4770      	bx	lr
 8001124:	46c0      	nop			; (mov r8, r8)
 8001126:	46c0      	nop			; (mov r8, r8)
 8001128:	46c0      	nop			; (mov r8, r8)
 800112a:	46c0      	nop			; (mov r8, r8)
 800112c:	46c0      	nop			; (mov r8, r8)
 800112e:	46c0      	nop			; (mov r8, r8)

08001130 <port_unlock.6051.4339>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001130:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001132:	4770      	bx	lr
 8001134:	46c0      	nop			; (mov r8, r8)
 8001136:	46c0      	nop			; (mov r8, r8)
 8001138:	46c0      	nop			; (mov r8, r8)
 800113a:	46c0      	nop			; (mov r8, r8)
 800113c:	46c0      	nop			; (mov r8, r8)
 800113e:	46c0      	nop			; (mov r8, r8)

08001140 <queue_init.6053.4336>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001140:	b082      	sub	sp, #8
 8001142:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001144:	9b01      	ldr	r3, [sp, #4]
 8001146:	9a01      	ldr	r2, [sp, #4]
 8001148:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800114a:	9b01      	ldr	r3, [sp, #4]
 800114c:	9a01      	ldr	r2, [sp, #4]
 800114e:	605a      	str	r2, [r3, #4]
}
 8001150:	b002      	add	sp, #8
 8001152:	4770      	bx	lr
 8001154:	46c0      	nop			; (mov r8, r8)
 8001156:	46c0      	nop			; (mov r8, r8)
 8001158:	46c0      	nop			; (mov r8, r8)
 800115a:	46c0      	nop			; (mov r8, r8)
 800115c:	46c0      	nop			; (mov r8, r8)
 800115e:	46c0      	nop			; (mov r8, r8)

08001160 <chSysLock.6119.4334>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8001160:	b508      	push	{r3, lr}

  port_lock();
 8001162:	f7ff ffdd 	bl	8001120 <port_lock.6048.4341>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001166:	bd08      	pop	{r3, pc}
 8001168:	46c0      	nop			; (mov r8, r8)
 800116a:	46c0      	nop			; (mov r8, r8)
 800116c:	46c0      	nop			; (mov r8, r8)
 800116e:	46c0      	nop			; (mov r8, r8)

08001170 <chSysUnlock.6121.4332>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001170:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001172:	f7ff ffdd 	bl	8001130 <port_unlock.6051.4339>
}
 8001176:	bd08      	pop	{r3, pc}
 8001178:	46c0      	nop			; (mov r8, r8)
 800117a:	46c0      	nop			; (mov r8, r8)
 800117c:	46c0      	nop			; (mov r8, r8)
 800117e:	46c0      	nop			; (mov r8, r8)

08001180 <chThdQueueObjectInit.6123.4329>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8001180:	b500      	push	{lr}
 8001182:	b083      	sub	sp, #12
 8001184:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8001186:	9b01      	ldr	r3, [sp, #4]
 8001188:	1c18      	adds	r0, r3, #0
 800118a:	f7ff ffd9 	bl	8001140 <queue_init.6053.4336>
}
 800118e:	b003      	add	sp, #12
 8001190:	bd00      	pop	{pc}
 8001192:	46c0      	nop			; (mov r8, r8)
 8001194:	46c0      	nop			; (mov r8, r8)
 8001196:	46c0      	nop			; (mov r8, r8)
 8001198:	46c0      	nop			; (mov r8, r8)
 800119a:	46c0      	nop			; (mov r8, r8)
 800119c:	46c0      	nop			; (mov r8, r8)
 800119e:	46c0      	nop			; (mov r8, r8)

080011a0 <osalSysLock.6126.4327>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80011a0:	b508      	push	{r3, lr}

  chSysLock();
 80011a2:	f7ff ffdd 	bl	8001160 <chSysLock.6119.4334>
}
 80011a6:	bd08      	pop	{r3, pc}
 80011a8:	46c0      	nop			; (mov r8, r8)
 80011aa:	46c0      	nop			; (mov r8, r8)
 80011ac:	46c0      	nop			; (mov r8, r8)
 80011ae:	46c0      	nop			; (mov r8, r8)

080011b0 <osalSysUnlock.6128.4325>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80011b0:	b508      	push	{r3, lr}

  chSysUnlock();
 80011b2:	f7ff ffdd 	bl	8001170 <chSysUnlock.6121.4332>
}
 80011b6:	bd08      	pop	{r3, pc}
 80011b8:	46c0      	nop			; (mov r8, r8)
 80011ba:	46c0      	nop			; (mov r8, r8)
 80011bc:	46c0      	nop			; (mov r8, r8)
 80011be:	46c0      	nop			; (mov r8, r8)

080011c0 <osalThreadQueueObjectInit.6130.4322>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 80011c0:	b500      	push	{lr}
 80011c2:	b083      	sub	sp, #12
 80011c4:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 80011c6:	9b01      	ldr	r3, [sp, #4]
 80011c8:	1c18      	adds	r0, r3, #0
 80011ca:	f7ff ffd9 	bl	8001180 <chThdQueueObjectInit.6123.4329>
}
 80011ce:	b003      	add	sp, #12
 80011d0:	bd00      	pop	{pc}
 80011d2:	46c0      	nop			; (mov r8, r8)
 80011d4:	46c0      	nop			; (mov r8, r8)
 80011d6:	46c0      	nop			; (mov r8, r8)
 80011d8:	46c0      	nop			; (mov r8, r8)
 80011da:	46c0      	nop			; (mov r8, r8)
 80011dc:	46c0      	nop			; (mov r8, r8)
 80011de:	46c0      	nop			; (mov r8, r8)

080011e0 <osalThreadEnqueueTimeoutS.6141.4318>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 80011e0:	b500      	push	{lr}
 80011e2:	b083      	sub	sp, #12
 80011e4:	9001      	str	r0, [sp, #4]
 80011e6:	1c0a      	adds	r2, r1, #0
 80011e8:	466b      	mov	r3, sp
 80011ea:	3302      	adds	r3, #2
 80011ec:	801a      	strh	r2, [r3, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 80011ee:	9a01      	ldr	r2, [sp, #4]
 80011f0:	466b      	mov	r3, sp
 80011f2:	3302      	adds	r3, #2
 80011f4:	881b      	ldrh	r3, [r3, #0]
 80011f6:	1c10      	adds	r0, r2, #0
 80011f8:	1c19      	adds	r1, r3, #0
 80011fa:	f001 fa21 	bl	8002640 <chThdEnqueueTimeoutS>
 80011fe:	1c03      	adds	r3, r0, #0
}
 8001200:	1c18      	adds	r0, r3, #0
 8001202:	b003      	add	sp, #12
 8001204:	bd00      	pop	{pc}
 8001206:	46c0      	nop			; (mov r8, r8)
 8001208:	46c0      	nop			; (mov r8, r8)
 800120a:	46c0      	nop			; (mov r8, r8)
 800120c:	46c0      	nop			; (mov r8, r8)
 800120e:	46c0      	nop			; (mov r8, r8)

08001210 <osalThreadDequeueNextI.6137.4314>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001210:	b500      	push	{lr}
 8001212:	b083      	sub	sp, #12
 8001214:	9001      	str	r0, [sp, #4]
 8001216:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8001218:	9a01      	ldr	r2, [sp, #4]
 800121a:	9b00      	ldr	r3, [sp, #0]
 800121c:	1c10      	adds	r0, r2, #0
 800121e:	1c19      	adds	r1, r3, #0
 8001220:	f001 fa36 	bl	8002690 <chThdDequeueNextI>
}
 8001224:	b003      	add	sp, #12
 8001226:	bd00      	pop	{pc}
 8001228:	46c0      	nop			; (mov r8, r8)
 800122a:	46c0      	nop			; (mov r8, r8)
 800122c:	46c0      	nop			; (mov r8, r8)
 800122e:	46c0      	nop			; (mov r8, r8)

08001230 <iqObjectInit.4303>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8001230:	b500      	push	{lr}
 8001232:	b085      	sub	sp, #20
 8001234:	9003      	str	r0, [sp, #12]
 8001236:	9102      	str	r1, [sp, #8]
 8001238:	9201      	str	r2, [sp, #4]
 800123a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 800123c:	9b03      	ldr	r3, [sp, #12]
 800123e:	1c18      	adds	r0, r3, #0
 8001240:	f7ff ffbe 	bl	80011c0 <osalThreadQueueObjectInit.6130.4322>
  iqp->q_counter = 0;
 8001244:	9b03      	ldr	r3, [sp, #12]
 8001246:	2200      	movs	r2, #0
 8001248:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800124a:	9b03      	ldr	r3, [sp, #12]
 800124c:	9a02      	ldr	r2, [sp, #8]
 800124e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8001250:	9b03      	ldr	r3, [sp, #12]
 8001252:	9a02      	ldr	r2, [sp, #8]
 8001254:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8001256:	9b03      	ldr	r3, [sp, #12]
 8001258:	9a02      	ldr	r2, [sp, #8]
 800125a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800125c:	9a02      	ldr	r2, [sp, #8]
 800125e:	9b01      	ldr	r3, [sp, #4]
 8001260:	18d2      	adds	r2, r2, r3
 8001262:	9b03      	ldr	r3, [sp, #12]
 8001264:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8001266:	9b03      	ldr	r3, [sp, #12]
 8001268:	9a00      	ldr	r2, [sp, #0]
 800126a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800126c:	9b03      	ldr	r3, [sp, #12]
 800126e:	9a06      	ldr	r2, [sp, #24]
 8001270:	621a      	str	r2, [r3, #32]
}
 8001272:	b005      	add	sp, #20
 8001274:	bd00      	pop	{pc}
 8001276:	46c0      	nop			; (mov r8, r8)
 8001278:	46c0      	nop			; (mov r8, r8)
 800127a:	46c0      	nop			; (mov r8, r8)
 800127c:	46c0      	nop			; (mov r8, r8)
 800127e:	46c0      	nop			; (mov r8, r8)

08001280 <iqPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8001280:	b500      	push	{lr}
 8001282:	b083      	sub	sp, #12
 8001284:	9001      	str	r0, [sp, #4]
 8001286:	1c0a      	adds	r2, r1, #0
 8001288:	466b      	mov	r3, sp
 800128a:	3303      	adds	r3, #3
 800128c:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 800128e:	9b01      	ldr	r3, [sp, #4]
 8001290:	695a      	ldr	r2, [r3, #20]
 8001292:	9b01      	ldr	r3, [sp, #4]
 8001294:	699b      	ldr	r3, [r3, #24]
 8001296:	429a      	cmp	r2, r3
 8001298:	d105      	bne.n	80012a6 <iqPutI+0x26>
 800129a:	9b01      	ldr	r3, [sp, #4]
 800129c:	689b      	ldr	r3, [r3, #8]
 800129e:	2b00      	cmp	r3, #0
 80012a0:	d001      	beq.n	80012a6 <iqPutI+0x26>
 80012a2:	2301      	movs	r3, #1
 80012a4:	e000      	b.n	80012a8 <iqPutI+0x28>
 80012a6:	2300      	movs	r3, #0
 80012a8:	1c1a      	adds	r2, r3, #0
 80012aa:	2301      	movs	r3, #1
 80012ac:	4013      	ands	r3, r2
 80012ae:	b2db      	uxtb	r3, r3
 80012b0:	2b00      	cmp	r3, #0
 80012b2:	d002      	beq.n	80012ba <iqPutI+0x3a>
    return Q_FULL;
 80012b4:	2304      	movs	r3, #4
 80012b6:	425b      	negs	r3, r3
 80012b8:	e01d      	b.n	80012f6 <iqPutI+0x76>
  }

  iqp->q_counter++;
 80012ba:	9b01      	ldr	r3, [sp, #4]
 80012bc:	689b      	ldr	r3, [r3, #8]
 80012be:	1c5a      	adds	r2, r3, #1
 80012c0:	9b01      	ldr	r3, [sp, #4]
 80012c2:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 80012c4:	9b01      	ldr	r3, [sp, #4]
 80012c6:	695b      	ldr	r3, [r3, #20]
 80012c8:	1c59      	adds	r1, r3, #1
 80012ca:	9a01      	ldr	r2, [sp, #4]
 80012cc:	6151      	str	r1, [r2, #20]
 80012ce:	466a      	mov	r2, sp
 80012d0:	3203      	adds	r2, #3
 80012d2:	7812      	ldrb	r2, [r2, #0]
 80012d4:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80012d6:	9b01      	ldr	r3, [sp, #4]
 80012d8:	695a      	ldr	r2, [r3, #20]
 80012da:	9b01      	ldr	r3, [sp, #4]
 80012dc:	691b      	ldr	r3, [r3, #16]
 80012de:	429a      	cmp	r2, r3
 80012e0:	d303      	bcc.n	80012ea <iqPutI+0x6a>
    iqp->q_wrptr = iqp->q_buffer;
 80012e2:	9b01      	ldr	r3, [sp, #4]
 80012e4:	68da      	ldr	r2, [r3, #12]
 80012e6:	9b01      	ldr	r3, [sp, #4]
 80012e8:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, Q_OK);
 80012ea:	9b01      	ldr	r3, [sp, #4]
 80012ec:	1c18      	adds	r0, r3, #0
 80012ee:	2100      	movs	r1, #0
 80012f0:	f7ff ff8e 	bl	8001210 <osalThreadDequeueNextI.6137.4314>

  return Q_OK;
 80012f4:	2300      	movs	r3, #0
}
 80012f6:	1c18      	adds	r0, r3, #0
 80012f8:	b003      	add	sp, #12
 80012fa:	bd00      	pop	{pc}
 80012fc:	46c0      	nop			; (mov r8, r8)
 80012fe:	46c0      	nop			; (mov r8, r8)

08001300 <iqGetTimeout.4292>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001300:	b500      	push	{lr}
 8001302:	b085      	sub	sp, #20
 8001304:	9001      	str	r0, [sp, #4]
 8001306:	1c0a      	adds	r2, r1, #0
 8001308:	466b      	mov	r3, sp
 800130a:	3302      	adds	r3, #2
 800130c:	801a      	strh	r2, [r3, #0]
  uint8_t b;

  osalSysLock();
 800130e:	f7ff ff47 	bl	80011a0 <osalSysLock.6126.4327>
  if (iqp->q_notify != NULL) {
 8001312:	9b01      	ldr	r3, [sp, #4]
 8001314:	69db      	ldr	r3, [r3, #28]
 8001316:	2b00      	cmp	r3, #0
 8001318:	d016      	beq.n	8001348 <iqGetTimeout.4292+0x48>
    iqp->q_notify(iqp);
 800131a:	9b01      	ldr	r3, [sp, #4]
 800131c:	69db      	ldr	r3, [r3, #28]
 800131e:	9a01      	ldr	r2, [sp, #4]
 8001320:	1c10      	adds	r0, r2, #0
 8001322:	4798      	blx	r3
 8001324:	e010      	b.n	8001348 <iqGetTimeout.4292+0x48>
  }

  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001326:	9a01      	ldr	r2, [sp, #4]
 8001328:	466b      	mov	r3, sp
 800132a:	3302      	adds	r3, #2
 800132c:	881b      	ldrh	r3, [r3, #0]
 800132e:	1c10      	adds	r0, r2, #0
 8001330:	1c19      	adds	r1, r3, #0
 8001332:	f7ff ff55 	bl	80011e0 <osalThreadEnqueueTimeoutS.6141.4318>
 8001336:	1c03      	adds	r3, r0, #0
 8001338:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 800133a:	9b03      	ldr	r3, [sp, #12]
 800133c:	2b00      	cmp	r3, #0
 800133e:	da03      	bge.n	8001348 <iqGetTimeout.4292+0x48>
      osalSysUnlock();
 8001340:	f7ff ff36 	bl	80011b0 <osalSysUnlock.6128.4325>
      return msg;
 8001344:	9b03      	ldr	r3, [sp, #12]
 8001346:	e020      	b.n	800138a <iqGetTimeout.4292+0x8a>
  osalSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (iqIsEmptyI(iqp)) {
 8001348:	9b01      	ldr	r3, [sp, #4]
 800134a:	689b      	ldr	r3, [r3, #8]
 800134c:	2b00      	cmp	r3, #0
 800134e:	d0ea      	beq.n	8001326 <iqGetTimeout.4292+0x26>
      osalSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001350:	9b01      	ldr	r3, [sp, #4]
 8001352:	689b      	ldr	r3, [r3, #8]
 8001354:	1e5a      	subs	r2, r3, #1
 8001356:	9b01      	ldr	r3, [sp, #4]
 8001358:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800135a:	9b01      	ldr	r3, [sp, #4]
 800135c:	699b      	ldr	r3, [r3, #24]
 800135e:	1c59      	adds	r1, r3, #1
 8001360:	9a01      	ldr	r2, [sp, #4]
 8001362:	6191      	str	r1, [r2, #24]
 8001364:	466a      	mov	r2, sp
 8001366:	320b      	adds	r2, #11
 8001368:	781b      	ldrb	r3, [r3, #0]
 800136a:	7013      	strb	r3, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 800136c:	9b01      	ldr	r3, [sp, #4]
 800136e:	699a      	ldr	r2, [r3, #24]
 8001370:	9b01      	ldr	r3, [sp, #4]
 8001372:	691b      	ldr	r3, [r3, #16]
 8001374:	429a      	cmp	r2, r3
 8001376:	d303      	bcc.n	8001380 <iqGetTimeout.4292+0x80>
    iqp->q_rdptr = iqp->q_buffer;
 8001378:	9b01      	ldr	r3, [sp, #4]
 800137a:	68da      	ldr	r2, [r3, #12]
 800137c:	9b01      	ldr	r3, [sp, #4]
 800137e:	619a      	str	r2, [r3, #24]
  }
  osalSysUnlock();
 8001380:	f7ff ff16 	bl	80011b0 <osalSysUnlock.6128.4325>

  return (msg_t)b;
 8001384:	466b      	mov	r3, sp
 8001386:	330b      	adds	r3, #11
 8001388:	781b      	ldrb	r3, [r3, #0]
}
 800138a:	1c18      	adds	r0, r3, #0
 800138c:	b005      	add	sp, #20
 800138e:	bd00      	pop	{pc}

08001390 <iqReadTimeout.4286>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8001390:	b500      	push	{lr}
 8001392:	b087      	sub	sp, #28
 8001394:	9003      	str	r0, [sp, #12]
 8001396:	9102      	str	r1, [sp, #8]
 8001398:	9201      	str	r2, [sp, #4]
 800139a:	1c1a      	adds	r2, r3, #0
 800139c:	466b      	mov	r3, sp
 800139e:	3302      	adds	r3, #2
 80013a0:	801a      	strh	r2, [r3, #0]
  qnotify_t nfy = iqp->q_notify;
 80013a2:	9b03      	ldr	r3, [sp, #12]
 80013a4:	69db      	ldr	r3, [r3, #28]
 80013a6:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 80013a8:	2300      	movs	r3, #0
 80013aa:	9305      	str	r3, [sp, #20]

  osalDbgCheck(n > 0U);

  osalSysLock();
 80013ac:	f7ff fef8 	bl	80011a0 <osalSysLock.6126.4327>
  while (true) {
    if (nfy != NULL) {
 80013b0:	9b04      	ldr	r3, [sp, #16]
 80013b2:	2b00      	cmp	r3, #0
 80013b4:	d013      	beq.n	80013de <iqReadTimeout.4286+0x4e>
      nfy(iqp);
 80013b6:	9a03      	ldr	r2, [sp, #12]
 80013b8:	9b04      	ldr	r3, [sp, #16]
 80013ba:	1c10      	adds	r0, r2, #0
 80013bc:	4798      	blx	r3
 80013be:	e00e      	b.n	80013de <iqReadTimeout.4286+0x4e>
    }

    while (iqIsEmptyI(iqp)) {
      if (osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 80013c0:	9a03      	ldr	r2, [sp, #12]
 80013c2:	466b      	mov	r3, sp
 80013c4:	3302      	adds	r3, #2
 80013c6:	881b      	ldrh	r3, [r3, #0]
 80013c8:	1c10      	adds	r0, r2, #0
 80013ca:	1c19      	adds	r1, r3, #0
 80013cc:	f7ff ff08 	bl	80011e0 <osalThreadEnqueueTimeoutS.6141.4318>
 80013d0:	1c03      	adds	r3, r0, #0
 80013d2:	2b00      	cmp	r3, #0
 80013d4:	d003      	beq.n	80013de <iqReadTimeout.4286+0x4e>
        osalSysUnlock();
 80013d6:	f7ff feeb 	bl	80011b0 <osalSysUnlock.6128.4325>
        return r;
 80013da:	9b05      	ldr	r3, [sp, #20]
 80013dc:	e02c      	b.n	8001438 <iqReadTimeout.4286+0xa8>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (iqIsEmptyI(iqp)) {
 80013de:	9b03      	ldr	r3, [sp, #12]
 80013e0:	689b      	ldr	r3, [r3, #8]
 80013e2:	2b00      	cmp	r3, #0
 80013e4:	d0ec      	beq.n	80013c0 <iqReadTimeout.4286+0x30>
        osalSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80013e6:	9b03      	ldr	r3, [sp, #12]
 80013e8:	689b      	ldr	r3, [r3, #8]
 80013ea:	1e5a      	subs	r2, r3, #1
 80013ec:	9b03      	ldr	r3, [sp, #12]
 80013ee:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 80013f0:	9b02      	ldr	r3, [sp, #8]
 80013f2:	1c5a      	adds	r2, r3, #1
 80013f4:	9202      	str	r2, [sp, #8]
 80013f6:	9a03      	ldr	r2, [sp, #12]
 80013f8:	6992      	ldr	r2, [r2, #24]
 80013fa:	1c50      	adds	r0, r2, #1
 80013fc:	9903      	ldr	r1, [sp, #12]
 80013fe:	6188      	str	r0, [r1, #24]
 8001400:	7812      	ldrb	r2, [r2, #0]
 8001402:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8001404:	9b03      	ldr	r3, [sp, #12]
 8001406:	699a      	ldr	r2, [r3, #24]
 8001408:	9b03      	ldr	r3, [sp, #12]
 800140a:	691b      	ldr	r3, [r3, #16]
 800140c:	429a      	cmp	r2, r3
 800140e:	d303      	bcc.n	8001418 <iqReadTimeout.4286+0x88>
      iqp->q_rdptr = iqp->q_buffer;
 8001410:	9b03      	ldr	r3, [sp, #12]
 8001412:	68da      	ldr	r2, [r3, #12]
 8001414:	9b03      	ldr	r3, [sp, #12]
 8001416:	619a      	str	r2, [r3, #24]
    }
    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8001418:	f7ff feca 	bl	80011b0 <osalSysUnlock.6128.4325>

    r++;
 800141c:	9b05      	ldr	r3, [sp, #20]
 800141e:	3301      	adds	r3, #1
 8001420:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8001422:	9b01      	ldr	r3, [sp, #4]
 8001424:	3b01      	subs	r3, #1
 8001426:	9301      	str	r3, [sp, #4]
 8001428:	9b01      	ldr	r3, [sp, #4]
 800142a:	2b00      	cmp	r3, #0
 800142c:	d101      	bne.n	8001432 <iqReadTimeout.4286+0xa2>
      return r;
 800142e:	9b05      	ldr	r3, [sp, #20]
 8001430:	e002      	b.n	8001438 <iqReadTimeout.4286+0xa8>
    }

    osalSysLock();
 8001432:	f7ff feb5 	bl	80011a0 <osalSysLock.6126.4327>
 8001436:	e7bb      	b.n	80013b0 <iqReadTimeout.4286+0x20>
  }
}
 8001438:	1c18      	adds	r0, r3, #0
 800143a:	b007      	add	sp, #28
 800143c:	bd00      	pop	{pc}
 800143e:	46c0      	nop			; (mov r8, r8)

08001440 <oqObjectInit.4279>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8001440:	b500      	push	{lr}
 8001442:	b085      	sub	sp, #20
 8001444:	9003      	str	r0, [sp, #12]
 8001446:	9102      	str	r1, [sp, #8]
 8001448:	9201      	str	r2, [sp, #4]
 800144a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 800144c:	9b03      	ldr	r3, [sp, #12]
 800144e:	1c18      	adds	r0, r3, #0
 8001450:	f7ff feb6 	bl	80011c0 <osalThreadQueueObjectInit.6130.4322>
  oqp->q_counter = size;
 8001454:	9b03      	ldr	r3, [sp, #12]
 8001456:	9a01      	ldr	r2, [sp, #4]
 8001458:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800145a:	9b03      	ldr	r3, [sp, #12]
 800145c:	9a02      	ldr	r2, [sp, #8]
 800145e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8001460:	9b03      	ldr	r3, [sp, #12]
 8001462:	9a02      	ldr	r2, [sp, #8]
 8001464:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8001466:	9b03      	ldr	r3, [sp, #12]
 8001468:	9a02      	ldr	r2, [sp, #8]
 800146a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800146c:	9a02      	ldr	r2, [sp, #8]
 800146e:	9b01      	ldr	r3, [sp, #4]
 8001470:	18d2      	adds	r2, r2, r3
 8001472:	9b03      	ldr	r3, [sp, #12]
 8001474:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8001476:	9b03      	ldr	r3, [sp, #12]
 8001478:	9a00      	ldr	r2, [sp, #0]
 800147a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800147c:	9b03      	ldr	r3, [sp, #12]
 800147e:	9a06      	ldr	r2, [sp, #24]
 8001480:	621a      	str	r2, [r3, #32]
}
 8001482:	b005      	add	sp, #20
 8001484:	bd00      	pop	{pc}
 8001486:	46c0      	nop			; (mov r8, r8)
 8001488:	46c0      	nop			; (mov r8, r8)
 800148a:	46c0      	nop			; (mov r8, r8)
 800148c:	46c0      	nop			; (mov r8, r8)
 800148e:	46c0      	nop			; (mov r8, r8)

08001490 <oqPutTimeout.4271>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001490:	b500      	push	{lr}
 8001492:	b085      	sub	sp, #20
 8001494:	9001      	str	r0, [sp, #4]
 8001496:	466b      	mov	r3, sp
 8001498:	3303      	adds	r3, #3
 800149a:	7019      	strb	r1, [r3, #0]
 800149c:	466b      	mov	r3, sp
 800149e:	801a      	strh	r2, [r3, #0]

  osalSysLock();
 80014a0:	f7ff fe7e 	bl	80011a0 <osalSysLock.6126.4327>
 80014a4:	e00f      	b.n	80014c6 <oqPutTimeout.4271+0x36>
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80014a6:	9a01      	ldr	r2, [sp, #4]
 80014a8:	466b      	mov	r3, sp
 80014aa:	881b      	ldrh	r3, [r3, #0]
 80014ac:	1c10      	adds	r0, r2, #0
 80014ae:	1c19      	adds	r1, r3, #0
 80014b0:	f7ff fe96 	bl	80011e0 <osalThreadEnqueueTimeoutS.6141.4318>
 80014b4:	1c03      	adds	r3, r0, #0
 80014b6:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 80014b8:	9b03      	ldr	r3, [sp, #12]
 80014ba:	2b00      	cmp	r3, #0
 80014bc:	da03      	bge.n	80014c6 <oqPutTimeout.4271+0x36>
      osalSysUnlock();
 80014be:	f7ff fe77 	bl	80011b0 <osalSysUnlock.6128.4325>
      return msg;
 80014c2:	9b03      	ldr	r3, [sp, #12]
 80014c4:	e027      	b.n	8001516 <oqPutTimeout.4271+0x86>
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();
  while (oqIsFullI(oqp)) {
 80014c6:	9b01      	ldr	r3, [sp, #4]
 80014c8:	689b      	ldr	r3, [r3, #8]
 80014ca:	2b00      	cmp	r3, #0
 80014cc:	d0eb      	beq.n	80014a6 <oqPutTimeout.4271+0x16>
      osalSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80014ce:	9b01      	ldr	r3, [sp, #4]
 80014d0:	689b      	ldr	r3, [r3, #8]
 80014d2:	1e5a      	subs	r2, r3, #1
 80014d4:	9b01      	ldr	r3, [sp, #4]
 80014d6:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 80014d8:	9b01      	ldr	r3, [sp, #4]
 80014da:	695b      	ldr	r3, [r3, #20]
 80014dc:	1c59      	adds	r1, r3, #1
 80014de:	9a01      	ldr	r2, [sp, #4]
 80014e0:	6151      	str	r1, [r2, #20]
 80014e2:	466a      	mov	r2, sp
 80014e4:	3203      	adds	r2, #3
 80014e6:	7812      	ldrb	r2, [r2, #0]
 80014e8:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80014ea:	9b01      	ldr	r3, [sp, #4]
 80014ec:	695a      	ldr	r2, [r3, #20]
 80014ee:	9b01      	ldr	r3, [sp, #4]
 80014f0:	691b      	ldr	r3, [r3, #16]
 80014f2:	429a      	cmp	r2, r3
 80014f4:	d303      	bcc.n	80014fe <oqPutTimeout.4271+0x6e>
    oqp->q_wrptr = oqp->q_buffer;
 80014f6:	9b01      	ldr	r3, [sp, #4]
 80014f8:	68da      	ldr	r2, [r3, #12]
 80014fa:	9b01      	ldr	r3, [sp, #4]
 80014fc:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80014fe:	9b01      	ldr	r3, [sp, #4]
 8001500:	69db      	ldr	r3, [r3, #28]
 8001502:	2b00      	cmp	r3, #0
 8001504:	d004      	beq.n	8001510 <oqPutTimeout.4271+0x80>
    oqp->q_notify(oqp);
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	69db      	ldr	r3, [r3, #28]
 800150a:	9a01      	ldr	r2, [sp, #4]
 800150c:	1c10      	adds	r0, r2, #0
 800150e:	4798      	blx	r3
  }
  osalSysUnlock();
 8001510:	f7ff fe4e 	bl	80011b0 <osalSysUnlock.6128.4325>

  return Q_OK;
 8001514:	2300      	movs	r3, #0
}
 8001516:	1c18      	adds	r0, r3, #0
 8001518:	b005      	add	sp, #20
 800151a:	bd00      	pop	{pc}
 800151c:	46c0      	nop			; (mov r8, r8)
 800151e:	46c0      	nop			; (mov r8, r8)

08001520 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8001520:	b500      	push	{lr}
 8001522:	b085      	sub	sp, #20
 8001524:	9001      	str	r0, [sp, #4]
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8001526:	9b01      	ldr	r3, [sp, #4]
 8001528:	695a      	ldr	r2, [r3, #20]
 800152a:	9b01      	ldr	r3, [sp, #4]
 800152c:	699b      	ldr	r3, [r3, #24]
 800152e:	429a      	cmp	r2, r3
 8001530:	d105      	bne.n	800153e <oqGetI+0x1e>
 8001532:	9b01      	ldr	r3, [sp, #4]
 8001534:	689b      	ldr	r3, [r3, #8]
 8001536:	2b00      	cmp	r3, #0
 8001538:	d001      	beq.n	800153e <oqGetI+0x1e>
 800153a:	2301      	movs	r3, #1
 800153c:	e000      	b.n	8001540 <oqGetI+0x20>
 800153e:	2300      	movs	r3, #0
 8001540:	1c1a      	adds	r2, r3, #0
 8001542:	2301      	movs	r3, #1
 8001544:	4013      	ands	r3, r2
 8001546:	b2db      	uxtb	r3, r3
 8001548:	2b00      	cmp	r3, #0
 800154a:	d002      	beq.n	8001552 <oqGetI+0x32>
    return Q_EMPTY;
 800154c:	2303      	movs	r3, #3
 800154e:	425b      	negs	r3, r3
 8001550:	e01f      	b.n	8001592 <oqGetI+0x72>
  }

  oqp->q_counter++;
 8001552:	9b01      	ldr	r3, [sp, #4]
 8001554:	689b      	ldr	r3, [r3, #8]
 8001556:	1c5a      	adds	r2, r3, #1
 8001558:	9b01      	ldr	r3, [sp, #4]
 800155a:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 800155c:	9b01      	ldr	r3, [sp, #4]
 800155e:	699b      	ldr	r3, [r3, #24]
 8001560:	1c59      	adds	r1, r3, #1
 8001562:	9a01      	ldr	r2, [sp, #4]
 8001564:	6191      	str	r1, [r2, #24]
 8001566:	466a      	mov	r2, sp
 8001568:	320f      	adds	r2, #15
 800156a:	781b      	ldrb	r3, [r3, #0]
 800156c:	7013      	strb	r3, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 800156e:	9b01      	ldr	r3, [sp, #4]
 8001570:	699a      	ldr	r2, [r3, #24]
 8001572:	9b01      	ldr	r3, [sp, #4]
 8001574:	691b      	ldr	r3, [r3, #16]
 8001576:	429a      	cmp	r2, r3
 8001578:	d303      	bcc.n	8001582 <oqGetI+0x62>
    oqp->q_rdptr = oqp->q_buffer;
 800157a:	9b01      	ldr	r3, [sp, #4]
 800157c:	68da      	ldr	r2, [r3, #12]
 800157e:	9b01      	ldr	r3, [sp, #4]
 8001580:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, Q_OK);
 8001582:	9b01      	ldr	r3, [sp, #4]
 8001584:	1c18      	adds	r0, r3, #0
 8001586:	2100      	movs	r1, #0
 8001588:	f7ff fe42 	bl	8001210 <osalThreadDequeueNextI.6137.4314>

  return (msg_t)b;
 800158c:	466b      	mov	r3, sp
 800158e:	330f      	adds	r3, #15
 8001590:	781b      	ldrb	r3, [r3, #0]
}
 8001592:	1c18      	adds	r0, r3, #0
 8001594:	b005      	add	sp, #20
 8001596:	bd00      	pop	{pc}
 8001598:	46c0      	nop			; (mov r8, r8)
 800159a:	46c0      	nop			; (mov r8, r8)
 800159c:	46c0      	nop			; (mov r8, r8)
 800159e:	46c0      	nop			; (mov r8, r8)

080015a0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 80015a0:	b500      	push	{lr}
 80015a2:	b087      	sub	sp, #28
 80015a4:	9003      	str	r0, [sp, #12]
 80015a6:	9102      	str	r1, [sp, #8]
 80015a8:	9201      	str	r2, [sp, #4]
 80015aa:	1c1a      	adds	r2, r3, #0
 80015ac:	466b      	mov	r3, sp
 80015ae:	3302      	adds	r3, #2
 80015b0:	801a      	strh	r2, [r3, #0]
  qnotify_t nfy = oqp->q_notify;
 80015b2:	9b03      	ldr	r3, [sp, #12]
 80015b4:	69db      	ldr	r3, [r3, #28]
 80015b6:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 80015b8:	2300      	movs	r3, #0
 80015ba:	9305      	str	r3, [sp, #20]

  osalDbgCheck(n > 0U);

  osalSysLock();
 80015bc:	f7ff fdf0 	bl	80011a0 <osalSysLock.6126.4327>
 80015c0:	e00e      	b.n	80015e0 <oqWriteTimeout+0x40>
  while (true) {
    while (oqIsFullI(oqp)) {
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80015c2:	9a03      	ldr	r2, [sp, #12]
 80015c4:	466b      	mov	r3, sp
 80015c6:	3302      	adds	r3, #2
 80015c8:	881b      	ldrh	r3, [r3, #0]
 80015ca:	1c10      	adds	r0, r2, #0
 80015cc:	1c19      	adds	r1, r3, #0
 80015ce:	f7ff fe07 	bl	80011e0 <osalThreadEnqueueTimeoutS.6141.4318>
 80015d2:	1c03      	adds	r3, r0, #0
 80015d4:	2b00      	cmp	r3, #0
 80015d6:	d003      	beq.n	80015e0 <oqWriteTimeout+0x40>
        osalSysUnlock();
 80015d8:	f7ff fdea 	bl	80011b0 <osalSysUnlock.6128.4325>
        return w;
 80015dc:	9b05      	ldr	r3, [sp, #20]
 80015de:	e033      	b.n	8001648 <oqWriteTimeout+0xa8>

  osalDbgCheck(n > 0U);

  osalSysLock();
  while (true) {
    while (oqIsFullI(oqp)) {
 80015e0:	9b03      	ldr	r3, [sp, #12]
 80015e2:	689b      	ldr	r3, [r3, #8]
 80015e4:	2b00      	cmp	r3, #0
 80015e6:	d0ec      	beq.n	80015c2 <oqWriteTimeout+0x22>
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
        osalSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 80015e8:	9b03      	ldr	r3, [sp, #12]
 80015ea:	689b      	ldr	r3, [r3, #8]
 80015ec:	1e5a      	subs	r2, r3, #1
 80015ee:	9b03      	ldr	r3, [sp, #12]
 80015f0:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 80015f2:	9b03      	ldr	r3, [sp, #12]
 80015f4:	695b      	ldr	r3, [r3, #20]
 80015f6:	1c59      	adds	r1, r3, #1
 80015f8:	9a03      	ldr	r2, [sp, #12]
 80015fa:	6151      	str	r1, [r2, #20]
 80015fc:	9a02      	ldr	r2, [sp, #8]
 80015fe:	1c51      	adds	r1, r2, #1
 8001600:	9102      	str	r1, [sp, #8]
 8001602:	7812      	ldrb	r2, [r2, #0]
 8001604:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8001606:	9b03      	ldr	r3, [sp, #12]
 8001608:	695a      	ldr	r2, [r3, #20]
 800160a:	9b03      	ldr	r3, [sp, #12]
 800160c:	691b      	ldr	r3, [r3, #16]
 800160e:	429a      	cmp	r2, r3
 8001610:	d303      	bcc.n	800161a <oqWriteTimeout+0x7a>
      oqp->q_wrptr = oqp->q_buffer;
 8001612:	9b03      	ldr	r3, [sp, #12]
 8001614:	68da      	ldr	r2, [r3, #12]
 8001616:	9b03      	ldr	r3, [sp, #12]
 8001618:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 800161a:	9b04      	ldr	r3, [sp, #16]
 800161c:	2b00      	cmp	r3, #0
 800161e:	d003      	beq.n	8001628 <oqWriteTimeout+0x88>
      nfy(oqp);
 8001620:	9a03      	ldr	r2, [sp, #12]
 8001622:	9b04      	ldr	r3, [sp, #16]
 8001624:	1c10      	adds	r0, r2, #0
 8001626:	4798      	blx	r3
    }
    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8001628:	f7ff fdc2 	bl	80011b0 <osalSysUnlock.6128.4325>

    w++;
 800162c:	9b05      	ldr	r3, [sp, #20]
 800162e:	3301      	adds	r3, #1
 8001630:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8001632:	9b01      	ldr	r3, [sp, #4]
 8001634:	3b01      	subs	r3, #1
 8001636:	9301      	str	r3, [sp, #4]
 8001638:	9b01      	ldr	r3, [sp, #4]
 800163a:	2b00      	cmp	r3, #0
 800163c:	d101      	bne.n	8001642 <oqWriteTimeout+0xa2>
      return w;
 800163e:	9b05      	ldr	r3, [sp, #20]
 8001640:	e002      	b.n	8001648 <oqWriteTimeout+0xa8>
    }

    osalSysLock();
 8001642:	f7ff fdad 	bl	80011a0 <osalSysLock.6126.4327>
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);

  osalSysLock();
 8001646:	e7cb      	b.n	80015e0 <oqWriteTimeout+0x40>
      return w;
    }

    osalSysLock();
  }
}
 8001648:	1c18      	adds	r0, r3, #0
 800164a:	b007      	add	sp, #28
 800164c:	bd00      	pop	{pc}
 800164e:	46c0      	nop			; (mov r8, r8)

08001650 <port_lock.6278.4220>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001650:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001652:	4770      	bx	lr
 8001654:	46c0      	nop			; (mov r8, r8)
 8001656:	46c0      	nop			; (mov r8, r8)
 8001658:	46c0      	nop			; (mov r8, r8)
 800165a:	46c0      	nop			; (mov r8, r8)
 800165c:	46c0      	nop			; (mov r8, r8)
 800165e:	46c0      	nop			; (mov r8, r8)

08001660 <port_unlock.6281.4218>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001660:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001662:	4770      	bx	lr
 8001664:	46c0      	nop			; (mov r8, r8)
 8001666:	46c0      	nop			; (mov r8, r8)
 8001668:	46c0      	nop			; (mov r8, r8)
 800166a:	46c0      	nop			; (mov r8, r8)
 800166c:	46c0      	nop			; (mov r8, r8)
 800166e:	46c0      	nop			; (mov r8, r8)

08001670 <chSysLock.6283.4216>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8001670:	b508      	push	{r3, lr}

  port_lock();
 8001672:	f7ff ffed 	bl	8001650 <port_lock.6278.4220>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001676:	bd08      	pop	{r3, pc}
 8001678:	46c0      	nop			; (mov r8, r8)
 800167a:	46c0      	nop			; (mov r8, r8)
 800167c:	46c0      	nop			; (mov r8, r8)
 800167e:	46c0      	nop			; (mov r8, r8)

08001680 <chSysUnlock.6285.4214>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001680:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001682:	f7ff ffed 	bl	8001660 <port_unlock.6281.4218>
}
 8001686:	bd08      	pop	{r3, pc}
 8001688:	46c0      	nop			; (mov r8, r8)
 800168a:	46c0      	nop			; (mov r8, r8)
 800168c:	46c0      	nop			; (mov r8, r8)
 800168e:	46c0      	nop			; (mov r8, r8)

08001690 <osalSysLock.6287>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8001690:	b508      	push	{r3, lr}

  chSysLock();
 8001692:	f7ff ffed 	bl	8001670 <chSysLock.6283.4216>
}
 8001696:	bd08      	pop	{r3, pc}
 8001698:	46c0      	nop			; (mov r8, r8)
 800169a:	46c0      	nop			; (mov r8, r8)
 800169c:	46c0      	nop			; (mov r8, r8)
 800169e:	46c0      	nop			; (mov r8, r8)

080016a0 <osalSysUnlock.6289>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80016a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80016a2:	f7ff ffed 	bl	8001680 <chSysUnlock.6285.4214>
}
 80016a6:	bd08      	pop	{r3, pc}
 80016a8:	46c0      	nop			; (mov r8, r8)
 80016aa:	46c0      	nop			; (mov r8, r8)
 80016ac:	46c0      	nop			; (mov r8, r8)
 80016ae:	46c0      	nop			; (mov r8, r8)

080016b0 <osalEventObjectInit.6291.4205>:
static inline void osalEventObjectInit(event_source_t *esp) {

  chEvtObjectInit(esp);
}
#else
static inline void osalEventObjectInit(event_source_t *esp) {
 80016b0:	b082      	sub	sp, #8
 80016b2:	9001      	str	r0, [sp, #4]

  esp->flags = 0;
 80016b4:	9b01      	ldr	r3, [sp, #4]
 80016b6:	2200      	movs	r2, #0
 80016b8:	601a      	str	r2, [r3, #0]
}
 80016ba:	b002      	add	sp, #8
 80016bc:	4770      	bx	lr
 80016be:	46c0      	nop			; (mov r8, r8)

080016c0 <osalEventBroadcastFlagsI.6300>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80016c0:	b082      	sub	sp, #8
 80016c2:	9001      	str	r0, [sp, #4]
 80016c4:	9100      	str	r1, [sp, #0]

  esp->flags |= flags;
 80016c6:	9b01      	ldr	r3, [sp, #4]
 80016c8:	681a      	ldr	r2, [r3, #0]
 80016ca:	9b00      	ldr	r3, [sp, #0]
 80016cc:	431a      	orrs	r2, r3
 80016ce:	9b01      	ldr	r3, [sp, #4]
 80016d0:	601a      	str	r2, [r3, #0]
}
 80016d2:	b002      	add	sp, #8
 80016d4:	4770      	bx	lr
 80016d6:	46c0      	nop			; (mov r8, r8)
 80016d8:	46c0      	nop			; (mov r8, r8)
 80016da:	46c0      	nop			; (mov r8, r8)
 80016dc:	46c0      	nop			; (mov r8, r8)
 80016de:	46c0      	nop			; (mov r8, r8)

080016e0 <write.6304>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 80016e0:	b500      	push	{lr}
 80016e2:	b085      	sub	sp, #20
 80016e4:	9003      	str	r0, [sp, #12]
 80016e6:	9102      	str	r1, [sp, #8]
 80016e8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80016ea:	9b03      	ldr	r3, [sp, #12]
 80016ec:	1c18      	adds	r0, r3, #0
 80016ee:	3030      	adds	r0, #48	; 0x30
 80016f0:	9902      	ldr	r1, [sp, #8]
 80016f2:	9a01      	ldr	r2, [sp, #4]
 80016f4:	4b03      	ldr	r3, [pc, #12]	; (8001704 <write.6304+0x24>)
 80016f6:	f7ff ff53 	bl	80015a0 <oqWriteTimeout>
 80016fa:	1c03      	adds	r3, r0, #0
                        n, TIME_INFINITE);
}
 80016fc:	1c18      	adds	r0, r3, #0
 80016fe:	b005      	add	sp, #20
 8001700:	bd00      	pop	{pc}
 8001702:	46c0      	nop			; (mov r8, r8)
 8001704:	0000ffff 	.word	0x0000ffff
 8001708:	46c0      	nop			; (mov r8, r8)
 800170a:	46c0      	nop			; (mov r8, r8)
 800170c:	46c0      	nop			; (mov r8, r8)
 800170e:	46c0      	nop			; (mov r8, r8)

08001710 <read.6321>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8001710:	b500      	push	{lr}
 8001712:	b085      	sub	sp, #20
 8001714:	9003      	str	r0, [sp, #12]
 8001716:	9102      	str	r1, [sp, #8]
 8001718:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800171a:	9b03      	ldr	r3, [sp, #12]
 800171c:	1c18      	adds	r0, r3, #0
 800171e:	300c      	adds	r0, #12
 8001720:	9902      	ldr	r1, [sp, #8]
 8001722:	9a01      	ldr	r2, [sp, #4]
 8001724:	4b03      	ldr	r3, [pc, #12]	; (8001734 <read.6321+0x24>)
 8001726:	f7ff fe33 	bl	8001390 <iqReadTimeout.4286>
 800172a:	1c03      	adds	r3, r0, #0
                       n, TIME_INFINITE);
}
 800172c:	1c18      	adds	r0, r3, #0
 800172e:	b005      	add	sp, #20
 8001730:	bd00      	pop	{pc}
 8001732:	46c0      	nop			; (mov r8, r8)
 8001734:	0000ffff 	.word	0x0000ffff
 8001738:	46c0      	nop			; (mov r8, r8)
 800173a:	46c0      	nop			; (mov r8, r8)
 800173c:	46c0      	nop			; (mov r8, r8)
 800173e:	46c0      	nop			; (mov r8, r8)

08001740 <put.6332>:

static msg_t put(void *ip, uint8_t b) {
 8001740:	b500      	push	{lr}
 8001742:	b083      	sub	sp, #12
 8001744:	9001      	str	r0, [sp, #4]
 8001746:	1c0a      	adds	r2, r1, #0
 8001748:	466b      	mov	r3, sp
 800174a:	3303      	adds	r3, #3
 800174c:	701a      	strb	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800174e:	9b01      	ldr	r3, [sp, #4]
 8001750:	1c19      	adds	r1, r3, #0
 8001752:	3130      	adds	r1, #48	; 0x30
 8001754:	466b      	mov	r3, sp
 8001756:	3303      	adds	r3, #3
 8001758:	781a      	ldrb	r2, [r3, #0]
 800175a:	4b05      	ldr	r3, [pc, #20]	; (8001770 <put.6332+0x30>)
 800175c:	1c08      	adds	r0, r1, #0
 800175e:	1c11      	adds	r1, r2, #0
 8001760:	1c1a      	adds	r2, r3, #0
 8001762:	f7ff fe95 	bl	8001490 <oqPutTimeout.4271>
 8001766:	1c03      	adds	r3, r0, #0
}
 8001768:	1c18      	adds	r0, r3, #0
 800176a:	b003      	add	sp, #12
 800176c:	bd00      	pop	{pc}
 800176e:	46c0      	nop			; (mov r8, r8)
 8001770:	0000ffff 	.word	0x0000ffff
 8001774:	46c0      	nop			; (mov r8, r8)
 8001776:	46c0      	nop			; (mov r8, r8)
 8001778:	46c0      	nop			; (mov r8, r8)
 800177a:	46c0      	nop			; (mov r8, r8)
 800177c:	46c0      	nop			; (mov r8, r8)
 800177e:	46c0      	nop			; (mov r8, r8)

08001780 <get.6344>:

static msg_t get(void *ip) {
 8001780:	b500      	push	{lr}
 8001782:	b083      	sub	sp, #12
 8001784:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001786:	9b01      	ldr	r3, [sp, #4]
 8001788:	1c1a      	adds	r2, r3, #0
 800178a:	320c      	adds	r2, #12
 800178c:	4b04      	ldr	r3, [pc, #16]	; (80017a0 <get.6344+0x20>)
 800178e:	1c10      	adds	r0, r2, #0
 8001790:	1c19      	adds	r1, r3, #0
 8001792:	f7ff fdb5 	bl	8001300 <iqGetTimeout.4292>
 8001796:	1c03      	adds	r3, r0, #0
}
 8001798:	1c18      	adds	r0, r3, #0
 800179a:	b003      	add	sp, #12
 800179c:	bd00      	pop	{pc}
 800179e:	46c0      	nop			; (mov r8, r8)
 80017a0:	0000ffff 	.word	0x0000ffff
 80017a4:	46c0      	nop			; (mov r8, r8)
 80017a6:	46c0      	nop			; (mov r8, r8)
 80017a8:	46c0      	nop			; (mov r8, r8)
 80017aa:	46c0      	nop			; (mov r8, r8)
 80017ac:	46c0      	nop			; (mov r8, r8)
 80017ae:	46c0      	nop			; (mov r8, r8)

080017b0 <putt.6339>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80017b0:	b500      	push	{lr}
 80017b2:	b083      	sub	sp, #12
 80017b4:	9001      	str	r0, [sp, #4]
 80017b6:	466b      	mov	r3, sp
 80017b8:	3303      	adds	r3, #3
 80017ba:	7019      	strb	r1, [r3, #0]
 80017bc:	466b      	mov	r3, sp
 80017be:	801a      	strh	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80017c0:	9b01      	ldr	r3, [sp, #4]
 80017c2:	1c19      	adds	r1, r3, #0
 80017c4:	3130      	adds	r1, #48	; 0x30
 80017c6:	466b      	mov	r3, sp
 80017c8:	3303      	adds	r3, #3
 80017ca:	781a      	ldrb	r2, [r3, #0]
 80017cc:	466b      	mov	r3, sp
 80017ce:	881b      	ldrh	r3, [r3, #0]
 80017d0:	1c08      	adds	r0, r1, #0
 80017d2:	1c11      	adds	r1, r2, #0
 80017d4:	1c1a      	adds	r2, r3, #0
 80017d6:	f7ff fe5b 	bl	8001490 <oqPutTimeout.4271>
 80017da:	1c03      	adds	r3, r0, #0
}
 80017dc:	1c18      	adds	r0, r3, #0
 80017de:	b003      	add	sp, #12
 80017e0:	bd00      	pop	{pc}
 80017e2:	46c0      	nop			; (mov r8, r8)
 80017e4:	46c0      	nop			; (mov r8, r8)
 80017e6:	46c0      	nop			; (mov r8, r8)
 80017e8:	46c0      	nop			; (mov r8, r8)
 80017ea:	46c0      	nop			; (mov r8, r8)
 80017ec:	46c0      	nop			; (mov r8, r8)
 80017ee:	46c0      	nop			; (mov r8, r8)

080017f0 <gett.6347>:

static msg_t gett(void *ip, systime_t timeout) {
 80017f0:	b500      	push	{lr}
 80017f2:	b083      	sub	sp, #12
 80017f4:	9001      	str	r0, [sp, #4]
 80017f6:	1c0a      	adds	r2, r1, #0
 80017f8:	466b      	mov	r3, sp
 80017fa:	3302      	adds	r3, #2
 80017fc:	801a      	strh	r2, [r3, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80017fe:	9b01      	ldr	r3, [sp, #4]
 8001800:	1c1a      	adds	r2, r3, #0
 8001802:	320c      	adds	r2, #12
 8001804:	466b      	mov	r3, sp
 8001806:	3302      	adds	r3, #2
 8001808:	881b      	ldrh	r3, [r3, #0]
 800180a:	1c10      	adds	r0, r2, #0
 800180c:	1c19      	adds	r1, r3, #0
 800180e:	f7ff fd77 	bl	8001300 <iqGetTimeout.4292>
 8001812:	1c03      	adds	r3, r0, #0
}
 8001814:	1c18      	adds	r0, r3, #0
 8001816:	b003      	add	sp, #12
 8001818:	bd00      	pop	{pc}
 800181a:	46c0      	nop			; (mov r8, r8)
 800181c:	46c0      	nop			; (mov r8, r8)
 800181e:	46c0      	nop			; (mov r8, r8)

08001820 <writet.6312>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8001820:	b500      	push	{lr}
 8001822:	b085      	sub	sp, #20
 8001824:	9003      	str	r0, [sp, #12]
 8001826:	9102      	str	r1, [sp, #8]
 8001828:	9201      	str	r2, [sp, #4]
 800182a:	1c1a      	adds	r2, r3, #0
 800182c:	466b      	mov	r3, sp
 800182e:	3302      	adds	r3, #2
 8001830:	801a      	strh	r2, [r3, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001832:	9b03      	ldr	r3, [sp, #12]
 8001834:	1c18      	adds	r0, r3, #0
 8001836:	3030      	adds	r0, #48	; 0x30
 8001838:	9902      	ldr	r1, [sp, #8]
 800183a:	9a01      	ldr	r2, [sp, #4]
 800183c:	466b      	mov	r3, sp
 800183e:	3302      	adds	r3, #2
 8001840:	881b      	ldrh	r3, [r3, #0]
 8001842:	f7ff fead 	bl	80015a0 <oqWriteTimeout>
 8001846:	1c03      	adds	r3, r0, #0
}
 8001848:	1c18      	adds	r0, r3, #0
 800184a:	b005      	add	sp, #20
 800184c:	bd00      	pop	{pc}
 800184e:	46c0      	nop			; (mov r8, r8)

08001850 <readt.6326>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8001850:	b500      	push	{lr}
 8001852:	b085      	sub	sp, #20
 8001854:	9003      	str	r0, [sp, #12]
 8001856:	9102      	str	r1, [sp, #8]
 8001858:	9201      	str	r2, [sp, #4]
 800185a:	1c1a      	adds	r2, r3, #0
 800185c:	466b      	mov	r3, sp
 800185e:	3302      	adds	r3, #2
 8001860:	801a      	strh	r2, [r3, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001862:	9b03      	ldr	r3, [sp, #12]
 8001864:	1c18      	adds	r0, r3, #0
 8001866:	300c      	adds	r0, #12
 8001868:	9902      	ldr	r1, [sp, #8]
 800186a:	9a01      	ldr	r2, [sp, #4]
 800186c:	466b      	mov	r3, sp
 800186e:	3302      	adds	r3, #2
 8001870:	881b      	ldrh	r3, [r3, #0]
 8001872:	f7ff fd8d 	bl	8001390 <iqReadTimeout.4286>
 8001876:	1c03      	adds	r3, r0, #0
}
 8001878:	1c18      	adds	r0, r3, #0
 800187a:	b005      	add	sp, #20
 800187c:	bd00      	pop	{pc}
 800187e:	46c0      	nop			; (mov r8, r8)

08001880 <sdInit.4161>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8001880:	b508      	push	{r3, lr}

  sd_lld_init();
 8001882:	f7ff f935 	bl	8000af0 <sd_lld_init>
}
 8001886:	bd08      	pop	{r3, pc}
 8001888:	46c0      	nop			; (mov r8, r8)
 800188a:	46c0      	nop			; (mov r8, r8)
 800188c:	46c0      	nop			; (mov r8, r8)
 800188e:	46c0      	nop			; (mov r8, r8)

08001890 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8001890:	b500      	push	{lr}
 8001892:	b087      	sub	sp, #28
 8001894:	9005      	str	r0, [sp, #20]
 8001896:	9104      	str	r1, [sp, #16]
 8001898:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 800189a:	9b05      	ldr	r3, [sp, #20]
 800189c:	4a13      	ldr	r2, [pc, #76]	; (80018ec <sdObjectInit+0x5c>)
 800189e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80018a0:	9b05      	ldr	r3, [sp, #20]
 80018a2:	3304      	adds	r3, #4
 80018a4:	1c18      	adds	r0, r3, #0
 80018a6:	f7ff ff03 	bl	80016b0 <osalEventObjectInit.6291.4205>
  sdp->state = SD_STOP;
 80018aa:	9b05      	ldr	r3, [sp, #20]
 80018ac:	2201      	movs	r2, #1
 80018ae:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80018b0:	9b05      	ldr	r3, [sp, #20]
 80018b2:	1c19      	adds	r1, r3, #0
 80018b4:	310c      	adds	r1, #12
 80018b6:	9b05      	ldr	r3, [sp, #20]
 80018b8:	1c1a      	adds	r2, r3, #0
 80018ba:	3254      	adds	r2, #84	; 0x54
 80018bc:	9b04      	ldr	r3, [sp, #16]
 80018be:	9805      	ldr	r0, [sp, #20]
 80018c0:	9000      	str	r0, [sp, #0]
 80018c2:	1c08      	adds	r0, r1, #0
 80018c4:	1c11      	adds	r1, r2, #0
 80018c6:	2210      	movs	r2, #16
 80018c8:	f7ff fcb2 	bl	8001230 <iqObjectInit.4303>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80018cc:	9b05      	ldr	r3, [sp, #20]
 80018ce:	1c19      	adds	r1, r3, #0
 80018d0:	3130      	adds	r1, #48	; 0x30
 80018d2:	9b05      	ldr	r3, [sp, #20]
 80018d4:	1c1a      	adds	r2, r3, #0
 80018d6:	3264      	adds	r2, #100	; 0x64
 80018d8:	9b03      	ldr	r3, [sp, #12]
 80018da:	9805      	ldr	r0, [sp, #20]
 80018dc:	9000      	str	r0, [sp, #0]
 80018de:	1c08      	adds	r0, r1, #0
 80018e0:	1c11      	adds	r1, r2, #0
 80018e2:	2210      	movs	r2, #16
 80018e4:	f7ff fdac 	bl	8001440 <oqObjectInit.4279>
}
 80018e8:	b007      	add	sp, #28
 80018ea:	bd00      	pop	{pc}
 80018ec:	08002730 	.word	0x08002730

080018f0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 80018f0:	b500      	push	{lr}
 80018f2:	b083      	sub	sp, #12
 80018f4:	9001      	str	r0, [sp, #4]
 80018f6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 80018f8:	f7ff feca 	bl	8001690 <osalSysLock.6287>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 80018fc:	9a01      	ldr	r2, [sp, #4]
 80018fe:	9b00      	ldr	r3, [sp, #0]
 8001900:	1c10      	adds	r0, r2, #0
 8001902:	1c19      	adds	r1, r3, #0
 8001904:	f7ff f914 	bl	8000b30 <sd_lld_start>
  sdp->state = SD_READY;
 8001908:	9b01      	ldr	r3, [sp, #4]
 800190a:	2202      	movs	r2, #2
 800190c:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800190e:	f7ff fec7 	bl	80016a0 <osalSysUnlock.6289>
}
 8001912:	b003      	add	sp, #12
 8001914:	bd00      	pop	{pc}
 8001916:	46c0      	nop			; (mov r8, r8)
 8001918:	46c0      	nop			; (mov r8, r8)
 800191a:	46c0      	nop			; (mov r8, r8)
 800191c:	46c0      	nop			; (mov r8, r8)
 800191e:	46c0      	nop			; (mov r8, r8)

08001920 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001920:	4770      	bx	lr
 8001922:	46c0      	nop			; (mov r8, r8)
 8001924:	46c0      	nop			; (mov r8, r8)
 8001926:	46c0      	nop			; (mov r8, r8)
 8001928:	46c0      	nop			; (mov r8, r8)
 800192a:	46c0      	nop			; (mov r8, r8)
 800192c:	46c0      	nop			; (mov r8, r8)
 800192e:	46c0      	nop			; (mov r8, r8)

08001930 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001930:	4770      	bx	lr
 8001932:	46c0      	nop			; (mov r8, r8)
 8001934:	46c0      	nop			; (mov r8, r8)
 8001936:	46c0      	nop			; (mov r8, r8)
 8001938:	46c0      	nop			; (mov r8, r8)
 800193a:	46c0      	nop			; (mov r8, r8)
 800193c:	46c0      	nop			; (mov r8, r8)
 800193e:	46c0      	nop			; (mov r8, r8)

08001940 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001940:	e7fe      	b.n	8001940 <__default_exit>
 8001942:	46c0      	nop			; (mov r8, r8)
 8001944:	46c0      	nop			; (mov r8, r8)
 8001946:	46c0      	nop			; (mov r8, r8)
 8001948:	46c0      	nop			; (mov r8, r8)
 800194a:	46c0      	nop			; (mov r8, r8)
 800194c:	46c0      	nop			; (mov r8, r8)
 800194e:	46c0      	nop			; (mov r8, r8)

08001950 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001950:	e7fe      	b.n	8001950 <BusFault_Handler>
 8001952:	46c0      	nop			; (mov r8, r8)
 8001954:	46c0      	nop			; (mov r8, r8)
 8001956:	46c0      	nop			; (mov r8, r8)
 8001958:	46c0      	nop			; (mov r8, r8)
 800195a:	46c0      	nop			; (mov r8, r8)
 800195c:	46c0      	nop			; (mov r8, r8)
 800195e:	46c0      	nop			; (mov r8, r8)

08001960 <NVIC_SetPriority.4097.4486>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001960:	b530      	push	{r4, r5, lr}
 8001962:	b083      	sub	sp, #12
 8001964:	1c02      	adds	r2, r0, #0
 8001966:	9100      	str	r1, [sp, #0]
 8001968:	466b      	mov	r3, sp
 800196a:	3307      	adds	r3, #7
 800196c:	701a      	strb	r2, [r3, #0]
  if((int32_t)(IRQn) < 0) {
 800196e:	466b      	mov	r3, sp
 8001970:	3307      	adds	r3, #7
 8001972:	781b      	ldrb	r3, [r3, #0]
 8001974:	2b7f      	cmp	r3, #127	; 0x7f
 8001976:	d936      	bls.n	80019e6 <NVIC_SetPriority.4097.4486+0x86>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001978:	4933      	ldr	r1, [pc, #204]	; (8001a48 <NVIC_SetPriority.4097.4486+0xe8>)
 800197a:	466b      	mov	r3, sp
 800197c:	3307      	adds	r3, #7
 800197e:	781b      	ldrb	r3, [r3, #0]
 8001980:	1c1a      	adds	r2, r3, #0
 8001982:	230f      	movs	r3, #15
 8001984:	4013      	ands	r3, r2
 8001986:	3b08      	subs	r3, #8
 8001988:	0898      	lsrs	r0, r3, #2
 800198a:	4a2f      	ldr	r2, [pc, #188]	; (8001a48 <NVIC_SetPriority.4097.4486+0xe8>)
 800198c:	466b      	mov	r3, sp
 800198e:	3307      	adds	r3, #7
 8001990:	781b      	ldrb	r3, [r3, #0]
 8001992:	1c1c      	adds	r4, r3, #0
 8001994:	230f      	movs	r3, #15
 8001996:	4023      	ands	r3, r4
 8001998:	3b08      	subs	r3, #8
 800199a:	089b      	lsrs	r3, r3, #2
 800199c:	3306      	adds	r3, #6
 800199e:	009b      	lsls	r3, r3, #2
 80019a0:	18d3      	adds	r3, r2, r3
 80019a2:	685b      	ldr	r3, [r3, #4]
 80019a4:	466a      	mov	r2, sp
 80019a6:	3207      	adds	r2, #7
 80019a8:	7812      	ldrb	r2, [r2, #0]
 80019aa:	1c14      	adds	r4, r2, #0
 80019ac:	2203      	movs	r2, #3
 80019ae:	4022      	ands	r2, r4
 80019b0:	00d2      	lsls	r2, r2, #3
 80019b2:	24ff      	movs	r4, #255	; 0xff
 80019b4:	1c25      	adds	r5, r4, #0
 80019b6:	4095      	lsls	r5, r2
 80019b8:	1c2a      	adds	r2, r5, #0
 80019ba:	43d2      	mvns	r2, r2
 80019bc:	401a      	ands	r2, r3
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80019be:	9b00      	ldr	r3, [sp, #0]
 80019c0:	019c      	lsls	r4, r3, #6
 80019c2:	23ff      	movs	r3, #255	; 0xff
 80019c4:	401c      	ands	r4, r3
 80019c6:	466b      	mov	r3, sp
 80019c8:	3307      	adds	r3, #7
 80019ca:	781b      	ldrb	r3, [r3, #0]
 80019cc:	1c1d      	adds	r5, r3, #0
 80019ce:	2303      	movs	r3, #3
 80019d0:	402b      	ands	r3, r5
 80019d2:	00db      	lsls	r3, r3, #3
 80019d4:	1c25      	adds	r5, r4, #0
 80019d6:	409d      	lsls	r5, r3
 80019d8:	1c2b      	adds	r3, r5, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80019da:	431a      	orrs	r2, r3
 80019dc:	1d83      	adds	r3, r0, #6
 80019de:	009b      	lsls	r3, r3, #2
 80019e0:	18cb      	adds	r3, r1, r3
 80019e2:	605a      	str	r2, [r3, #4]
 80019e4:	e02d      	b.n	8001a42 <NVIC_SetPriority.4097.4486+0xe2>
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80019e6:	4b19      	ldr	r3, [pc, #100]	; (8001a4c <NVIC_SetPriority.4097.4486+0xec>)
 80019e8:	466a      	mov	r2, sp
 80019ea:	3207      	adds	r2, #7
 80019ec:	7812      	ldrb	r2, [r2, #0]
 80019ee:	b252      	sxtb	r2, r2
 80019f0:	0892      	lsrs	r2, r2, #2
 80019f2:	4916      	ldr	r1, [pc, #88]	; (8001a4c <NVIC_SetPriority.4097.4486+0xec>)
 80019f4:	4668      	mov	r0, sp
 80019f6:	3007      	adds	r0, #7
 80019f8:	7800      	ldrb	r0, [r0, #0]
 80019fa:	b240      	sxtb	r0, r0
 80019fc:	0880      	lsrs	r0, r0, #2
 80019fe:	30c0      	adds	r0, #192	; 0xc0
 8001a00:	0080      	lsls	r0, r0, #2
 8001a02:	5841      	ldr	r1, [r0, r1]
 8001a04:	4668      	mov	r0, sp
 8001a06:	3007      	adds	r0, #7
 8001a08:	7800      	ldrb	r0, [r0, #0]
 8001a0a:	1c04      	adds	r4, r0, #0
 8001a0c:	2003      	movs	r0, #3
 8001a0e:	4020      	ands	r0, r4
 8001a10:	00c0      	lsls	r0, r0, #3
 8001a12:	24ff      	movs	r4, #255	; 0xff
 8001a14:	1c25      	adds	r5, r4, #0
 8001a16:	4085      	lsls	r5, r0
 8001a18:	1c28      	adds	r0, r5, #0
 8001a1a:	43c0      	mvns	r0, r0
 8001a1c:	4008      	ands	r0, r1
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8001a1e:	9900      	ldr	r1, [sp, #0]
 8001a20:	018c      	lsls	r4, r1, #6
 8001a22:	21ff      	movs	r1, #255	; 0xff
 8001a24:	400c      	ands	r4, r1
 8001a26:	4669      	mov	r1, sp
 8001a28:	3107      	adds	r1, #7
 8001a2a:	7809      	ldrb	r1, [r1, #0]
 8001a2c:	1c0d      	adds	r5, r1, #0
 8001a2e:	2103      	movs	r1, #3
 8001a30:	4029      	ands	r1, r5
 8001a32:	00c9      	lsls	r1, r1, #3
 8001a34:	1c25      	adds	r5, r4, #0
 8001a36:	408d      	lsls	r5, r1
 8001a38:	1c29      	adds	r1, r5, #0
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001a3a:	4301      	orrs	r1, r0
 8001a3c:	32c0      	adds	r2, #192	; 0xc0
 8001a3e:	0092      	lsls	r2, r2, #2
 8001a40:	50d1      	str	r1, [r2, r3]
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8001a42:	b003      	add	sp, #12
 8001a44:	bd30      	pop	{r4, r5, pc}
 8001a46:	46c0      	nop			; (mov r8, r8)
 8001a48:	e000ed00 	.word	0xe000ed00
 8001a4c:	e000e100 	.word	0xe000e100

08001a50 <port_init.4106.4484>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8001a50:	b508      	push	{r3, lr}

  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8001a52:	2302      	movs	r3, #2
 8001a54:	425b      	negs	r3, r3
 8001a56:	1c18      	adds	r0, r3, #0
 8001a58:	2100      	movs	r1, #0
 8001a5a:	f7ff ff81 	bl	8001960 <NVIC_SetPriority.4097.4486>
}
 8001a5e:	bd08      	pop	{r3, pc}

08001a60 <port_lock.4117.4475>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001a60:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001a62:	4770      	bx	lr
 8001a64:	46c0      	nop			; (mov r8, r8)
 8001a66:	46c0      	nop			; (mov r8, r8)
 8001a68:	46c0      	nop			; (mov r8, r8)
 8001a6a:	46c0      	nop			; (mov r8, r8)
 8001a6c:	46c0      	nop			; (mov r8, r8)
 8001a6e:	46c0      	nop			; (mov r8, r8)

08001a70 <port_unlock.4119.4473>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a70:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001a72:	4770      	bx	lr
 8001a74:	46c0      	nop			; (mov r8, r8)
 8001a76:	46c0      	nop			; (mov r8, r8)
 8001a78:	46c0      	nop			; (mov r8, r8)
 8001a7a:	46c0      	nop			; (mov r8, r8)
 8001a7c:	46c0      	nop			; (mov r8, r8)
 8001a7e:	46c0      	nop			; (mov r8, r8)

08001a80 <port_lock_from_isr.4121.4471>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001a80:	b508      	push	{r3, lr}

  port_lock();
 8001a82:	f7ff ffed 	bl	8001a60 <port_lock.4117.4475>
}
 8001a86:	bd08      	pop	{r3, pc}
 8001a88:	46c0      	nop			; (mov r8, r8)
 8001a8a:	46c0      	nop			; (mov r8, r8)
 8001a8c:	46c0      	nop			; (mov r8, r8)
 8001a8e:	46c0      	nop			; (mov r8, r8)

08001a90 <port_unlock_from_isr.4123.4469>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001a90:	b508      	push	{r3, lr}

  port_unlock();
 8001a92:	f7ff ffed 	bl	8001a70 <port_unlock.4119.4473>
}
 8001a96:	bd08      	pop	{r3, pc}
 8001a98:	46c0      	nop			; (mov r8, r8)
 8001a9a:	46c0      	nop			; (mov r8, r8)
 8001a9c:	46c0      	nop			; (mov r8, r8)
 8001a9e:	46c0      	nop			; (mov r8, r8)

08001aa0 <port_enable.4127.4465>:
 8001aa0:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 8001aa2:	4770      	bx	lr
 8001aa4:	46c0      	nop			; (mov r8, r8)
 8001aa6:	46c0      	nop			; (mov r8, r8)
 8001aa8:	46c0      	nop			; (mov r8, r8)
 8001aaa:	46c0      	nop			; (mov r8, r8)
 8001aac:	46c0      	nop			; (mov r8, r8)
 8001aae:	46c0      	nop			; (mov r8, r8)

08001ab0 <port_wait_for_interrupt.4129.4463>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8001ab0:	4770      	bx	lr
 8001ab2:	46c0      	nop			; (mov r8, r8)
 8001ab4:	46c0      	nop			; (mov r8, r8)
 8001ab6:	46c0      	nop			; (mov r8, r8)
 8001ab8:	46c0      	nop			; (mov r8, r8)
 8001aba:	46c0      	nop			; (mov r8, r8)
 8001abc:	46c0      	nop			; (mov r8, r8)
 8001abe:	46c0      	nop			; (mov r8, r8)

08001ac0 <st_lld_get_counter.4131.4461>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001ac0:	4b02      	ldr	r3, [pc, #8]	; (8001acc <st_lld_get_counter.4131.4461+0xc>)
 8001ac2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001ac4:	b29b      	uxth	r3, r3
}
 8001ac6:	1c18      	adds	r0, r3, #0
 8001ac8:	4770      	bx	lr
 8001aca:	46c0      	nop			; (mov r8, r8)
 8001acc:	40000400 	.word	0x40000400

08001ad0 <port_timer_stop_alarm.4221.4459>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8001ad0:	b508      	push	{r3, lr}

  stStopAlarm();
 8001ad2:	f7ff fb0d 	bl	80010f0 <stStopAlarm>
}
 8001ad6:	bd08      	pop	{r3, pc}
 8001ad8:	46c0      	nop			; (mov r8, r8)
 8001ada:	46c0      	nop			; (mov r8, r8)
 8001adc:	46c0      	nop			; (mov r8, r8)
 8001ade:	46c0      	nop			; (mov r8, r8)

08001ae0 <port_timer_set_alarm.4223.4456>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8001ae0:	b500      	push	{lr}
 8001ae2:	b083      	sub	sp, #12
 8001ae4:	1c02      	adds	r2, r0, #0
 8001ae6:	466b      	mov	r3, sp
 8001ae8:	3306      	adds	r3, #6
 8001aea:	801a      	strh	r2, [r3, #0]

  stSetAlarm(time);
 8001aec:	466b      	mov	r3, sp
 8001aee:	3306      	adds	r3, #6
 8001af0:	881b      	ldrh	r3, [r3, #0]
 8001af2:	1c18      	adds	r0, r3, #0
 8001af4:	f7ff fb04 	bl	8001100 <stSetAlarm>
}
 8001af8:	b003      	add	sp, #12
 8001afa:	bd00      	pop	{pc}
 8001afc:	46c0      	nop			; (mov r8, r8)
 8001afe:	46c0      	nop			; (mov r8, r8)

08001b00 <port_timer_get_time.4136.4454>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8001b00:	b508      	push	{r3, lr}

  return stGetCounter();
 8001b02:	f7ff ffdd 	bl	8001ac0 <st_lld_get_counter.4131.4461>
 8001b06:	1c03      	adds	r3, r0, #0
}
 8001b08:	1c18      	adds	r0, r3, #0
 8001b0a:	bd08      	pop	{r3, pc}
 8001b0c:	46c0      	nop			; (mov r8, r8)
 8001b0e:	46c0      	nop			; (mov r8, r8)

08001b10 <chSysEnable.4138.4452>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8001b10:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 8001b12:	f7ff ffc5 	bl	8001aa0 <port_enable.4127.4465>
}
 8001b16:	bd08      	pop	{r3, pc}
 8001b18:	46c0      	nop			; (mov r8, r8)
 8001b1a:	46c0      	nop			; (mov r8, r8)
 8001b1c:	46c0      	nop			; (mov r8, r8)
 8001b1e:	46c0      	nop			; (mov r8, r8)

08001b20 <chSysLockFromISR.4144.4446>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001b20:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001b22:	f7ff ffad 	bl	8001a80 <port_lock_from_isr.4121.4471>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001b26:	bd08      	pop	{r3, pc}
 8001b28:	46c0      	nop			; (mov r8, r8)
 8001b2a:	46c0      	nop			; (mov r8, r8)
 8001b2c:	46c0      	nop			; (mov r8, r8)
 8001b2e:	46c0      	nop			; (mov r8, r8)

08001b30 <chSysUnlockFromISR.4146.4444>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001b30:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001b32:	f7ff ffad 	bl	8001a90 <port_unlock_from_isr.4123.4469>
}
 8001b36:	bd08      	pop	{r3, pc}
 8001b38:	46c0      	nop			; (mov r8, r8)
 8001b3a:	46c0      	nop			; (mov r8, r8)
 8001b3c:	46c0      	nop			; (mov r8, r8)
 8001b3e:	46c0      	nop			; (mov r8, r8)

08001b40 <chVTGetSystemTimeX.4148.4442>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8001b40:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8001b42:	f7ff ffdd 	bl	8001b00 <port_timer_get_time.4136.4454>
 8001b46:	1c03      	adds	r3, r0, #0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001b48:	1c18      	adds	r0, r3, #0
 8001b4a:	bd08      	pop	{r3, pc}
 8001b4c:	46c0      	nop			; (mov r8, r8)
 8001b4e:	46c0      	nop			; (mov r8, r8)

08001b50 <chVTDoTickI.4226.4440>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8001b50:	b510      	push	{r4, lr}
 8001b52:	b084      	sub	sp, #16
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8001b54:	4b33      	ldr	r3, [pc, #204]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001b56:	69db      	ldr	r3, [r3, #28]
 8001b58:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 8001b5a:	466c      	mov	r4, sp
 8001b5c:	340a      	adds	r4, #10
 8001b5e:	f7ff ffef 	bl	8001b40 <chVTGetSystemTimeX.4148.4442>
 8001b62:	1c03      	adds	r3, r0, #0
 8001b64:	8023      	strh	r3, [r4, #0]
 8001b66:	e02e      	b.n	8001bc6 <chVTDoTickI.4226.4440+0x76>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001b68:	4b2e      	ldr	r3, [pc, #184]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001b6a:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001b6c:	9b03      	ldr	r3, [sp, #12]
 8001b6e:	891b      	ldrh	r3, [r3, #8]
 8001b70:	18d3      	adds	r3, r2, r3
 8001b72:	b29a      	uxth	r2, r3
 8001b74:	4b2b      	ldr	r3, [pc, #172]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001b76:	84da      	strh	r2, [r3, #38]	; 0x26

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001b78:	9b03      	ldr	r3, [sp, #12]
 8001b7a:	681b      	ldr	r3, [r3, #0]
 8001b7c:	4a2a      	ldr	r2, [pc, #168]	; (8001c28 <chVTDoTickI.4226.4440+0xd8>)
 8001b7e:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8001b80:	9b03      	ldr	r3, [sp, #12]
 8001b82:	681a      	ldr	r2, [r3, #0]
 8001b84:	4b27      	ldr	r3, [pc, #156]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001b86:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
 8001b88:	9b03      	ldr	r3, [sp, #12]
 8001b8a:	68db      	ldr	r3, [r3, #12]
 8001b8c:	9301      	str	r3, [sp, #4]
    vtp->vt_func = NULL;
 8001b8e:	9b03      	ldr	r3, [sp, #12]
 8001b90:	2200      	movs	r2, #0
 8001b92:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001b94:	4b23      	ldr	r3, [pc, #140]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001b96:	69da      	ldr	r2, [r3, #28]
 8001b98:	4b23      	ldr	r3, [pc, #140]	; (8001c28 <chVTDoTickI.4226.4440+0xd8>)
 8001b9a:	429a      	cmp	r2, r3
 8001b9c:	d101      	bne.n	8001ba2 <chVTDoTickI.4226.4440+0x52>
      port_timer_stop_alarm();
 8001b9e:	f7ff ff97 	bl	8001ad0 <port_timer_stop_alarm.4221.4459>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 8001ba2:	f7ff ffc5 	bl	8001b30 <chSysUnlockFromISR.4146.4444>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8001ba6:	9b03      	ldr	r3, [sp, #12]
 8001ba8:	691a      	ldr	r2, [r3, #16]
 8001baa:	9b01      	ldr	r3, [sp, #4]
 8001bac:	1c10      	adds	r0, r2, #0
 8001bae:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 8001bb0:	f7ff ffb6 	bl	8001b20 <chSysLockFromISR.4144.4446>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8001bb4:	4b1b      	ldr	r3, [pc, #108]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001bb6:	69db      	ldr	r3, [r3, #28]
 8001bb8:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 8001bba:	466c      	mov	r4, sp
 8001bbc:	340a      	adds	r4, #10
 8001bbe:	f7ff ffbf 	bl	8001b40 <chVTGetSystemTimeX.4148.4442>
 8001bc2:	1c03      	adds	r3, r0, #0
 8001bc4:	8023      	strh	r3, [r4, #0]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8001bc6:	9b03      	ldr	r3, [sp, #12]
 8001bc8:	891a      	ldrh	r2, [r3, #8]
 8001bca:	4b16      	ldr	r3, [pc, #88]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001bcc:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8001bce:	4669      	mov	r1, sp
 8001bd0:	310a      	adds	r1, #10
 8001bd2:	8809      	ldrh	r1, [r1, #0]
 8001bd4:	1acb      	subs	r3, r1, r3
 8001bd6:	b29b      	uxth	r3, r3
 8001bd8:	429a      	cmp	r2, r3
 8001bda:	d9c5      	bls.n	8001b68 <chVTDoTickI.4226.4440+0x18>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001bdc:	4b11      	ldr	r3, [pc, #68]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001bde:	69da      	ldr	r2, [r3, #28]
 8001be0:	4b11      	ldr	r3, [pc, #68]	; (8001c28 <chVTDoTickI.4226.4440+0xd8>)
 8001be2:	429a      	cmp	r2, r3
 8001be4:	d01c      	beq.n	8001c20 <chVTDoTickI.4226.4440+0xd0>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8001be6:	4b0f      	ldr	r3, [pc, #60]	; (8001c24 <chVTDoTickI.4226.4440+0xd4>)
 8001be8:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001bea:	9b03      	ldr	r3, [sp, #12]
 8001bec:	891b      	ldrh	r3, [r3, #8]
 8001bee:	18d3      	adds	r3, r2, r3
 8001bf0:	b299      	uxth	r1, r3
 8001bf2:	ab02      	add	r3, sp, #8
 8001bf4:	466a      	mov	r2, sp
 8001bf6:	320a      	adds	r2, #10
 8001bf8:	8812      	ldrh	r2, [r2, #0]
 8001bfa:	1a8a      	subs	r2, r1, r2
 8001bfc:	801a      	strh	r2, [r3, #0]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8001bfe:	ab02      	add	r3, sp, #8
 8001c00:	881b      	ldrh	r3, [r3, #0]
 8001c02:	2b04      	cmp	r3, #4
 8001c04:	d802      	bhi.n	8001c0c <chVTDoTickI.4226.4440+0xbc>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001c06:	ab02      	add	r3, sp, #8
 8001c08:	2205      	movs	r2, #5
 8001c0a:	801a      	strh	r2, [r3, #0]
  }
  port_timer_set_alarm(now + delta);
 8001c0c:	466a      	mov	r2, sp
 8001c0e:	320a      	adds	r2, #10
 8001c10:	ab02      	add	r3, sp, #8
 8001c12:	8812      	ldrh	r2, [r2, #0]
 8001c14:	881b      	ldrh	r3, [r3, #0]
 8001c16:	18d3      	adds	r3, r2, r3
 8001c18:	b29b      	uxth	r3, r3
 8001c1a:	1c18      	adds	r0, r3, #0
 8001c1c:	f7ff ff60 	bl	8001ae0 <port_timer_set_alarm.4223.4456>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001c20:	b004      	add	sp, #16
 8001c22:	bd10      	pop	{r4, pc}
 8001c24:	20000300 	.word	0x20000300
 8001c28:	2000031c 	.word	0x2000031c
 8001c2c:	46c0      	nop			; (mov r8, r8)
 8001c2e:	46c0      	nop			; (mov r8, r8)

08001c30 <chRegSetThreadName.4150.4437>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8001c30:	b082      	sub	sp, #8
 8001c32:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001c34:	4b02      	ldr	r3, [pc, #8]	; (8001c40 <chRegSetThreadName.4150.4437+0x10>)
 8001c36:	699b      	ldr	r3, [r3, #24]
 8001c38:	9a01      	ldr	r2, [sp, #4]
 8001c3a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8001c3c:	b002      	add	sp, #8
 8001c3e:	4770      	bx	lr
 8001c40:	20000300 	.word	0x20000300
 8001c44:	46c0      	nop			; (mov r8, r8)
 8001c46:	46c0      	nop			; (mov r8, r8)
 8001c48:	46c0      	nop			; (mov r8, r8)
 8001c4a:	46c0      	nop			; (mov r8, r8)
 8001c4c:	46c0      	nop			; (mov r8, r8)
 8001c4e:	46c0      	nop			; (mov r8, r8)

08001c50 <chRegSetThreadNameX.4154.4433>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8001c50:	b082      	sub	sp, #8
 8001c52:	9001      	str	r0, [sp, #4]
 8001c54:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8001c56:	9b01      	ldr	r3, [sp, #4]
 8001c58:	9a00      	ldr	r2, [sp, #0]
 8001c5a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 8001c5c:	b002      	add	sp, #8
 8001c5e:	4770      	bx	lr

08001c60 <_idle_thread.4218.4430>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001c60:	b500      	push	{lr}
 8001c62:	b083      	sub	sp, #12
 8001c64:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8001c66:	f7ff ff23 	bl	8001ab0 <port_wait_for_interrupt.4129.4463>
 8001c6a:	e7fc      	b.n	8001c66 <_idle_thread.4218.4430+0x6>
 8001c6c:	46c0      	nop			; (mov r8, r8)
 8001c6e:	46c0      	nop			; (mov r8, r8)

08001c70 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8001c70:	b500      	push	{lr}
 8001c72:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8001c74:	f7ff feec 	bl	8001a50 <port_init.4106.4484>
  _scheduler_init();
 8001c78:	f000 fa12 	bl	80020a0 <_scheduler_init.4355>
  _vt_init();
 8001c7c:	f000 f880 	bl	8001d80 <_vt_init.4398>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8001c80:	f7ff f8f6 	bl	8000e70 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8001c84:	f7ff f94c 	bl	8000f20 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8001c88:	4b12      	ldr	r3, [pc, #72]	; (8001cd4 <chSysInit+0x64>)
 8001c8a:	1c18      	adds	r0, r3, #0
 8001c8c:	2140      	movs	r1, #64	; 0x40
 8001c8e:	f000 fc17 	bl	80024c0 <_thread_init.4256>
 8001c92:	1c02      	adds	r2, r0, #0
 8001c94:	4b10      	ldr	r3, [pc, #64]	; (8001cd8 <chSysInit+0x68>)
 8001c96:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8001c98:	4b0f      	ldr	r3, [pc, #60]	; (8001cd8 <chSysInit+0x68>)
 8001c9a:	699b      	ldr	r3, [r3, #24]
 8001c9c:	2201      	movs	r2, #1
 8001c9e:	771a      	strb	r2, [r3, #28]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 8001ca0:	f7ff ff36 	bl	8001b10 <chSysEnable.4138.4452>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 8001ca4:	4b0d      	ldr	r3, [pc, #52]	; (8001cdc <chSysInit+0x6c>)
 8001ca6:	1c18      	adds	r0, r3, #0
 8001ca8:	f7ff ffc2 	bl	8001c30 <chRegSetThreadName.4150.4437>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8001cac:	4a0c      	ldr	r2, [pc, #48]	; (8001ce0 <chSysInit+0x70>)
 8001cae:	4b0d      	ldr	r3, [pc, #52]	; (8001ce4 <chSysInit+0x74>)
 8001cb0:	2100      	movs	r1, #0
 8001cb2:	9100      	str	r1, [sp, #0]
 8001cb4:	1c10      	adds	r0, r2, #0
 8001cb6:	21c8      	movs	r1, #200	; 0xc8
 8001cb8:	2201      	movs	r2, #1
 8001cba:	f000 fc59 	bl	8002570 <chThdCreateStatic.4239>
 8001cbe:	1c03      	adds	r3, r0, #0
 8001cc0:	9303      	str	r3, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 8001cc2:	9a03      	ldr	r2, [sp, #12]
 8001cc4:	4b08      	ldr	r3, [pc, #32]	; (8001ce8 <chSysInit+0x78>)
 8001cc6:	1c10      	adds	r0, r2, #0
 8001cc8:	1c19      	adds	r1, r3, #0
 8001cca:	f7ff ffc1 	bl	8001c50 <chRegSetThreadNameX.4154.4433>
  }
#endif
}
 8001cce:	b005      	add	sp, #20
 8001cd0:	bd00      	pop	{pc}
 8001cd2:	46c0      	nop			; (mov r8, r8)
 8001cd4:	2000032c 	.word	0x2000032c
 8001cd8:	20000300 	.word	0x20000300
 8001cdc:	08002710 	.word	0x08002710
 8001ce0:	20000360 	.word	0x20000360
 8001ce4:	08001c61 	.word	0x08001c61
 8001ce8:	08002700 	.word	0x08002700
 8001cec:	46c0      	nop			; (mov r8, r8)
 8001cee:	46c0      	nop			; (mov r8, r8)

08001cf0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8001cf0:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8001cf2:	f7ff ff2d 	bl	8001b50 <chVTDoTickI.4226.4440>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 8001cf6:	bd08      	pop	{r3, pc}
 8001cf8:	46c0      	nop			; (mov r8, r8)
 8001cfa:	46c0      	nop			; (mov r8, r8)
 8001cfc:	46c0      	nop			; (mov r8, r8)
 8001cfe:	46c0      	nop			; (mov r8, r8)

08001d00 <st_lld_get_counter.4377.4412>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001d00:	4b02      	ldr	r3, [pc, #8]	; (8001d0c <st_lld_get_counter.4377.4412+0xc>)
 8001d02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001d04:	b29b      	uxth	r3, r3
}
 8001d06:	1c18      	adds	r0, r3, #0
 8001d08:	4770      	bx	lr
 8001d0a:	46c0      	nop			; (mov r8, r8)
 8001d0c:	40000400 	.word	0x40000400

08001d10 <port_timer_start_alarm.4387.4409>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8001d10:	b500      	push	{lr}
 8001d12:	b083      	sub	sp, #12
 8001d14:	1c02      	adds	r2, r0, #0
 8001d16:	466b      	mov	r3, sp
 8001d18:	3306      	adds	r3, #6
 8001d1a:	801a      	strh	r2, [r3, #0]

  stStartAlarm(time);
 8001d1c:	466b      	mov	r3, sp
 8001d1e:	3306      	adds	r3, #6
 8001d20:	881b      	ldrh	r3, [r3, #0]
 8001d22:	1c18      	adds	r0, r3, #0
 8001d24:	f7ff f9d4 	bl	80010d0 <stStartAlarm>
}
 8001d28:	b003      	add	sp, #12
 8001d2a:	bd00      	pop	{pc}
 8001d2c:	46c0      	nop			; (mov r8, r8)
 8001d2e:	46c0      	nop			; (mov r8, r8)

08001d30 <port_timer_stop_alarm.4393.4407>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8001d30:	b508      	push	{r3, lr}

  stStopAlarm();
 8001d32:	f7ff f9dd 	bl	80010f0 <stStopAlarm>
}
 8001d36:	bd08      	pop	{r3, pc}
 8001d38:	46c0      	nop			; (mov r8, r8)
 8001d3a:	46c0      	nop			; (mov r8, r8)
 8001d3c:	46c0      	nop			; (mov r8, r8)
 8001d3e:	46c0      	nop			; (mov r8, r8)

08001d40 <port_timer_set_alarm.4390.4404>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8001d40:	b500      	push	{lr}
 8001d42:	b083      	sub	sp, #12
 8001d44:	1c02      	adds	r2, r0, #0
 8001d46:	466b      	mov	r3, sp
 8001d48:	3306      	adds	r3, #6
 8001d4a:	801a      	strh	r2, [r3, #0]

  stSetAlarm(time);
 8001d4c:	466b      	mov	r3, sp
 8001d4e:	3306      	adds	r3, #6
 8001d50:	881b      	ldrh	r3, [r3, #0]
 8001d52:	1c18      	adds	r0, r3, #0
 8001d54:	f7ff f9d4 	bl	8001100 <stSetAlarm>
}
 8001d58:	b003      	add	sp, #12
 8001d5a:	bd00      	pop	{pc}
 8001d5c:	46c0      	nop			; (mov r8, r8)
 8001d5e:	46c0      	nop			; (mov r8, r8)

08001d60 <port_timer_get_time.4383.4402>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8001d60:	b508      	push	{r3, lr}

  return stGetCounter();
 8001d62:	f7ff ffcd 	bl	8001d00 <st_lld_get_counter.4377.4412>
 8001d66:	1c03      	adds	r3, r0, #0
}
 8001d68:	1c18      	adds	r0, r3, #0
 8001d6a:	bd08      	pop	{r3, pc}
 8001d6c:	46c0      	nop			; (mov r8, r8)
 8001d6e:	46c0      	nop			; (mov r8, r8)

08001d70 <chVTGetSystemTimeX.4385.4400>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8001d70:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8001d72:	f7ff fff5 	bl	8001d60 <port_timer_get_time.4383.4402>
 8001d76:	1c03      	adds	r3, r0, #0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001d78:	1c18      	adds	r0, r3, #0
 8001d7a:	bd08      	pop	{r3, pc}
 8001d7c:	46c0      	nop			; (mov r8, r8)
 8001d7e:	46c0      	nop			; (mov r8, r8)

08001d80 <_vt_init.4398>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001d80:	4b06      	ldr	r3, [pc, #24]	; (8001d9c <_vt_init.4398+0x1c>)
 8001d82:	4a07      	ldr	r2, [pc, #28]	; (8001da0 <_vt_init.4398+0x20>)
 8001d84:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001d86:	4b05      	ldr	r3, [pc, #20]	; (8001d9c <_vt_init.4398+0x1c>)
 8001d88:	4a05      	ldr	r2, [pc, #20]	; (8001da0 <_vt_init.4398+0x20>)
 8001d8a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001d8c:	4b03      	ldr	r3, [pc, #12]	; (8001d9c <_vt_init.4398+0x1c>)
 8001d8e:	2201      	movs	r2, #1
 8001d90:	4252      	negs	r2, r2
 8001d92:	849a      	strh	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8001d94:	4b01      	ldr	r3, [pc, #4]	; (8001d9c <_vt_init.4398+0x1c>)
 8001d96:	2200      	movs	r2, #0
 8001d98:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001d9a:	4770      	bx	lr
 8001d9c:	20000300 	.word	0x20000300
 8001da0:	2000031c 	.word	0x2000031c
 8001da4:	46c0      	nop			; (mov r8, r8)
 8001da6:	46c0      	nop			; (mov r8, r8)
 8001da8:	46c0      	nop			; (mov r8, r8)
 8001daa:	46c0      	nop			; (mov r8, r8)
 8001dac:	46c0      	nop			; (mov r8, r8)
 8001dae:	46c0      	nop			; (mov r8, r8)

08001db0 <chVTDoSetI.4392>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001db0:	b510      	push	{r4, lr}
 8001db2:	b086      	sub	sp, #24
 8001db4:	9003      	str	r0, [sp, #12]
 8001db6:	9201      	str	r2, [sp, #4]
 8001db8:	9300      	str	r3, [sp, #0]
 8001dba:	466b      	mov	r3, sp
 8001dbc:	330a      	adds	r3, #10
 8001dbe:	1c0a      	adds	r2, r1, #0
 8001dc0:	801a      	strh	r2, [r3, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001dc2:	9b03      	ldr	r3, [sp, #12]
 8001dc4:	9a00      	ldr	r2, [sp, #0]
 8001dc6:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 8001dc8:	9b03      	ldr	r3, [sp, #12]
 8001dca:	9a01      	ldr	r2, [sp, #4]
 8001dcc:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 8001dce:	ac04      	add	r4, sp, #16
 8001dd0:	f7ff ffce 	bl	8001d70 <chVTGetSystemTimeX.4385.4400>
 8001dd4:	1c03      	adds	r3, r0, #0
 8001dd6:	8023      	strh	r3, [r4, #0]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8001dd8:	466b      	mov	r3, sp
 8001dda:	330a      	adds	r3, #10
 8001ddc:	881b      	ldrh	r3, [r3, #0]
 8001dde:	2b04      	cmp	r3, #4
 8001de0:	d803      	bhi.n	8001dea <chVTDoSetI.4392+0x3a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001de2:	466b      	mov	r3, sp
 8001de4:	330a      	adds	r3, #10
 8001de6:	2205      	movs	r2, #5
 8001de8:	801a      	strh	r2, [r3, #0]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001dea:	4b3f      	ldr	r3, [pc, #252]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001dec:	69da      	ldr	r2, [r3, #28]
 8001dee:	4b3f      	ldr	r3, [pc, #252]	; (8001eec <chVTDoSetI.4392+0x13c>)
 8001df0:	429a      	cmp	r2, r3
 8001df2:	d11f      	bne.n	8001e34 <chVTDoSetI.4392+0x84>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8001df4:	4b3c      	ldr	r3, [pc, #240]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001df6:	aa04      	add	r2, sp, #16
 8001df8:	8812      	ldrh	r2, [r2, #0]
 8001dfa:	84da      	strh	r2, [r3, #38]	; 0x26
      ch.vtlist.vt_next = vtp;
 8001dfc:	4b3a      	ldr	r3, [pc, #232]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001dfe:	9a03      	ldr	r2, [sp, #12]
 8001e00:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
 8001e02:	4b39      	ldr	r3, [pc, #228]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001e04:	9a03      	ldr	r2, [sp, #12]
 8001e06:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8001e08:	9b03      	ldr	r3, [sp, #12]
 8001e0a:	4a38      	ldr	r2, [pc, #224]	; (8001eec <chVTDoSetI.4392+0x13c>)
 8001e0c:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001e0e:	9b03      	ldr	r3, [sp, #12]
 8001e10:	4a36      	ldr	r2, [pc, #216]	; (8001eec <chVTDoSetI.4392+0x13c>)
 8001e12:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 8001e14:	9b03      	ldr	r3, [sp, #12]
 8001e16:	466a      	mov	r2, sp
 8001e18:	320a      	adds	r2, #10
 8001e1a:	8812      	ldrh	r2, [r2, #0]
 8001e1c:	811a      	strh	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8001e1e:	4b32      	ldr	r3, [pc, #200]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001e20:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001e22:	466b      	mov	r3, sp
 8001e24:	330a      	adds	r3, #10
 8001e26:	881b      	ldrh	r3, [r3, #0]
 8001e28:	18d3      	adds	r3, r2, r3
 8001e2a:	b29b      	uxth	r3, r3
 8001e2c:	1c18      	adds	r0, r3, #0
 8001e2e:	f7ff ff6f 	bl	8001d10 <port_timer_start_alarm.4387.4409>
 8001e32:	e056      	b.n	8001ee2 <chVTDoSetI.4392+0x132>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001e34:	aa04      	add	r2, sp, #16
 8001e36:	466b      	mov	r3, sp
 8001e38:	330a      	adds	r3, #10
 8001e3a:	8812      	ldrh	r2, [r2, #0]
 8001e3c:	881b      	ldrh	r3, [r3, #0]
 8001e3e:	18d3      	adds	r3, r2, r3
 8001e40:	b299      	uxth	r1, r3
 8001e42:	4b29      	ldr	r3, [pc, #164]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001e44:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001e46:	466b      	mov	r3, sp
 8001e48:	3312      	adds	r3, #18
 8001e4a:	1a8a      	subs	r2, r1, r2
 8001e4c:	801a      	strh	r2, [r3, #0]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001e4e:	4b26      	ldr	r3, [pc, #152]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001e50:	69db      	ldr	r3, [r3, #28]
 8001e52:	891b      	ldrh	r3, [r3, #8]
 8001e54:	466a      	mov	r2, sp
 8001e56:	3212      	adds	r2, #18
 8001e58:	8812      	ldrh	r2, [r2, #0]
 8001e5a:	429a      	cmp	r2, r3
 8001e5c:	d209      	bcs.n	8001e72 <chVTDoSetI.4392+0xc2>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 8001e5e:	4b22      	ldr	r3, [pc, #136]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001e60:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001e62:	466b      	mov	r3, sp
 8001e64:	3312      	adds	r3, #18
 8001e66:	881b      	ldrh	r3, [r3, #0]
 8001e68:	18d3      	adds	r3, r2, r3
 8001e6a:	b29b      	uxth	r3, r3
 8001e6c:	1c18      	adds	r0, r3, #0
 8001e6e:	f7ff ff67 	bl	8001d40 <port_timer_set_alarm.4390.4404>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8001e72:	4b1d      	ldr	r3, [pc, #116]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001e74:	69db      	ldr	r3, [r3, #28]
 8001e76:	9305      	str	r3, [sp, #20]
 8001e78:	e00b      	b.n	8001e92 <chVTDoSetI.4392+0xe2>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001e7a:	9b05      	ldr	r3, [sp, #20]
 8001e7c:	891a      	ldrh	r2, [r3, #8]
 8001e7e:	466b      	mov	r3, sp
 8001e80:	3312      	adds	r3, #18
 8001e82:	4669      	mov	r1, sp
 8001e84:	3112      	adds	r1, #18
 8001e86:	8809      	ldrh	r1, [r1, #0]
 8001e88:	1a8a      	subs	r2, r1, r2
 8001e8a:	801a      	strh	r2, [r3, #0]
    p = p->vt_next;
 8001e8c:	9b05      	ldr	r3, [sp, #20]
 8001e8e:	681b      	ldr	r3, [r3, #0]
 8001e90:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001e92:	9b05      	ldr	r3, [sp, #20]
 8001e94:	891b      	ldrh	r3, [r3, #8]
 8001e96:	466a      	mov	r2, sp
 8001e98:	3212      	adds	r2, #18
 8001e9a:	8812      	ldrh	r2, [r2, #0]
 8001e9c:	429a      	cmp	r2, r3
 8001e9e:	d8ec      	bhi.n	8001e7a <chVTDoSetI.4392+0xca>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8001ea0:	9b03      	ldr	r3, [sp, #12]
 8001ea2:	9a05      	ldr	r2, [sp, #20]
 8001ea4:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001ea6:	9b03      	ldr	r3, [sp, #12]
 8001ea8:	681b      	ldr	r3, [r3, #0]
 8001eaa:	685a      	ldr	r2, [r3, #4]
 8001eac:	9b03      	ldr	r3, [sp, #12]
 8001eae:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 8001eb0:	9b03      	ldr	r3, [sp, #12]
 8001eb2:	685b      	ldr	r3, [r3, #4]
 8001eb4:	9a03      	ldr	r2, [sp, #12]
 8001eb6:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 8001eb8:	9b05      	ldr	r3, [sp, #20]
 8001eba:	9a03      	ldr	r2, [sp, #12]
 8001ebc:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 8001ebe:	9b03      	ldr	r3, [sp, #12]
 8001ec0:	466a      	mov	r2, sp
 8001ec2:	3212      	adds	r2, #18
 8001ec4:	8812      	ldrh	r2, [r2, #0]
 8001ec6:	811a      	strh	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001ec8:	9b05      	ldr	r3, [sp, #20]
 8001eca:	891a      	ldrh	r2, [r3, #8]
 8001ecc:	466b      	mov	r3, sp
 8001ece:	3312      	adds	r3, #18
 8001ed0:	881b      	ldrh	r3, [r3, #0]
 8001ed2:	1ad3      	subs	r3, r2, r3
 8001ed4:	b29a      	uxth	r2, r3
 8001ed6:	9b05      	ldr	r3, [sp, #20]
 8001ed8:	811a      	strh	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001eda:	4b03      	ldr	r3, [pc, #12]	; (8001ee8 <chVTDoSetI.4392+0x138>)
 8001edc:	2201      	movs	r2, #1
 8001ede:	4252      	negs	r2, r2
 8001ee0:	849a      	strh	r2, [r3, #36]	; 0x24
}
 8001ee2:	b006      	add	sp, #24
 8001ee4:	bd10      	pop	{r4, pc}
 8001ee6:	46c0      	nop			; (mov r8, r8)
 8001ee8:	20000300 	.word	0x20000300
 8001eec:	2000031c 	.word	0x2000031c

08001ef0 <chVTDoResetI.4388>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001ef0:	b500      	push	{lr}
 8001ef2:	b085      	sub	sp, #20
 8001ef4:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8001ef6:	4b38      	ldr	r3, [pc, #224]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001ef8:	69da      	ldr	r2, [r3, #28]
 8001efa:	9b01      	ldr	r3, [sp, #4]
 8001efc:	429a      	cmp	r2, r3
 8001efe:	d01c      	beq.n	8001f3a <chVTDoResetI.4388+0x4a>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8001f00:	9b01      	ldr	r3, [sp, #4]
 8001f02:	685b      	ldr	r3, [r3, #4]
 8001f04:	9a01      	ldr	r2, [sp, #4]
 8001f06:	6812      	ldr	r2, [r2, #0]
 8001f08:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8001f0a:	9b01      	ldr	r3, [sp, #4]
 8001f0c:	681b      	ldr	r3, [r3, #0]
 8001f0e:	9a01      	ldr	r2, [sp, #4]
 8001f10:	6852      	ldr	r2, [r2, #4]
 8001f12:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8001f14:	9b01      	ldr	r3, [sp, #4]
 8001f16:	2200      	movs	r2, #0
 8001f18:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001f1a:	9b01      	ldr	r3, [sp, #4]
 8001f1c:	681a      	ldr	r2, [r3, #0]
 8001f1e:	4b2f      	ldr	r3, [pc, #188]	; (8001fdc <chVTDoResetI.4388+0xec>)
 8001f20:	429a      	cmp	r2, r3
 8001f22:	d057      	beq.n	8001fd4 <chVTDoResetI.4388+0xe4>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8001f24:	9b01      	ldr	r3, [sp, #4]
 8001f26:	681a      	ldr	r2, [r3, #0]
 8001f28:	9b01      	ldr	r3, [sp, #4]
 8001f2a:	681b      	ldr	r3, [r3, #0]
 8001f2c:	8919      	ldrh	r1, [r3, #8]
 8001f2e:	9b01      	ldr	r3, [sp, #4]
 8001f30:	891b      	ldrh	r3, [r3, #8]
 8001f32:	18cb      	adds	r3, r1, r3
 8001f34:	b29b      	uxth	r3, r3
 8001f36:	8113      	strh	r3, [r2, #8]
 8001f38:	e04c      	b.n	8001fd4 <chVTDoResetI.4388+0xe4>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8001f3a:	9b01      	ldr	r3, [sp, #4]
 8001f3c:	681a      	ldr	r2, [r3, #0]
 8001f3e:	4b26      	ldr	r3, [pc, #152]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001f40:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001f42:	4b25      	ldr	r3, [pc, #148]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001f44:	69db      	ldr	r3, [r3, #28]
 8001f46:	4a25      	ldr	r2, [pc, #148]	; (8001fdc <chVTDoResetI.4388+0xec>)
 8001f48:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8001f4a:	9b01      	ldr	r3, [sp, #4]
 8001f4c:	2200      	movs	r2, #0
 8001f4e:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001f50:	4b21      	ldr	r3, [pc, #132]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001f52:	69da      	ldr	r2, [r3, #28]
 8001f54:	4b21      	ldr	r3, [pc, #132]	; (8001fdc <chVTDoResetI.4388+0xec>)
 8001f56:	429a      	cmp	r2, r3
 8001f58:	d102      	bne.n	8001f60 <chVTDoResetI.4388+0x70>
    port_timer_stop_alarm();
 8001f5a:	f7ff fee9 	bl	8001d30 <port_timer_stop_alarm.4393.4407>
 8001f5e:	e039      	b.n	8001fd4 <chVTDoResetI.4388+0xe4>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8001f60:	4b1d      	ldr	r3, [pc, #116]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001f62:	69da      	ldr	r2, [r3, #28]
 8001f64:	4b1c      	ldr	r3, [pc, #112]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001f66:	69db      	ldr	r3, [r3, #28]
 8001f68:	8919      	ldrh	r1, [r3, #8]
 8001f6a:	9b01      	ldr	r3, [sp, #4]
 8001f6c:	891b      	ldrh	r3, [r3, #8]
 8001f6e:	18cb      	adds	r3, r1, r3
 8001f70:	b29b      	uxth	r3, r3
 8001f72:	8113      	strh	r3, [r2, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8001f74:	f7ff fefc 	bl	8001d70 <chVTGetSystemTimeX.4385.4400>
 8001f78:	1c03      	adds	r3, r0, #0
 8001f7a:	1c19      	adds	r1, r3, #0
 8001f7c:	4b16      	ldr	r3, [pc, #88]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001f7e:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001f80:	ab03      	add	r3, sp, #12
 8001f82:	1a8a      	subs	r2, r1, r2
 8001f84:	801a      	strh	r2, [r3, #0]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8001f86:	4b14      	ldr	r3, [pc, #80]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001f88:	69db      	ldr	r3, [r3, #28]
 8001f8a:	891b      	ldrh	r3, [r3, #8]
 8001f8c:	aa03      	add	r2, sp, #12
 8001f8e:	8812      	ldrh	r2, [r2, #0]
 8001f90:	429a      	cmp	r2, r3
 8001f92:	d21f      	bcs.n	8001fd4 <chVTDoResetI.4388+0xe4>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8001f94:	4b10      	ldr	r3, [pc, #64]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001f96:	69db      	ldr	r3, [r3, #28]
 8001f98:	8919      	ldrh	r1, [r3, #8]
 8001f9a:	466b      	mov	r3, sp
 8001f9c:	330e      	adds	r3, #14
 8001f9e:	aa03      	add	r2, sp, #12
 8001fa0:	8812      	ldrh	r2, [r2, #0]
 8001fa2:	1a8a      	subs	r2, r1, r2
 8001fa4:	801a      	strh	r2, [r3, #0]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8001fa6:	466b      	mov	r3, sp
 8001fa8:	330e      	adds	r3, #14
 8001faa:	881b      	ldrh	r3, [r3, #0]
 8001fac:	2b04      	cmp	r3, #4
 8001fae:	d803      	bhi.n	8001fb8 <chVTDoResetI.4388+0xc8>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001fb0:	466b      	mov	r3, sp
 8001fb2:	330e      	adds	r3, #14
 8001fb4:	2205      	movs	r2, #5
 8001fb6:	801a      	strh	r2, [r3, #0]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8001fb8:	4b07      	ldr	r3, [pc, #28]	; (8001fd8 <chVTDoResetI.4388+0xe8>)
 8001fba:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001fbc:	ab03      	add	r3, sp, #12
 8001fbe:	881b      	ldrh	r3, [r3, #0]
 8001fc0:	18d3      	adds	r3, r2, r3
 8001fc2:	b29a      	uxth	r2, r3
 8001fc4:	466b      	mov	r3, sp
 8001fc6:	330e      	adds	r3, #14
 8001fc8:	881b      	ldrh	r3, [r3, #0]
 8001fca:	18d3      	adds	r3, r2, r3
 8001fcc:	b29b      	uxth	r3, r3
 8001fce:	1c18      	adds	r0, r3, #0
 8001fd0:	f7ff feb6 	bl	8001d40 <port_timer_set_alarm.4390.4404>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001fd4:	b005      	add	sp, #20
 8001fd6:	bd00      	pop	{pc}
 8001fd8:	20000300 	.word	0x20000300
 8001fdc:	2000031c 	.word	0x2000031c

08001fe0 <port_lock.4537.4386>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001fe0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001fe2:	4770      	bx	lr
 8001fe4:	46c0      	nop			; (mov r8, r8)
 8001fe6:	46c0      	nop			; (mov r8, r8)
 8001fe8:	46c0      	nop			; (mov r8, r8)
 8001fea:	46c0      	nop			; (mov r8, r8)
 8001fec:	46c0      	nop			; (mov r8, r8)
 8001fee:	46c0      	nop			; (mov r8, r8)

08001ff0 <port_unlock.4540.4384>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001ff0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001ff2:	4770      	bx	lr
 8001ff4:	46c0      	nop			; (mov r8, r8)
 8001ff6:	46c0      	nop			; (mov r8, r8)
 8001ff8:	46c0      	nop			; (mov r8, r8)
 8001ffa:	46c0      	nop			; (mov r8, r8)
 8001ffc:	46c0      	nop			; (mov r8, r8)
 8001ffe:	46c0      	nop			; (mov r8, r8)

08002000 <port_lock_from_isr.4542.4382>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002000:	b508      	push	{r3, lr}

  port_lock();
 8002002:	f7ff ffed 	bl	8001fe0 <port_lock.4537.4386>
}
 8002006:	bd08      	pop	{r3, pc}
 8002008:	46c0      	nop			; (mov r8, r8)
 800200a:	46c0      	nop			; (mov r8, r8)
 800200c:	46c0      	nop			; (mov r8, r8)
 800200e:	46c0      	nop			; (mov r8, r8)

08002010 <port_unlock_from_isr.4544.4380>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002010:	b508      	push	{r3, lr}

  port_unlock();
 8002012:	f7ff ffed 	bl	8001ff0 <port_unlock.4540.4384>
}
 8002016:	bd08      	pop	{r3, pc}
 8002018:	46c0      	nop			; (mov r8, r8)
 800201a:	46c0      	nop			; (mov r8, r8)
 800201c:	46c0      	nop			; (mov r8, r8)
 800201e:	46c0      	nop			; (mov r8, r8)

08002020 <queue_init.4546.4377>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002020:	b082      	sub	sp, #8
 8002022:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002024:	9b01      	ldr	r3, [sp, #4]
 8002026:	9a01      	ldr	r2, [sp, #4]
 8002028:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800202a:	9b01      	ldr	r3, [sp, #4]
 800202c:	9a01      	ldr	r2, [sp, #4]
 800202e:	605a      	str	r2, [r3, #4]
}
 8002030:	b002      	add	sp, #8
 8002032:	4770      	bx	lr
 8002034:	46c0      	nop			; (mov r8, r8)
 8002036:	46c0      	nop			; (mov r8, r8)
 8002038:	46c0      	nop			; (mov r8, r8)
 800203a:	46c0      	nop			; (mov r8, r8)
 800203c:	46c0      	nop			; (mov r8, r8)
 800203e:	46c0      	nop			; (mov r8, r8)

08002040 <chSysLockFromISR.4615.4373>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002040:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002042:	f7ff ffdd 	bl	8002000 <port_lock_from_isr.4542.4382>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002046:	bd08      	pop	{r3, pc}
 8002048:	46c0      	nop			; (mov r8, r8)
 800204a:	46c0      	nop			; (mov r8, r8)
 800204c:	46c0      	nop			; (mov r8, r8)
 800204e:	46c0      	nop			; (mov r8, r8)

08002050 <chSysUnlockFromISR.4617.4371>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002050:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002052:	f7ff ffdd 	bl	8002010 <port_unlock_from_isr.4544.4380>
}
 8002056:	bd08      	pop	{r3, pc}
 8002058:	46c0      	nop			; (mov r8, r8)
 800205a:	46c0      	nop			; (mov r8, r8)
 800205c:	46c0      	nop			; (mov r8, r8)
 800205e:	46c0      	nop			; (mov r8, r8)

08002060 <chVTIsArmedI.4619.4360>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8002060:	b082      	sub	sp, #8
 8002062:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8002064:	9b01      	ldr	r3, [sp, #4]
 8002066:	68db      	ldr	r3, [r3, #12]
 8002068:	1e5a      	subs	r2, r3, #1
 800206a:	4193      	sbcs	r3, r2
 800206c:	b2db      	uxtb	r3, r3
}
 800206e:	1c18      	adds	r0, r3, #0
 8002070:	b002      	add	sp, #8
 8002072:	4770      	bx	lr
 8002074:	46c0      	nop			; (mov r8, r8)
 8002076:	46c0      	nop			; (mov r8, r8)
 8002078:	46c0      	nop			; (mov r8, r8)
 800207a:	46c0      	nop			; (mov r8, r8)
 800207c:	46c0      	nop			; (mov r8, r8)
 800207e:	46c0      	nop			; (mov r8, r8)

08002080 <chSemFastSignalI.4633.4357>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8002080:	b082      	sub	sp, #8
 8002082:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8002084:	9b01      	ldr	r3, [sp, #4]
 8002086:	689b      	ldr	r3, [r3, #8]
 8002088:	1c5a      	adds	r2, r3, #1
 800208a:	9b01      	ldr	r3, [sp, #4]
 800208c:	609a      	str	r2, [r3, #8]
}
 800208e:	b002      	add	sp, #8
 8002090:	4770      	bx	lr
 8002092:	46c0      	nop			; (mov r8, r8)
 8002094:	46c0      	nop			; (mov r8, r8)
 8002096:	46c0      	nop			; (mov r8, r8)
 8002098:	46c0      	nop			; (mov r8, r8)
 800209a:	46c0      	nop			; (mov r8, r8)
 800209c:	46c0      	nop			; (mov r8, r8)
 800209e:	46c0      	nop			; (mov r8, r8)

080020a0 <_scheduler_init.4355>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 80020a0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 80020a2:	4b07      	ldr	r3, [pc, #28]	; (80020c0 <_scheduler_init.4355+0x20>)
 80020a4:	1c18      	adds	r0, r3, #0
 80020a6:	f7ff ffbb 	bl	8002020 <queue_init.4546.4377>
  ch.rlist.r_prio = NOPRIO;
 80020aa:	4b05      	ldr	r3, [pc, #20]	; (80020c0 <_scheduler_init.4355+0x20>)
 80020ac:	2200      	movs	r2, #0
 80020ae:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 80020b0:	4b03      	ldr	r3, [pc, #12]	; (80020c0 <_scheduler_init.4355+0x20>)
 80020b2:	4a03      	ldr	r2, [pc, #12]	; (80020c0 <_scheduler_init.4355+0x20>)
 80020b4:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 80020b6:	4b02      	ldr	r3, [pc, #8]	; (80020c0 <_scheduler_init.4355+0x20>)
 80020b8:	4a01      	ldr	r2, [pc, #4]	; (80020c0 <_scheduler_init.4355+0x20>)
 80020ba:	615a      	str	r2, [r3, #20]
#endif
}
 80020bc:	bd08      	pop	{r3, pc}
 80020be:	46c0      	nop			; (mov r8, r8)
 80020c0:	20000300 	.word	0x20000300
 80020c4:	46c0      	nop			; (mov r8, r8)
 80020c6:	46c0      	nop			; (mov r8, r8)
 80020c8:	46c0      	nop			; (mov r8, r8)
 80020ca:	46c0      	nop			; (mov r8, r8)
 80020cc:	46c0      	nop			; (mov r8, r8)
 80020ce:	46c0      	nop			; (mov r8, r8)

080020d0 <queue_insert.4347>:
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 80020d0:	b082      	sub	sp, #8
 80020d2:	9001      	str	r0, [sp, #4]
 80020d4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 80020d6:	9b01      	ldr	r3, [sp, #4]
 80020d8:	9a00      	ldr	r2, [sp, #0]
 80020da:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80020dc:	9b00      	ldr	r3, [sp, #0]
 80020de:	685a      	ldr	r2, [r3, #4]
 80020e0:	9b01      	ldr	r3, [sp, #4]
 80020e2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80020e4:	9b01      	ldr	r3, [sp, #4]
 80020e6:	685b      	ldr	r3, [r3, #4]
 80020e8:	9a01      	ldr	r2, [sp, #4]
 80020ea:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 80020ec:	9b00      	ldr	r3, [sp, #0]
 80020ee:	9a01      	ldr	r2, [sp, #4]
 80020f0:	605a      	str	r2, [r3, #4]
}
 80020f2:	b002      	add	sp, #8
 80020f4:	4770      	bx	lr
 80020f6:	46c0      	nop			; (mov r8, r8)
 80020f8:	46c0      	nop			; (mov r8, r8)
 80020fa:	46c0      	nop			; (mov r8, r8)
 80020fc:	46c0      	nop			; (mov r8, r8)
 80020fe:	46c0      	nop			; (mov r8, r8)

08002100 <queue_fifo_remove>:
 * @param[in] tqp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002100:	b084      	sub	sp, #16
 8002102:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8002104:	9b01      	ldr	r3, [sp, #4]
 8002106:	681b      	ldr	r3, [r3, #0]
 8002108:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800210a:	9b03      	ldr	r3, [sp, #12]
 800210c:	681a      	ldr	r2, [r3, #0]
 800210e:	9b01      	ldr	r3, [sp, #4]
 8002110:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002112:	9b01      	ldr	r3, [sp, #4]
 8002114:	681b      	ldr	r3, [r3, #0]
 8002116:	9a01      	ldr	r2, [sp, #4]
 8002118:	605a      	str	r2, [r3, #4]

  return tp;
 800211a:	9b03      	ldr	r3, [sp, #12]
}
 800211c:	1c18      	adds	r0, r3, #0
 800211e:	b004      	add	sp, #16
 8002120:	4770      	bx	lr
 8002122:	46c0      	nop			; (mov r8, r8)
 8002124:	46c0      	nop			; (mov r8, r8)
 8002126:	46c0      	nop			; (mov r8, r8)
 8002128:	46c0      	nop			; (mov r8, r8)
 800212a:	46c0      	nop			; (mov r8, r8)
 800212c:	46c0      	nop			; (mov r8, r8)
 800212e:	46c0      	nop			; (mov r8, r8)

08002130 <queue_dequeue>:
 * @param[in] tp        the pointer to the thread to be removed from the queue
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_dequeue(thread_t *tp) {
 8002130:	b082      	sub	sp, #8
 8002132:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8002134:	9b01      	ldr	r3, [sp, #4]
 8002136:	685b      	ldr	r3, [r3, #4]
 8002138:	9a01      	ldr	r2, [sp, #4]
 800213a:	6812      	ldr	r2, [r2, #0]
 800213c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800213e:	9b01      	ldr	r3, [sp, #4]
 8002140:	681b      	ldr	r3, [r3, #0]
 8002142:	9a01      	ldr	r2, [sp, #4]
 8002144:	6852      	ldr	r2, [r2, #4]
 8002146:	605a      	str	r2, [r3, #4]

  return tp;
 8002148:	9b01      	ldr	r3, [sp, #4]
}
 800214a:	1c18      	adds	r0, r3, #0
 800214c:	b002      	add	sp, #8
 800214e:	4770      	bx	lr

08002150 <list_remove.4331>:
 * @param[in] tlp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *list_remove(threads_list_t *tlp) {
 8002150:	b084      	sub	sp, #16
 8002152:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8002154:	9b01      	ldr	r3, [sp, #4]
 8002156:	681b      	ldr	r3, [r3, #0]
 8002158:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 800215a:	9b03      	ldr	r3, [sp, #12]
 800215c:	681a      	ldr	r2, [r3, #0]
 800215e:	9b01      	ldr	r3, [sp, #4]
 8002160:	601a      	str	r2, [r3, #0]

  return tp;
 8002162:	9b03      	ldr	r3, [sp, #12]
}
 8002164:	1c18      	adds	r0, r3, #0
 8002166:	b004      	add	sp, #16
 8002168:	4770      	bx	lr
 800216a:	46c0      	nop			; (mov r8, r8)
 800216c:	46c0      	nop			; (mov r8, r8)
 800216e:	46c0      	nop			; (mov r8, r8)

08002170 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8002170:	b084      	sub	sp, #16
 8002172:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8002174:	9b01      	ldr	r3, [sp, #4]
 8002176:	2200      	movs	r2, #0
 8002178:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 800217a:	4b0e      	ldr	r3, [pc, #56]	; (80021b4 <chSchReadyI+0x44>)
 800217c:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800217e:	9b03      	ldr	r3, [sp, #12]
 8002180:	681b      	ldr	r3, [r3, #0]
 8002182:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8002184:	9b03      	ldr	r3, [sp, #12]
 8002186:	689a      	ldr	r2, [r3, #8]
 8002188:	9b01      	ldr	r3, [sp, #4]
 800218a:	689b      	ldr	r3, [r3, #8]
 800218c:	429a      	cmp	r2, r3
 800218e:	d2f6      	bcs.n	800217e <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8002190:	9b01      	ldr	r3, [sp, #4]
 8002192:	9a03      	ldr	r2, [sp, #12]
 8002194:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8002196:	9b03      	ldr	r3, [sp, #12]
 8002198:	685a      	ldr	r2, [r3, #4]
 800219a:	9b01      	ldr	r3, [sp, #4]
 800219c:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800219e:	9b01      	ldr	r3, [sp, #4]
 80021a0:	685b      	ldr	r3, [r3, #4]
 80021a2:	9a01      	ldr	r2, [sp, #4]
 80021a4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80021a6:	9b03      	ldr	r3, [sp, #12]
 80021a8:	9a01      	ldr	r2, [sp, #4]
 80021aa:	605a      	str	r2, [r3, #4]

  return tp;
 80021ac:	9b01      	ldr	r3, [sp, #4]
}
 80021ae:	1c18      	adds	r0, r3, #0
 80021b0:	b004      	add	sp, #16
 80021b2:	4770      	bx	lr
 80021b4:	20000300 	.word	0x20000300
 80021b8:	46c0      	nop			; (mov r8, r8)
 80021ba:	46c0      	nop			; (mov r8, r8)
 80021bc:	46c0      	nop			; (mov r8, r8)
 80021be:	46c0      	nop			; (mov r8, r8)

080021c0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80021c0:	b500      	push	{lr}
 80021c2:	b085      	sub	sp, #20
 80021c4:	1c02      	adds	r2, r0, #0
 80021c6:	466b      	mov	r3, sp
 80021c8:	3307      	adds	r3, #7
 80021ca:	701a      	strb	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80021cc:	4b0d      	ldr	r3, [pc, #52]	; (8002204 <chSchGoSleepS+0x44>)
 80021ce:	699b      	ldr	r3, [r3, #24]
 80021d0:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 80021d2:	9b03      	ldr	r3, [sp, #12]
 80021d4:	466a      	mov	r2, sp
 80021d6:	3207      	adds	r2, #7
 80021d8:	7812      	ldrb	r2, [r2, #0]
 80021da:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80021dc:	4b09      	ldr	r3, [pc, #36]	; (8002204 <chSchGoSleepS+0x44>)
 80021de:	1c18      	adds	r0, r3, #0
 80021e0:	f7ff ff8e 	bl	8002100 <queue_fifo_remove>
 80021e4:	1c02      	adds	r2, r0, #0
 80021e6:	4b07      	ldr	r3, [pc, #28]	; (8002204 <chSchGoSleepS+0x44>)
 80021e8:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80021ea:	4b06      	ldr	r3, [pc, #24]	; (8002204 <chSchGoSleepS+0x44>)
 80021ec:	699b      	ldr	r3, [r3, #24]
 80021ee:	2201      	movs	r2, #1
 80021f0:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 80021f2:	4b04      	ldr	r3, [pc, #16]	; (8002204 <chSchGoSleepS+0x44>)
 80021f4:	699a      	ldr	r2, [r3, #24]
 80021f6:	9b03      	ldr	r3, [sp, #12]
 80021f8:	1c10      	adds	r0, r2, #0
 80021fa:	1c19      	adds	r1, r3, #0
 80021fc:	f7fd ffc8 	bl	8000190 <_port_switch>
}
 8002200:	b005      	add	sp, #20
 8002202:	bd00      	pop	{pc}
 8002204:	20000300 	.word	0x20000300
 8002208:	46c0      	nop			; (mov r8, r8)
 800220a:	46c0      	nop			; (mov r8, r8)
 800220c:	46c0      	nop			; (mov r8, r8)
 800220e:	46c0      	nop			; (mov r8, r8)

08002210 <wakeup.4666.4322>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8002210:	b500      	push	{lr}
 8002212:	b085      	sub	sp, #20
 8002214:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8002216:	9b01      	ldr	r3, [sp, #4]
 8002218:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 800221a:	f7ff ff11 	bl	8002040 <chSysLockFromISR.4615.4373>
  switch (tp->p_state) {
 800221e:	9b03      	ldr	r3, [sp, #12]
 8002220:	7f1b      	ldrb	r3, [r3, #28]
 8002222:	2b07      	cmp	r3, #7
 8002224:	d815      	bhi.n	8002252 <wakeup.4666.4322+0x42>
 8002226:	009a      	lsls	r2, r3, #2
 8002228:	4b10      	ldr	r3, [pc, #64]	; (800226c <wakeup.4666.4322+0x5c>)
 800222a:	18d3      	adds	r3, r2, r3
 800222c:	681b      	ldr	r3, [r3, #0]
 800222e:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8002230:	f7ff ff0e 	bl	8002050 <chSysUnlockFromISR.4617.4371>
 8002234:	e017      	b.n	8002266 <wakeup.4666.4322+0x56>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8002236:	9b03      	ldr	r3, [sp, #12]
 8002238:	6a1b      	ldr	r3, [r3, #32]
 800223a:	2200      	movs	r2, #0
 800223c:	601a      	str	r2, [r3, #0]
 800223e:	e008      	b.n	8002252 <wakeup.4666.4322+0x42>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8002240:	9b03      	ldr	r3, [sp, #12]
 8002242:	6a1b      	ldr	r3, [r3, #32]
 8002244:	1c18      	adds	r0, r3, #0
 8002246:	f7ff ff1b 	bl	8002080 <chSemFastSignalI.4633.4357>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800224a:	9b03      	ldr	r3, [sp, #12]
 800224c:	1c18      	adds	r0, r3, #0
 800224e:	f7ff ff6f 	bl	8002130 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8002252:	9b03      	ldr	r3, [sp, #12]
 8002254:	2201      	movs	r2, #1
 8002256:	4252      	negs	r2, r2
 8002258:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 800225a:	9b03      	ldr	r3, [sp, #12]
 800225c:	1c18      	adds	r0, r3, #0
 800225e:	f7ff ff87 	bl	8002170 <chSchReadyI>
  chSysUnlockFromISR();
 8002262:	f7ff fef5 	bl	8002050 <chSysUnlockFromISR.4617.4371>
}
 8002266:	b005      	add	sp, #20
 8002268:	bd00      	pop	{pc}
 800226a:	46c0      	nop			; (mov r8, r8)
 800226c:	080027d0 	.word	0x080027d0

08002270 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8002270:	b500      	push	{lr}
 8002272:	b089      	sub	sp, #36	; 0x24
 8002274:	1c0a      	adds	r2, r1, #0
 8002276:	466b      	mov	r3, sp
 8002278:	3307      	adds	r3, #7
 800227a:	1c01      	adds	r1, r0, #0
 800227c:	7019      	strb	r1, [r3, #0]
 800227e:	ab01      	add	r3, sp, #4
 8002280:	801a      	strh	r2, [r3, #0]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8002282:	ab01      	add	r3, sp, #4
 8002284:	881a      	ldrh	r2, [r3, #0]
 8002286:	4b14      	ldr	r3, [pc, #80]	; (80022d8 <chSchGoSleepTimeoutS+0x68>)
 8002288:	429a      	cmp	r2, r3
 800228a:	d019      	beq.n	80022c0 <chSchGoSleepTimeoutS+0x50>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800228c:	4b13      	ldr	r3, [pc, #76]	; (80022dc <chSchGoSleepTimeoutS+0x6c>)
 800228e:	699b      	ldr	r3, [r3, #24]
 8002290:	a803      	add	r0, sp, #12
 8002292:	aa01      	add	r2, sp, #4
 8002294:	8811      	ldrh	r1, [r2, #0]
 8002296:	4a12      	ldr	r2, [pc, #72]	; (80022e0 <chSchGoSleepTimeoutS+0x70>)
 8002298:	f7ff fd8a 	bl	8001db0 <chVTDoSetI.4392>
    chSchGoSleepS(newstate);
 800229c:	466b      	mov	r3, sp
 800229e:	3307      	adds	r3, #7
 80022a0:	781b      	ldrb	r3, [r3, #0]
 80022a2:	1c18      	adds	r0, r3, #0
 80022a4:	f7ff ff8c 	bl	80021c0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80022a8:	ab03      	add	r3, sp, #12
 80022aa:	1c18      	adds	r0, r3, #0
 80022ac:	f7ff fed8 	bl	8002060 <chVTIsArmedI.4619.4360>
 80022b0:	1c03      	adds	r3, r0, #0
 80022b2:	2b00      	cmp	r3, #0
 80022b4:	d00a      	beq.n	80022cc <chSchGoSleepTimeoutS+0x5c>
      chVTDoResetI(&vt);
 80022b6:	ab03      	add	r3, sp, #12
 80022b8:	1c18      	adds	r0, r3, #0
 80022ba:	f7ff fe19 	bl	8001ef0 <chVTDoResetI.4388>
 80022be:	e005      	b.n	80022cc <chSchGoSleepTimeoutS+0x5c>
    }
  }
  else {
    chSchGoSleepS(newstate);
 80022c0:	466b      	mov	r3, sp
 80022c2:	3307      	adds	r3, #7
 80022c4:	781b      	ldrb	r3, [r3, #0]
 80022c6:	1c18      	adds	r0, r3, #0
 80022c8:	f7ff ff7a 	bl	80021c0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 80022cc:	4b03      	ldr	r3, [pc, #12]	; (80022dc <chSchGoSleepTimeoutS+0x6c>)
 80022ce:	699b      	ldr	r3, [r3, #24]
 80022d0:	6a1b      	ldr	r3, [r3, #32]
}
 80022d2:	1c18      	adds	r0, r3, #0
 80022d4:	b009      	add	sp, #36	; 0x24
 80022d6:	bd00      	pop	{pc}
 80022d8:	0000ffff 	.word	0x0000ffff
 80022dc:	20000300 	.word	0x20000300
 80022e0:	08002211 	.word	0x08002211
 80022e4:	46c0      	nop			; (mov r8, r8)
 80022e6:	46c0      	nop			; (mov r8, r8)
 80022e8:	46c0      	nop			; (mov r8, r8)
 80022ea:	46c0      	nop			; (mov r8, r8)
 80022ec:	46c0      	nop			; (mov r8, r8)
 80022ee:	46c0      	nop			; (mov r8, r8)

080022f0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80022f0:	b500      	push	{lr}
 80022f2:	b085      	sub	sp, #20
 80022f4:	9001      	str	r0, [sp, #4]
 80022f6:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80022f8:	9b01      	ldr	r3, [sp, #4]
 80022fa:	9a00      	ldr	r2, [sp, #0]
 80022fc:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80022fe:	9b01      	ldr	r3, [sp, #4]
 8002300:	689a      	ldr	r2, [r3, #8]
 8002302:	4b0f      	ldr	r3, [pc, #60]	; (8002340 <chSchWakeupS+0x50>)
 8002304:	699b      	ldr	r3, [r3, #24]
 8002306:	689b      	ldr	r3, [r3, #8]
 8002308:	429a      	cmp	r2, r3
 800230a:	d804      	bhi.n	8002316 <chSchWakeupS+0x26>
    (void) chSchReadyI(ntp);
 800230c:	9b01      	ldr	r3, [sp, #4]
 800230e:	1c18      	adds	r0, r3, #0
 8002310:	f7ff ff2e 	bl	8002170 <chSchReadyI>
 8002314:	e012      	b.n	800233c <chSchWakeupS+0x4c>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8002316:	4b0a      	ldr	r3, [pc, #40]	; (8002340 <chSchWakeupS+0x50>)
 8002318:	699b      	ldr	r3, [r3, #24]
 800231a:	1c18      	adds	r0, r3, #0
 800231c:	f7ff ff28 	bl	8002170 <chSchReadyI>
 8002320:	1c03      	adds	r3, r0, #0
 8002322:	9303      	str	r3, [sp, #12]
    setcurrp(ntp);
 8002324:	4b06      	ldr	r3, [pc, #24]	; (8002340 <chSchWakeupS+0x50>)
 8002326:	9a01      	ldr	r2, [sp, #4]
 8002328:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800232a:	9b01      	ldr	r3, [sp, #4]
 800232c:	2201      	movs	r2, #1
 800232e:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8002330:	9a01      	ldr	r2, [sp, #4]
 8002332:	9b03      	ldr	r3, [sp, #12]
 8002334:	1c10      	adds	r0, r2, #0
 8002336:	1c19      	adds	r1, r3, #0
 8002338:	f7fd ff2a 	bl	8000190 <_port_switch>
  }
}
 800233c:	b005      	add	sp, #20
 800233e:	bd00      	pop	{pc}
 8002340:	20000300 	.word	0x20000300
 8002344:	46c0      	nop			; (mov r8, r8)
 8002346:	46c0      	nop			; (mov r8, r8)
 8002348:	46c0      	nop			; (mov r8, r8)
 800234a:	46c0      	nop			; (mov r8, r8)
 800234c:	46c0      	nop			; (mov r8, r8)
 800234e:	46c0      	nop			; (mov r8, r8)

08002350 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8002350:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8002352:	4b08      	ldr	r3, [pc, #32]	; (8002374 <chSchIsPreemptionRequired+0x24>)
 8002354:	681b      	ldr	r3, [r3, #0]
 8002356:	689b      	ldr	r3, [r3, #8]
 8002358:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 800235a:	4b06      	ldr	r3, [pc, #24]	; (8002374 <chSchIsPreemptionRequired+0x24>)
 800235c:	699b      	ldr	r3, [r3, #24]
 800235e:	689b      	ldr	r3, [r3, #8]
 8002360:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8002362:	9b01      	ldr	r3, [sp, #4]
 8002364:	9a00      	ldr	r2, [sp, #0]
 8002366:	429a      	cmp	r2, r3
 8002368:	419b      	sbcs	r3, r3
 800236a:	425b      	negs	r3, r3
 800236c:	b2db      	uxtb	r3, r3
#endif
}
 800236e:	1c18      	adds	r0, r3, #0
 8002370:	b002      	add	sp, #8
 8002372:	4770      	bx	lr
 8002374:	20000300 	.word	0x20000300
 8002378:	46c0      	nop			; (mov r8, r8)
 800237a:	46c0      	nop			; (mov r8, r8)
 800237c:	46c0      	nop			; (mov r8, r8)
 800237e:	46c0      	nop			; (mov r8, r8)

08002380 <chSchDoRescheduleAhead.4306>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8002380:	b500      	push	{lr}
 8002382:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8002384:	4b19      	ldr	r3, [pc, #100]	; (80023ec <chSchDoRescheduleAhead.4306+0x6c>)
 8002386:	699b      	ldr	r3, [r3, #24]
 8002388:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800238a:	4b18      	ldr	r3, [pc, #96]	; (80023ec <chSchDoRescheduleAhead.4306+0x6c>)
 800238c:	1c18      	adds	r0, r3, #0
 800238e:	f7ff feb7 	bl	8002100 <queue_fifo_remove>
 8002392:	1c02      	adds	r2, r0, #0
 8002394:	4b15      	ldr	r3, [pc, #84]	; (80023ec <chSchDoRescheduleAhead.4306+0x6c>)
 8002396:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8002398:	4b14      	ldr	r3, [pc, #80]	; (80023ec <chSchDoRescheduleAhead.4306+0x6c>)
 800239a:	699b      	ldr	r3, [r3, #24]
 800239c:	2201      	movs	r2, #1
 800239e:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 80023a0:	9b00      	ldr	r3, [sp, #0]
 80023a2:	2200      	movs	r2, #0
 80023a4:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80023a6:	4b11      	ldr	r3, [pc, #68]	; (80023ec <chSchDoRescheduleAhead.4306+0x6c>)
 80023a8:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 80023aa:	9b01      	ldr	r3, [sp, #4]
 80023ac:	681b      	ldr	r3, [r3, #0]
 80023ae:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 80023b0:	9b01      	ldr	r3, [sp, #4]
 80023b2:	689a      	ldr	r2, [r3, #8]
 80023b4:	9b00      	ldr	r3, [sp, #0]
 80023b6:	689b      	ldr	r3, [r3, #8]
 80023b8:	429a      	cmp	r2, r3
 80023ba:	d8f6      	bhi.n	80023aa <chSchDoRescheduleAhead.4306+0x2a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80023bc:	9b00      	ldr	r3, [sp, #0]
 80023be:	9a01      	ldr	r2, [sp, #4]
 80023c0:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 80023c2:	9b01      	ldr	r3, [sp, #4]
 80023c4:	685a      	ldr	r2, [r3, #4]
 80023c6:	9b00      	ldr	r3, [sp, #0]
 80023c8:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 80023ca:	9b00      	ldr	r3, [sp, #0]
 80023cc:	685b      	ldr	r3, [r3, #4]
 80023ce:	9a00      	ldr	r2, [sp, #0]
 80023d0:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 80023d2:	9b01      	ldr	r3, [sp, #4]
 80023d4:	9a00      	ldr	r2, [sp, #0]
 80023d6:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 80023d8:	4b04      	ldr	r3, [pc, #16]	; (80023ec <chSchDoRescheduleAhead.4306+0x6c>)
 80023da:	699a      	ldr	r2, [r3, #24]
 80023dc:	9b00      	ldr	r3, [sp, #0]
 80023de:	1c10      	adds	r0, r2, #0
 80023e0:	1c19      	adds	r1, r3, #0
 80023e2:	f7fd fed5 	bl	8000190 <_port_switch>
}
 80023e6:	b003      	add	sp, #12
 80023e8:	bd00      	pop	{pc}
 80023ea:	46c0      	nop			; (mov r8, r8)
 80023ec:	20000300 	.word	0x20000300

080023f0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80023f0:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 80023f2:	f7ff ffc5 	bl	8002380 <chSchDoRescheduleAhead.4306>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 80023f6:	bd08      	pop	{r3, pc}
 80023f8:	46c0      	nop			; (mov r8, r8)
 80023fa:	46c0      	nop			; (mov r8, r8)
 80023fc:	46c0      	nop			; (mov r8, r8)
 80023fe:	46c0      	nop			; (mov r8, r8)

08002400 <port_lock.4742.4302>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002400:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8002402:	4770      	bx	lr
 8002404:	46c0      	nop			; (mov r8, r8)
 8002406:	46c0      	nop			; (mov r8, r8)
 8002408:	46c0      	nop			; (mov r8, r8)
 800240a:	46c0      	nop			; (mov r8, r8)
 800240c:	46c0      	nop			; (mov r8, r8)
 800240e:	46c0      	nop			; (mov r8, r8)

08002410 <port_unlock.4745.4300>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002410:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8002412:	4770      	bx	lr
 8002414:	46c0      	nop			; (mov r8, r8)
 8002416:	46c0      	nop			; (mov r8, r8)
 8002418:	46c0      	nop			; (mov r8, r8)
 800241a:	46c0      	nop			; (mov r8, r8)
 800241c:	46c0      	nop			; (mov r8, r8)
 800241e:	46c0      	nop			; (mov r8, r8)

08002420 <list_init.4754.4293>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8002420:	b082      	sub	sp, #8
 8002422:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8002424:	9b01      	ldr	r3, [sp, #4]
 8002426:	9a01      	ldr	r2, [sp, #4]
 8002428:	601a      	str	r2, [r3, #0]
}
 800242a:	b002      	add	sp, #8
 800242c:	4770      	bx	lr
 800242e:	46c0      	nop			; (mov r8, r8)

08002430 <list_notempty.4820.4290>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8002430:	b082      	sub	sp, #8
 8002432:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8002434:	9b01      	ldr	r3, [sp, #4]
 8002436:	681a      	ldr	r2, [r3, #0]
 8002438:	9b01      	ldr	r3, [sp, #4]
 800243a:	1ad3      	subs	r3, r2, r3
 800243c:	1e5a      	subs	r2, r3, #1
 800243e:	4193      	sbcs	r3, r2
 8002440:	b2db      	uxtb	r3, r3
}
 8002442:	1c18      	adds	r0, r3, #0
 8002444:	b002      	add	sp, #8
 8002446:	4770      	bx	lr
 8002448:	46c0      	nop			; (mov r8, r8)
 800244a:	46c0      	nop			; (mov r8, r8)
 800244c:	46c0      	nop			; (mov r8, r8)
 800244e:	46c0      	nop			; (mov r8, r8)

08002450 <queue_notempty.4824.4287>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002450:	b082      	sub	sp, #8
 8002452:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002454:	9b01      	ldr	r3, [sp, #4]
 8002456:	681a      	ldr	r2, [r3, #0]
 8002458:	9b01      	ldr	r3, [sp, #4]
 800245a:	1ad3      	subs	r3, r2, r3
 800245c:	1e5a      	subs	r2, r3, #1
 800245e:	4193      	sbcs	r3, r2
 8002460:	b2db      	uxtb	r3, r3
}
 8002462:	1c18      	adds	r0, r3, #0
 8002464:	b002      	add	sp, #8
 8002466:	4770      	bx	lr
 8002468:	46c0      	nop			; (mov r8, r8)
 800246a:	46c0      	nop			; (mov r8, r8)
 800246c:	46c0      	nop			; (mov r8, r8)
 800246e:	46c0      	nop			; (mov r8, r8)

08002470 <chSysLock.4829.4281>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8002470:	b508      	push	{r3, lr}

  port_lock();
 8002472:	f7ff ffc5 	bl	8002400 <port_lock.4742.4302>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002476:	bd08      	pop	{r3, pc}
 8002478:	46c0      	nop			; (mov r8, r8)
 800247a:	46c0      	nop			; (mov r8, r8)
 800247c:	46c0      	nop			; (mov r8, r8)
 800247e:	46c0      	nop			; (mov r8, r8)

08002480 <chSysUnlock.4831.4279>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002480:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002482:	f7ff ffc5 	bl	8002410 <port_unlock.4745.4300>
}
 8002486:	bd08      	pop	{r3, pc}
 8002488:	46c0      	nop			; (mov r8, r8)
 800248a:	46c0      	nop			; (mov r8, r8)
 800248c:	46c0      	nop			; (mov r8, r8)
 800248e:	46c0      	nop			; (mov r8, r8)

08002490 <chThdDoDequeueNextI.4850.4260>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002490:	b500      	push	{lr}
 8002492:	b085      	sub	sp, #20
 8002494:	9001      	str	r0, [sp, #4]
 8002496:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 8002498:	9b01      	ldr	r3, [sp, #4]
 800249a:	1c18      	adds	r0, r3, #0
 800249c:	f7ff fe30 	bl	8002100 <queue_fifo_remove>
 80024a0:	1c03      	adds	r3, r0, #0
 80024a2:	9303      	str	r3, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80024a4:	9b03      	ldr	r3, [sp, #12]
 80024a6:	9a00      	ldr	r2, [sp, #0]
 80024a8:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80024aa:	9b03      	ldr	r3, [sp, #12]
 80024ac:	1c18      	adds	r0, r3, #0
 80024ae:	f7ff fe5f 	bl	8002170 <chSchReadyI>
}
 80024b2:	b005      	add	sp, #20
 80024b4:	bd00      	pop	{pc}
 80024b6:	46c0      	nop			; (mov r8, r8)
 80024b8:	46c0      	nop			; (mov r8, r8)
 80024ba:	46c0      	nop			; (mov r8, r8)
 80024bc:	46c0      	nop			; (mov r8, r8)
 80024be:	46c0      	nop			; (mov r8, r8)

080024c0 <_thread_init.4256>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 80024c0:	b500      	push	{lr}
 80024c2:	b083      	sub	sp, #12
 80024c4:	9001      	str	r0, [sp, #4]
 80024c6:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 80024c8:	9b01      	ldr	r3, [sp, #4]
 80024ca:	9a00      	ldr	r2, [sp, #0]
 80024cc:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 80024ce:	9b01      	ldr	r3, [sp, #4]
 80024d0:	2202      	movs	r2, #2
 80024d2:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80024d4:	9b01      	ldr	r3, [sp, #4]
 80024d6:	2200      	movs	r2, #0
 80024d8:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80024da:	9b01      	ldr	r3, [sp, #4]
 80024dc:	9a00      	ldr	r2, [sp, #0]
 80024de:	62da      	str	r2, [r3, #44]	; 0x2c
  tp->p_mtxlist = NULL;
 80024e0:	9b01      	ldr	r3, [sp, #4]
 80024e2:	2200      	movs	r2, #0
 80024e4:	629a      	str	r2, [r3, #40]	; 0x28
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80024e6:	9b01      	ldr	r3, [sp, #4]
 80024e8:	2200      	movs	r2, #0
 80024ea:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 80024ec:	9b01      	ldr	r3, [sp, #4]
 80024ee:	4a0b      	ldr	r2, [pc, #44]	; (800251c <_thread_init.4256+0x5c>)
 80024f0:	611a      	str	r2, [r3, #16]
 80024f2:	4b0a      	ldr	r3, [pc, #40]	; (800251c <_thread_init.4256+0x5c>)
 80024f4:	695a      	ldr	r2, [r3, #20]
 80024f6:	9b01      	ldr	r3, [sp, #4]
 80024f8:	615a      	str	r2, [r3, #20]
 80024fa:	9b01      	ldr	r3, [sp, #4]
 80024fc:	695b      	ldr	r3, [r3, #20]
 80024fe:	9a01      	ldr	r2, [sp, #4]
 8002500:	611a      	str	r2, [r3, #16]
 8002502:	4b06      	ldr	r3, [pc, #24]	; (800251c <_thread_init.4256+0x5c>)
 8002504:	9a01      	ldr	r2, [sp, #4]
 8002506:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8002508:	9b01      	ldr	r3, [sp, #4]
 800250a:	3324      	adds	r3, #36	; 0x24
 800250c:	1c18      	adds	r0, r3, #0
 800250e:	f7ff ff87 	bl	8002420 <list_init.4754.4293>
  chTMStartMeasurementX(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 8002512:	9b01      	ldr	r3, [sp, #4]
}
 8002514:	1c18      	adds	r0, r3, #0
 8002516:	b003      	add	sp, #12
 8002518:	bd00      	pop	{pc}
 800251a:	46c0      	nop			; (mov r8, r8)
 800251c:	20000300 	.word	0x20000300

08002520 <chThdCreateI.4248>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8002520:	b500      	push	{lr}
 8002522:	b087      	sub	sp, #28
 8002524:	9003      	str	r0, [sp, #12]
 8002526:	9102      	str	r1, [sp, #8]
 8002528:	9201      	str	r2, [sp, #4]
 800252a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800252c:	9b03      	ldr	r3, [sp, #12]
 800252e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002530:	9b02      	ldr	r3, [sp, #8]
 8002532:	3b24      	subs	r3, #36	; 0x24
 8002534:	9a03      	ldr	r2, [sp, #12]
 8002536:	18d2      	adds	r2, r2, r3
 8002538:	9b05      	ldr	r3, [sp, #20]
 800253a:	60da      	str	r2, [r3, #12]
 800253c:	9b05      	ldr	r3, [sp, #20]
 800253e:	68db      	ldr	r3, [r3, #12]
 8002540:	9a00      	ldr	r2, [sp, #0]
 8002542:	611a      	str	r2, [r3, #16]
 8002544:	9b05      	ldr	r3, [sp, #20]
 8002546:	68db      	ldr	r3, [r3, #12]
 8002548:	9a08      	ldr	r2, [sp, #32]
 800254a:	615a      	str	r2, [r3, #20]
 800254c:	9b05      	ldr	r3, [sp, #20]
 800254e:	68db      	ldr	r3, [r3, #12]
 8002550:	4a05      	ldr	r2, [pc, #20]	; (8002568 <chThdCreateI.4248+0x48>)
 8002552:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 8002554:	9a05      	ldr	r2, [sp, #20]
 8002556:	9b01      	ldr	r3, [sp, #4]
 8002558:	1c10      	adds	r0, r2, #0
 800255a:	1c19      	adds	r1, r3, #0
 800255c:	f7ff ffb0 	bl	80024c0 <_thread_init.4256>
 8002560:	1c03      	adds	r3, r0, #0
}
 8002562:	1c18      	adds	r0, r3, #0
 8002564:	b007      	add	sp, #28
 8002566:	bd00      	pop	{pc}
 8002568:	080001b1 	.word	0x080001b1
 800256c:	46c0      	nop			; (mov r8, r8)
 800256e:	46c0      	nop			; (mov r8, r8)

08002570 <chThdCreateStatic.4239>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8002570:	b510      	push	{r4, lr}
 8002572:	b088      	sub	sp, #32
 8002574:	9005      	str	r0, [sp, #20]
 8002576:	9104      	str	r1, [sp, #16]
 8002578:	9203      	str	r2, [sp, #12]
 800257a:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800257c:	f7ff ff78 	bl	8002470 <chSysLock.4829.4281>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8002580:	9805      	ldr	r0, [sp, #20]
 8002582:	9904      	ldr	r1, [sp, #16]
 8002584:	9a03      	ldr	r2, [sp, #12]
 8002586:	9b02      	ldr	r3, [sp, #8]
 8002588:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800258a:	9400      	str	r4, [sp, #0]
 800258c:	f7ff ffc8 	bl	8002520 <chThdCreateI.4248>
 8002590:	1c03      	adds	r3, r0, #0
 8002592:	9307      	str	r3, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8002594:	9b07      	ldr	r3, [sp, #28]
 8002596:	1c18      	adds	r0, r3, #0
 8002598:	2100      	movs	r1, #0
 800259a:	f7ff fea9 	bl	80022f0 <chSchWakeupS>
  chSysUnlock();
 800259e:	f7ff ff6f 	bl	8002480 <chSysUnlock.4831.4279>

  return tp;
 80025a2:	9b07      	ldr	r3, [sp, #28]
}
 80025a4:	1c18      	adds	r0, r3, #0
 80025a6:	b008      	add	sp, #32
 80025a8:	bd10      	pop	{r4, pc}
 80025aa:	46c0      	nop			; (mov r8, r8)
 80025ac:	46c0      	nop			; (mov r8, r8)
 80025ae:	46c0      	nop			; (mov r8, r8)

080025b0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80025b0:	b500      	push	{lr}
 80025b2:	b083      	sub	sp, #12
 80025b4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80025b6:	f7ff ff5b 	bl	8002470 <chSysLock.4829.4281>
  chThdExitS(msg);
 80025ba:	9b01      	ldr	r3, [sp, #4]
 80025bc:	1c18      	adds	r0, r3, #0
 80025be:	f000 f807 	bl	80025d0 <chThdExitS.4212>
  /* The thread never returns here.*/
}
 80025c2:	b003      	add	sp, #12
 80025c4:	bd00      	pop	{pc}
 80025c6:	46c0      	nop			; (mov r8, r8)
 80025c8:	46c0      	nop			; (mov r8, r8)
 80025ca:	46c0      	nop			; (mov r8, r8)
 80025cc:	46c0      	nop			; (mov r8, r8)
 80025ce:	46c0      	nop			; (mov r8, r8)

080025d0 <chThdExitS.4212>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80025d0:	b500      	push	{lr}
 80025d2:	b085      	sub	sp, #20
 80025d4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80025d6:	4b16      	ldr	r3, [pc, #88]	; (8002630 <chThdExitS.4212+0x60>)
 80025d8:	699b      	ldr	r3, [r3, #24]
 80025da:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 80025dc:	9b03      	ldr	r3, [sp, #12]
 80025de:	9a01      	ldr	r2, [sp, #4]
 80025e0:	621a      	str	r2, [r3, #32]
 80025e2:	e008      	b.n	80025f6 <chThdExitS.4212+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80025e4:	9b03      	ldr	r3, [sp, #12]
 80025e6:	3324      	adds	r3, #36	; 0x24
 80025e8:	1c18      	adds	r0, r3, #0
 80025ea:	f7ff fdb1 	bl	8002150 <list_remove.4331>
 80025ee:	1c03      	adds	r3, r0, #0
 80025f0:	1c18      	adds	r0, r3, #0
 80025f2:	f7ff fdbd 	bl	8002170 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80025f6:	9b03      	ldr	r3, [sp, #12]
 80025f8:	3324      	adds	r3, #36	; 0x24
 80025fa:	1c18      	adds	r0, r3, #0
 80025fc:	f7ff ff18 	bl	8002430 <list_notempty.4820.4290>
 8002600:	1c03      	adds	r3, r0, #0
 8002602:	2b00      	cmp	r3, #0
 8002604:	d1ee      	bne.n	80025e4 <chThdExitS.4212+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8002606:	9b03      	ldr	r3, [sp, #12]
 8002608:	7f5b      	ldrb	r3, [r3, #29]
 800260a:	1c1a      	adds	r2, r3, #0
 800260c:	2303      	movs	r3, #3
 800260e:	4013      	ands	r3, r2
 8002610:	d109      	bne.n	8002626 <chThdExitS.4212+0x56>
    REG_REMOVE(tp);
 8002612:	9b03      	ldr	r3, [sp, #12]
 8002614:	695b      	ldr	r3, [r3, #20]
 8002616:	9a03      	ldr	r2, [sp, #12]
 8002618:	6912      	ldr	r2, [r2, #16]
 800261a:	611a      	str	r2, [r3, #16]
 800261c:	9b03      	ldr	r3, [sp, #12]
 800261e:	691b      	ldr	r3, [r3, #16]
 8002620:	9a03      	ldr	r2, [sp, #12]
 8002622:	6952      	ldr	r2, [r2, #20]
 8002624:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8002626:	200f      	movs	r0, #15
 8002628:	f7ff fdca 	bl	80021c0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 800262c:	b005      	add	sp, #20
 800262e:	bd00      	pop	{pc}
 8002630:	20000300 	.word	0x20000300
 8002634:	46c0      	nop			; (mov r8, r8)
 8002636:	46c0      	nop			; (mov r8, r8)
 8002638:	46c0      	nop			; (mov r8, r8)
 800263a:	46c0      	nop			; (mov r8, r8)
 800263c:	46c0      	nop			; (mov r8, r8)
 800263e:	46c0      	nop			; (mov r8, r8)

08002640 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
 8002644:	9001      	str	r0, [sp, #4]
 8002646:	1c0a      	adds	r2, r1, #0
 8002648:	466b      	mov	r3, sp
 800264a:	3302      	adds	r3, #2
 800264c:	801a      	strh	r2, [r3, #0]

  if (TIME_IMMEDIATE == timeout) {
 800264e:	466b      	mov	r3, sp
 8002650:	3302      	adds	r3, #2
 8002652:	881b      	ldrh	r3, [r3, #0]
 8002654:	2b00      	cmp	r3, #0
 8002656:	d102      	bne.n	800265e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
 8002658:	2301      	movs	r3, #1
 800265a:	425b      	negs	r3, r3
 800265c:	e00e      	b.n	800267c <chThdEnqueueTimeoutS+0x3c>
  }

  queue_insert(currp, tqp);
 800265e:	4b09      	ldr	r3, [pc, #36]	; (8002684 <chThdEnqueueTimeoutS+0x44>)
 8002660:	699a      	ldr	r2, [r3, #24]
 8002662:	9b01      	ldr	r3, [sp, #4]
 8002664:	1c10      	adds	r0, r2, #0
 8002666:	1c19      	adds	r1, r3, #0
 8002668:	f7ff fd32 	bl	80020d0 <queue_insert.4347>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800266c:	466b      	mov	r3, sp
 800266e:	3302      	adds	r3, #2
 8002670:	881b      	ldrh	r3, [r3, #0]
 8002672:	2004      	movs	r0, #4
 8002674:	1c19      	adds	r1, r3, #0
 8002676:	f7ff fdfb 	bl	8002270 <chSchGoSleepTimeoutS>
 800267a:	1c03      	adds	r3, r0, #0
}
 800267c:	1c18      	adds	r0, r3, #0
 800267e:	b003      	add	sp, #12
 8002680:	bd00      	pop	{pc}
 8002682:	46c0      	nop			; (mov r8, r8)
 8002684:	20000300 	.word	0x20000300
 8002688:	46c0      	nop			; (mov r8, r8)
 800268a:	46c0      	nop			; (mov r8, r8)
 800268c:	46c0      	nop			; (mov r8, r8)
 800268e:	46c0      	nop			; (mov r8, r8)

08002690 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002690:	b500      	push	{lr}
 8002692:	b083      	sub	sp, #12
 8002694:	9001      	str	r0, [sp, #4]
 8002696:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8002698:	9b01      	ldr	r3, [sp, #4]
 800269a:	1c18      	adds	r0, r3, #0
 800269c:	f7ff fed8 	bl	8002450 <queue_notempty.4824.4287>
 80026a0:	1c03      	adds	r3, r0, #0
 80026a2:	2b00      	cmp	r3, #0
 80026a4:	d005      	beq.n	80026b2 <chThdDequeueNextI+0x22>
    chThdDoDequeueNextI(tqp, msg);
 80026a6:	9a01      	ldr	r2, [sp, #4]
 80026a8:	9b00      	ldr	r3, [sp, #0]
 80026aa:	1c10      	adds	r0, r2, #0
 80026ac:	1c19      	adds	r1, r3, #0
 80026ae:	f7ff feef 	bl	8002490 <chThdDoDequeueNextI.4850.4260>
  }
}
 80026b2:	b003      	add	sp, #12
 80026b4:	bd00      	pop	{pc}
 80026b6:	46c0      	nop			; (mov r8, r8)
 80026b8:	46c0      	nop			; (mov r8, r8)
 80026ba:	46c0      	nop			; (mov r8, r8)
 80026bc:	46c0      	nop			; (mov r8, r8)
 80026be:	46c0      	nop			; (mov r8, r8)

080026c0 <queue_init.5370.4099>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80026c0:	b082      	sub	sp, #8
 80026c2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80026c4:	9b01      	ldr	r3, [sp, #4]
 80026c6:	9a01      	ldr	r2, [sp, #4]
 80026c8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80026ca:	9b01      	ldr	r3, [sp, #4]
 80026cc:	9a01      	ldr	r2, [sp, #4]
 80026ce:	605a      	str	r2, [r3, #4]
}
 80026d0:	b002      	add	sp, #8
 80026d2:	4770      	bx	lr
 80026d4:	46c0      	nop			; (mov r8, r8)
 80026d6:	46c0      	nop			; (mov r8, r8)
 80026d8:	46c0      	nop			; (mov r8, r8)
 80026da:	46c0      	nop			; (mov r8, r8)
 80026dc:	46c0      	nop			; (mov r8, r8)
 80026de:	46c0      	nop			; (mov r8, r8)

080026e0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 80026e0:	b500      	push	{lr}
 80026e2:	b083      	sub	sp, #12
 80026e4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 80026e6:	9b01      	ldr	r3, [sp, #4]
 80026e8:	1c18      	adds	r0, r3, #0
 80026ea:	f7ff ffe9 	bl	80026c0 <queue_init.5370.4099>
  mp->m_owner = NULL;
 80026ee:	9b01      	ldr	r3, [sp, #4]
 80026f0:	2200      	movs	r2, #0
 80026f2:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 80026f4:	b003      	add	sp, #12
 80026f6:	bd00      	pop	{pc}
 80026f8:	46c0      	nop			; (mov r8, r8)
 80026fa:	46c0      	nop			; (mov r8, r8)
 80026fc:	46c0      	nop			; (mov r8, r8)
 80026fe:	46c0      	nop			; (mov r8, r8)
 8002700:	656c6469 	.word	0x656c6469
	...

08002710 <ch_debug>:
 8002710:	6e69616d 18401600 08300204 1814100c     main..@...0.....
 8002720:	001d1c00 00000000 00000000 00000000     ................

08002730 <vmt.6507>:
 8002730:	080016e1 08001711 08001741 08001781     ........A.......
 8002740:	080017b1 080017f1 08001821 08001851     ........!...Q...

08002750 <default_config.6942.4464>:
 8002750:	000004b0 00000000 00004000 00000000     .........@......

08002760 <pal_default_config>:
 8002760:	280000a4 00000000 ffffff57 65555501     ...(....W....UUe
 8002770:	0000ffff 00001100 00000000 00000000     ................
 8002780:	00000000 ffffffff 55555555 0000ffff     ........UUUU....
	...
 80027a0:	ffffffff 51555555 0000ffff 00000000     ....UUUQ........
	...
 80027c0:	55555550 0000ffff 00000000 00000000     PUUU............
 80027d0:	08002230 08002252 08002252 08002236     0"..R"..R"..6"..
 80027e0:	0800224a 08002240 08002252 0800224a     J"..@"..R"..J"..
