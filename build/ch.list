
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4821      	ldr	r0, [pc, #132]	; (8000148 <endfiniloop+0x4>)
 80000c4:	f380 8809 	msr	PSP, r0
 80000c8:	2002      	movs	r0, #2
 80000ca:	f380 8814 	msr	CONTROL, r0
 80000ce:	f3bf 8f6f 	isb	sy
 80000d2:	f001 fa1d 	bl	8001510 <__core_init>
 80000d6:	f000 fdc3 	bl	8000c60 <__early_init>
 80000da:	481c      	ldr	r0, [pc, #112]	; (800014c <endfiniloop+0x8>)
 80000dc:	491c      	ldr	r1, [pc, #112]	; (8000150 <endfiniloop+0xc>)
 80000de:	4a1d      	ldr	r2, [pc, #116]	; (8000154 <endfiniloop+0x10>)

080000e0 <msloop>:
 80000e0:	4291      	cmp	r1, r2
 80000e2:	da02      	bge.n	80000ea <endmsloop>
 80000e4:	6008      	str	r0, [r1, #0]
 80000e6:	3104      	adds	r1, #4
 80000e8:	e7fa      	b.n	80000e0 <msloop>

080000ea <endmsloop>:
 80000ea:	491b      	ldr	r1, [pc, #108]	; (8000158 <endfiniloop+0x14>)
 80000ec:	4a16      	ldr	r2, [pc, #88]	; (8000148 <endfiniloop+0x4>)

080000ee <psloop>:
 80000ee:	4291      	cmp	r1, r2
 80000f0:	da02      	bge.n	80000f8 <endpsloop>
 80000f2:	6008      	str	r0, [r1, #0]
 80000f4:	3104      	adds	r1, #4
 80000f6:	e7fa      	b.n	80000ee <psloop>

080000f8 <endpsloop>:
 80000f8:	4918      	ldr	r1, [pc, #96]	; (800015c <endfiniloop+0x18>)
 80000fa:	4a19      	ldr	r2, [pc, #100]	; (8000160 <endfiniloop+0x1c>)
 80000fc:	4b19      	ldr	r3, [pc, #100]	; (8000164 <endfiniloop+0x20>)

080000fe <dloop>:
 80000fe:	429a      	cmp	r2, r3
 8000100:	da04      	bge.n	800010c <enddloop>
 8000102:	6808      	ldr	r0, [r1, #0]
 8000104:	6010      	str	r0, [r2, #0]
 8000106:	3104      	adds	r1, #4
 8000108:	3204      	adds	r2, #4
 800010a:	e7f8      	b.n	80000fe <dloop>

0800010c <enddloop>:
 800010c:	2000      	movs	r0, #0
 800010e:	4916      	ldr	r1, [pc, #88]	; (8000168 <endfiniloop+0x24>)
 8000110:	4a16      	ldr	r2, [pc, #88]	; (800016c <endfiniloop+0x28>)

08000112 <bloop>:
 8000112:	4291      	cmp	r1, r2
 8000114:	da02      	bge.n	800011c <endbloop>
 8000116:	6008      	str	r0, [r1, #0]
 8000118:	3104      	adds	r1, #4
 800011a:	e7fa      	b.n	8000112 <bloop>

0800011c <endbloop>:
 800011c:	f001 fa00 	bl	8001520 <__late_init>
 8000120:	4c13      	ldr	r4, [pc, #76]	; (8000170 <endfiniloop+0x2c>)
 8000122:	4d14      	ldr	r5, [pc, #80]	; (8000174 <endfiniloop+0x30>)

08000124 <initloop>:
 8000124:	42ac      	cmp	r4, r5
 8000126:	da03      	bge.n	8000130 <endinitloop>
 8000128:	6821      	ldr	r1, [r4, #0]
 800012a:	4788      	blx	r1
 800012c:	3404      	adds	r4, #4
 800012e:	e7f9      	b.n	8000124 <initloop>

08000130 <endinitloop>:
 8000130:	f000 fda6 	bl	8000c80 <main>
 8000134:	4c10      	ldr	r4, [pc, #64]	; (8000178 <endfiniloop+0x34>)
 8000136:	4d11      	ldr	r5, [pc, #68]	; (800017c <endfiniloop+0x38>)

08000138 <finiloop>:
 8000138:	42ac      	cmp	r4, r5
 800013a:	da03      	bge.n	8000144 <endfiniloop>
 800013c:	6821      	ldr	r1, [r4, #0]
 800013e:	4788      	blx	r1
 8000140:	3404      	adds	r4, #4
 8000142:	e7f9      	b.n	8000138 <finiloop>

08000144 <endfiniloop>:
 8000144:	490e      	ldr	r1, [pc, #56]	; (8000180 <endfiniloop+0x3c>)
 8000146:	4708      	bx	r1
 8000148:	20000300 	.word	0x20000300
 800014c:	55555555 	.word	0x55555555
 8000150:	20000000 	.word	0x20000000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000200 	.word	0x20000200
 800015c:	080023d0 	.word	0x080023d0
 8000160:	20000300 	.word	0x20000300
 8000164:	20000300 	.word	0x20000300
 8000168:	20000300 	.word	0x20000300
 800016c:	200004cc 	.word	0x200004cc
 8000170:	080000c0 	.word	0x080000c0
 8000174:	080000c0 	.word	0x080000c0
 8000178:	080000c0 	.word	0x080000c0
 800017c:	080000c0 	.word	0x080000c0
 8000180:	08001531 	.word	0x08001531
	...

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	b662      	cpsie	i
 80001b2:	1c28      	adds	r0, r5, #0
 80001b4:	47a0      	blx	r4
 80001b6:	2000      	movs	r0, #0
 80001b8:	f001 fff2 	bl	80021a0 <chThdExit>

080001bc <_port_switch_from_isr>:
 80001bc:	f001 ff10 	bl	8001fe0 <chSchDoReschedule>

080001c0 <_port_exit_from_isr>:
 80001c0:	4a01      	ldr	r2, [pc, #4]	; (80001c8 <_port_exit_from_isr+0x8>)
 80001c2:	4b02      	ldr	r3, [pc, #8]	; (80001cc <_port_exit_from_isr+0xc>)
 80001c4:	6013      	str	r3, [r2, #0]
 80001c6:	e7fe      	b.n	80001c6 <_port_exit_from_isr+0x6>
 80001c8:	e000ed04 	.word	0xe000ed04
 80001cc:	80000000 	.word	0x80000000

080001d0 <osalEventObjectInit.6291.4374>:
static inline void osalEventObjectInit(event_source_t *esp) {

  chEvtObjectInit(esp);
}
#else
static inline void osalEventObjectInit(event_source_t *esp) {
 80001d0:	b082      	sub	sp, #8
 80001d2:	9001      	str	r0, [sp, #4]

  esp->flags = 0;
 80001d4:	9b01      	ldr	r3, [sp, #4]
 80001d6:	2200      	movs	r2, #0
 80001d8:	601a      	str	r2, [r3, #0]
}
 80001da:	b002      	add	sp, #8
 80001dc:	4770      	bx	lr
 80001de:	46c0      	nop			; (mov r8, r8)

080001e0 <osalEventBroadcastFlagsI.6300.4370>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80001e0:	b082      	sub	sp, #8
 80001e2:	9001      	str	r0, [sp, #4]
 80001e4:	9100      	str	r1, [sp, #0]

  esp->flags |= flags;
 80001e6:	9b01      	ldr	r3, [sp, #4]
 80001e8:	681a      	ldr	r2, [r3, #0]
 80001ea:	9b00      	ldr	r3, [sp, #0]
 80001ec:	431a      	orrs	r2, r3
 80001ee:	9b01      	ldr	r3, [sp, #4]
 80001f0:	601a      	str	r2, [r3, #0]
}
 80001f2:	b002      	add	sp, #8
 80001f4:	4770      	bx	lr
 80001f6:	46c0      	nop			; (mov r8, r8)
 80001f8:	46c0      	nop			; (mov r8, r8)
 80001fa:	46c0      	nop			; (mov r8, r8)
 80001fc:	46c0      	nop			; (mov r8, r8)
 80001fe:	46c0      	nop			; (mov r8, r8)

08000200 <write.6304.4365>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8000200:	b500      	push	{lr}
 8000202:	b085      	sub	sp, #20
 8000204:	9003      	str	r0, [sp, #12]
 8000206:	9102      	str	r1, [sp, #8]
 8000208:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800020a:	9b03      	ldr	r3, [sp, #12]
 800020c:	1c18      	adds	r0, r3, #0
 800020e:	3030      	adds	r0, #48	; 0x30
 8000210:	9902      	ldr	r1, [sp, #8]
 8000212:	9a01      	ldr	r2, [sp, #4]
 8000214:	4b03      	ldr	r3, [pc, #12]	; (8000224 <write.6304.4365+0x24>)
 8000216:	f001 f923 	bl	8001460 <oqWriteTimeout>
 800021a:	1c03      	adds	r3, r0, #0
                        n, TIME_INFINITE);
}
 800021c:	1c18      	adds	r0, r3, #0
 800021e:	b005      	add	sp, #20
 8000220:	bd00      	pop	{pc}
 8000222:	46c0      	nop			; (mov r8, r8)
 8000224:	0000ffff 	.word	0x0000ffff
 8000228:	46c0      	nop			; (mov r8, r8)
 800022a:	46c0      	nop			; (mov r8, r8)
 800022c:	46c0      	nop			; (mov r8, r8)
 800022e:	46c0      	nop			; (mov r8, r8)

08000230 <read.6321.4360>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8000230:	b500      	push	{lr}
 8000232:	b085      	sub	sp, #20
 8000234:	9003      	str	r0, [sp, #12]
 8000236:	9102      	str	r1, [sp, #8]
 8000238:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800023a:	9b03      	ldr	r3, [sp, #12]
 800023c:	1c18      	adds	r0, r3, #0
 800023e:	300c      	adds	r0, #12
 8000240:	9902      	ldr	r1, [sp, #8]
 8000242:	9a01      	ldr	r2, [sp, #4]
 8000244:	4b03      	ldr	r3, [pc, #12]	; (8000254 <read.6321.4360+0x24>)
 8000246:	f001 f803 	bl	8001250 <iqReadTimeout>
 800024a:	1c03      	adds	r3, r0, #0
                       n, TIME_INFINITE);
}
 800024c:	1c18      	adds	r0, r3, #0
 800024e:	b005      	add	sp, #20
 8000250:	bd00      	pop	{pc}
 8000252:	46c0      	nop			; (mov r8, r8)
 8000254:	0000ffff 	.word	0x0000ffff
 8000258:	46c0      	nop			; (mov r8, r8)
 800025a:	46c0      	nop			; (mov r8, r8)
 800025c:	46c0      	nop			; (mov r8, r8)
 800025e:	46c0      	nop			; (mov r8, r8)

08000260 <put.6332.4356>:

static msg_t put(void *ip, uint8_t b) {
 8000260:	b500      	push	{lr}
 8000262:	b083      	sub	sp, #12
 8000264:	9001      	str	r0, [sp, #4]
 8000266:	1c0a      	adds	r2, r1, #0
 8000268:	466b      	mov	r3, sp
 800026a:	3303      	adds	r3, #3
 800026c:	701a      	strb	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800026e:	9b01      	ldr	r3, [sp, #4]
 8000270:	1c19      	adds	r1, r3, #0
 8000272:	3130      	adds	r1, #48	; 0x30
 8000274:	466b      	mov	r3, sp
 8000276:	3303      	adds	r3, #3
 8000278:	781a      	ldrb	r2, [r3, #0]
 800027a:	4b05      	ldr	r3, [pc, #20]	; (8000290 <put.6332.4356+0x30>)
 800027c:	1c08      	adds	r0, r1, #0
 800027e:	1c11      	adds	r1, r2, #0
 8000280:	1c1a      	adds	r2, r3, #0
 8000282:	f001 f865 	bl	8001350 <oqPutTimeout>
 8000286:	1c03      	adds	r3, r0, #0
}
 8000288:	1c18      	adds	r0, r3, #0
 800028a:	b003      	add	sp, #12
 800028c:	bd00      	pop	{pc}
 800028e:	46c0      	nop			; (mov r8, r8)
 8000290:	0000ffff 	.word	0x0000ffff
 8000294:	46c0      	nop			; (mov r8, r8)
 8000296:	46c0      	nop			; (mov r8, r8)
 8000298:	46c0      	nop			; (mov r8, r8)
 800029a:	46c0      	nop			; (mov r8, r8)
 800029c:	46c0      	nop			; (mov r8, r8)
 800029e:	46c0      	nop			; (mov r8, r8)

080002a0 <get.6344.4353>:

static msg_t get(void *ip) {
 80002a0:	b500      	push	{lr}
 80002a2:	b083      	sub	sp, #12
 80002a4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80002a6:	9b01      	ldr	r3, [sp, #4]
 80002a8:	1c1a      	adds	r2, r3, #0
 80002aa:	320c      	adds	r2, #12
 80002ac:	4b04      	ldr	r3, [pc, #16]	; (80002c0 <get.6344.4353+0x20>)
 80002ae:	1c10      	adds	r0, r2, #0
 80002b0:	1c19      	adds	r1, r3, #0
 80002b2:	f000 ff85 	bl	80011c0 <iqGetTimeout>
 80002b6:	1c03      	adds	r3, r0, #0
}
 80002b8:	1c18      	adds	r0, r3, #0
 80002ba:	b003      	add	sp, #12
 80002bc:	bd00      	pop	{pc}
 80002be:	46c0      	nop			; (mov r8, r8)
 80002c0:	0000ffff 	.word	0x0000ffff
 80002c4:	46c0      	nop			; (mov r8, r8)
 80002c6:	46c0      	nop			; (mov r8, r8)
 80002c8:	46c0      	nop			; (mov r8, r8)
 80002ca:	46c0      	nop			; (mov r8, r8)
 80002cc:	46c0      	nop			; (mov r8, r8)
 80002ce:	46c0      	nop			; (mov r8, r8)

080002d0 <putt.6339.4348>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80002d0:	b500      	push	{lr}
 80002d2:	b083      	sub	sp, #12
 80002d4:	9001      	str	r0, [sp, #4]
 80002d6:	466b      	mov	r3, sp
 80002d8:	3303      	adds	r3, #3
 80002da:	7019      	strb	r1, [r3, #0]
 80002dc:	466b      	mov	r3, sp
 80002de:	801a      	strh	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80002e0:	9b01      	ldr	r3, [sp, #4]
 80002e2:	1c19      	adds	r1, r3, #0
 80002e4:	3130      	adds	r1, #48	; 0x30
 80002e6:	466b      	mov	r3, sp
 80002e8:	3303      	adds	r3, #3
 80002ea:	781a      	ldrb	r2, [r3, #0]
 80002ec:	466b      	mov	r3, sp
 80002ee:	881b      	ldrh	r3, [r3, #0]
 80002f0:	1c08      	adds	r0, r1, #0
 80002f2:	1c11      	adds	r1, r2, #0
 80002f4:	1c1a      	adds	r2, r3, #0
 80002f6:	f001 f82b 	bl	8001350 <oqPutTimeout>
 80002fa:	1c03      	adds	r3, r0, #0
}
 80002fc:	1c18      	adds	r0, r3, #0
 80002fe:	b003      	add	sp, #12
 8000300:	bd00      	pop	{pc}
 8000302:	46c0      	nop			; (mov r8, r8)
 8000304:	46c0      	nop			; (mov r8, r8)
 8000306:	46c0      	nop			; (mov r8, r8)
 8000308:	46c0      	nop			; (mov r8, r8)
 800030a:	46c0      	nop			; (mov r8, r8)
 800030c:	46c0      	nop			; (mov r8, r8)
 800030e:	46c0      	nop			; (mov r8, r8)

08000310 <gett.6347.4344>:

static msg_t gett(void *ip, systime_t timeout) {
 8000310:	b500      	push	{lr}
 8000312:	b083      	sub	sp, #12
 8000314:	9001      	str	r0, [sp, #4]
 8000316:	1c0a      	adds	r2, r1, #0
 8000318:	466b      	mov	r3, sp
 800031a:	3302      	adds	r3, #2
 800031c:	801a      	strh	r2, [r3, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 800031e:	9b01      	ldr	r3, [sp, #4]
 8000320:	1c1a      	adds	r2, r3, #0
 8000322:	320c      	adds	r2, #12
 8000324:	466b      	mov	r3, sp
 8000326:	3302      	adds	r3, #2
 8000328:	881b      	ldrh	r3, [r3, #0]
 800032a:	1c10      	adds	r0, r2, #0
 800032c:	1c19      	adds	r1, r3, #0
 800032e:	f000 ff47 	bl	80011c0 <iqGetTimeout>
 8000332:	1c03      	adds	r3, r0, #0
}
 8000334:	1c18      	adds	r0, r3, #0
 8000336:	b003      	add	sp, #12
 8000338:	bd00      	pop	{pc}
 800033a:	46c0      	nop			; (mov r8, r8)
 800033c:	46c0      	nop			; (mov r8, r8)
 800033e:	46c0      	nop			; (mov r8, r8)

08000340 <writet.6312.4338>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8000340:	b500      	push	{lr}
 8000342:	b085      	sub	sp, #20
 8000344:	9003      	str	r0, [sp, #12]
 8000346:	9102      	str	r1, [sp, #8]
 8000348:	9201      	str	r2, [sp, #4]
 800034a:	1c1a      	adds	r2, r3, #0
 800034c:	466b      	mov	r3, sp
 800034e:	3302      	adds	r3, #2
 8000350:	801a      	strh	r2, [r3, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000352:	9b03      	ldr	r3, [sp, #12]
 8000354:	1c18      	adds	r0, r3, #0
 8000356:	3030      	adds	r0, #48	; 0x30
 8000358:	9902      	ldr	r1, [sp, #8]
 800035a:	9a01      	ldr	r2, [sp, #4]
 800035c:	466b      	mov	r3, sp
 800035e:	3302      	adds	r3, #2
 8000360:	881b      	ldrh	r3, [r3, #0]
 8000362:	f001 f87d 	bl	8001460 <oqWriteTimeout>
 8000366:	1c03      	adds	r3, r0, #0
}
 8000368:	1c18      	adds	r0, r3, #0
 800036a:	b005      	add	sp, #20
 800036c:	bd00      	pop	{pc}
 800036e:	46c0      	nop			; (mov r8, r8)

08000370 <readt.6326.4332>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8000370:	b500      	push	{lr}
 8000372:	b085      	sub	sp, #20
 8000374:	9003      	str	r0, [sp, #12]
 8000376:	9102      	str	r1, [sp, #8]
 8000378:	9201      	str	r2, [sp, #4]
 800037a:	1c1a      	adds	r2, r3, #0
 800037c:	466b      	mov	r3, sp
 800037e:	3302      	adds	r3, #2
 8000380:	801a      	strh	r2, [r3, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000382:	9b03      	ldr	r3, [sp, #12]
 8000384:	1c18      	adds	r0, r3, #0
 8000386:	300c      	adds	r0, #12
 8000388:	9902      	ldr	r1, [sp, #8]
 800038a:	9a01      	ldr	r2, [sp, #4]
 800038c:	466b      	mov	r3, sp
 800038e:	3302      	adds	r3, #2
 8000390:	881b      	ldrh	r3, [r3, #0]
 8000392:	f000 ff5d 	bl	8001250 <iqReadTimeout>
 8000396:	1c03      	adds	r3, r0, #0
}
 8000398:	1c18      	adds	r0, r3, #0
 800039a:	b005      	add	sp, #20
 800039c:	bd00      	pop	{pc}
 800039e:	46c0      	nop			; (mov r8, r8)

080003a0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80003a0:	b508      	push	{r3, lr}

  sd_lld_init();
 80003a2:	f000 fc3d 	bl	8000c20 <sd_lld_init.4165>
}
 80003a6:	bd08      	pop	{r3, pc}
 80003a8:	46c0      	nop			; (mov r8, r8)
 80003aa:	46c0      	nop			; (mov r8, r8)
 80003ac:	46c0      	nop			; (mov r8, r8)
 80003ae:	46c0      	nop			; (mov r8, r8)

080003b0 <sdObjectInit.4325>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80003b0:	b500      	push	{lr}
 80003b2:	b087      	sub	sp, #28
 80003b4:	9005      	str	r0, [sp, #20]
 80003b6:	9104      	str	r1, [sp, #16]
 80003b8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 80003ba:	9b05      	ldr	r3, [sp, #20]
 80003bc:	4a13      	ldr	r2, [pc, #76]	; (800040c <sdObjectInit.4325+0x5c>)
 80003be:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80003c0:	9b05      	ldr	r3, [sp, #20]
 80003c2:	3304      	adds	r3, #4
 80003c4:	1c18      	adds	r0, r3, #0
 80003c6:	f7ff ff03 	bl	80001d0 <osalEventObjectInit.6291.4374>
  sdp->state = SD_STOP;
 80003ca:	9b05      	ldr	r3, [sp, #20]
 80003cc:	2201      	movs	r2, #1
 80003ce:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80003d0:	9b05      	ldr	r3, [sp, #20]
 80003d2:	1c19      	adds	r1, r3, #0
 80003d4:	310c      	adds	r1, #12
 80003d6:	9b05      	ldr	r3, [sp, #20]
 80003d8:	1c1a      	adds	r2, r3, #0
 80003da:	3254      	adds	r2, #84	; 0x54
 80003dc:	9b04      	ldr	r3, [sp, #16]
 80003de:	9805      	ldr	r0, [sp, #20]
 80003e0:	9000      	str	r0, [sp, #0]
 80003e2:	1c08      	adds	r0, r1, #0
 80003e4:	1c11      	adds	r1, r2, #0
 80003e6:	2210      	movs	r2, #16
 80003e8:	f000 fe82 	bl	80010f0 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80003ec:	9b05      	ldr	r3, [sp, #20]
 80003ee:	1c19      	adds	r1, r3, #0
 80003f0:	3130      	adds	r1, #48	; 0x30
 80003f2:	9b05      	ldr	r3, [sp, #20]
 80003f4:	1c1a      	adds	r2, r3, #0
 80003f6:	3264      	adds	r2, #100	; 0x64
 80003f8:	9b03      	ldr	r3, [sp, #12]
 80003fa:	9805      	ldr	r0, [sp, #20]
 80003fc:	9000      	str	r0, [sp, #0]
 80003fe:	1c08      	adds	r0, r1, #0
 8000400:	1c11      	adds	r1, r2, #0
 8000402:	2210      	movs	r2, #16
 8000404:	f000 ff7c 	bl	8001300 <oqObjectInit>
}
 8000408:	b007      	add	sp, #28
 800040a:	bd00      	pop	{pc}
 800040c:	08002320 	.word	0x08002320

08000410 <sdIncomingDataI.4314>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000410:	b500      	push	{lr}
 8000412:	b083      	sub	sp, #12
 8000414:	9001      	str	r0, [sp, #4]
 8000416:	1c0a      	adds	r2, r1, #0
 8000418:	466b      	mov	r3, sp
 800041a:	3303      	adds	r3, #3
 800041c:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800041e:	9b01      	ldr	r3, [sp, #4]
 8000420:	695b      	ldr	r3, [r3, #20]
 8000422:	2b00      	cmp	r3, #0
 8000424:	d105      	bne.n	8000432 <sdIncomingDataI.4314+0x22>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8000426:	9b01      	ldr	r3, [sp, #4]
 8000428:	3304      	adds	r3, #4
 800042a:	1c18      	adds	r0, r3, #0
 800042c:	2104      	movs	r1, #4
 800042e:	f7ff fed7 	bl	80001e0 <osalEventBroadcastFlagsI.6300.4370>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8000432:	9b01      	ldr	r3, [sp, #4]
 8000434:	1c1a      	adds	r2, r3, #0
 8000436:	320c      	adds	r2, #12
 8000438:	466b      	mov	r3, sp
 800043a:	3303      	adds	r3, #3
 800043c:	781b      	ldrb	r3, [r3, #0]
 800043e:	1c10      	adds	r0, r2, #0
 8000440:	1c19      	adds	r1, r3, #0
 8000442:	f000 fe7d 	bl	8001140 <iqPutI>
 8000446:	1c03      	adds	r3, r0, #0
 8000448:	2b00      	cmp	r3, #0
 800044a:	da05      	bge.n	8000458 <sdIncomingDataI.4314+0x48>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 800044c:	9b01      	ldr	r3, [sp, #4]
 800044e:	3304      	adds	r3, #4
 8000450:	1c18      	adds	r0, r3, #0
 8000452:	2180      	movs	r1, #128	; 0x80
 8000454:	f7ff fec4 	bl	80001e0 <osalEventBroadcastFlagsI.6300.4370>
}
 8000458:	b003      	add	sp, #12
 800045a:	bd00      	pop	{pc}
 800045c:	46c0      	nop			; (mov r8, r8)
 800045e:	46c0      	nop			; (mov r8, r8)

08000460 <nvicEnableVector.4300>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000460:	b530      	push	{r4, r5, lr}
 8000462:	b083      	sub	sp, #12
 8000464:	9001      	str	r0, [sp, #4]
 8000466:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000468:	4b1d      	ldr	r3, [pc, #116]	; (80004e0 <nvicEnableVector.4300+0x80>)
 800046a:	9a01      	ldr	r2, [sp, #4]
 800046c:	0892      	lsrs	r2, r2, #2
 800046e:	491c      	ldr	r1, [pc, #112]	; (80004e0 <nvicEnableVector.4300+0x80>)
 8000470:	9801      	ldr	r0, [sp, #4]
 8000472:	0880      	lsrs	r0, r0, #2
 8000474:	30c0      	adds	r0, #192	; 0xc0
 8000476:	0080      	lsls	r0, r0, #2
 8000478:	5841      	ldr	r1, [r0, r1]
 800047a:	9c01      	ldr	r4, [sp, #4]
 800047c:	2003      	movs	r0, #3
 800047e:	4020      	ands	r0, r4
 8000480:	00c0      	lsls	r0, r0, #3
 8000482:	24ff      	movs	r4, #255	; 0xff
 8000484:	1c25      	adds	r5, r4, #0
 8000486:	4085      	lsls	r5, r0
 8000488:	1c28      	adds	r0, r5, #0
 800048a:	43c0      	mvns	r0, r0
 800048c:	4008      	ands	r0, r1
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 800048e:	9900      	ldr	r1, [sp, #0]
 8000490:	018c      	lsls	r4, r1, #6
 8000492:	9d01      	ldr	r5, [sp, #4]
 8000494:	2103      	movs	r1, #3
 8000496:	4029      	ands	r1, r5
 8000498:	00c9      	lsls	r1, r1, #3
 800049a:	1c25      	adds	r5, r4, #0
 800049c:	408d      	lsls	r5, r1
 800049e:	1c29      	adds	r1, r5, #0
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80004a0:	4301      	orrs	r1, r0
 80004a2:	32c0      	adds	r2, #192	; 0xc0
 80004a4:	0092      	lsls	r2, r2, #2
 80004a6:	50d1      	str	r1, [r2, r3]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80004a8:	4b0d      	ldr	r3, [pc, #52]	; (80004e0 <nvicEnableVector.4300+0x80>)
 80004aa:	9a01      	ldr	r2, [sp, #4]
 80004ac:	0952      	lsrs	r2, r2, #5
 80004ae:	9801      	ldr	r0, [sp, #4]
 80004b0:	211f      	movs	r1, #31
 80004b2:	4001      	ands	r1, r0
 80004b4:	2001      	movs	r0, #1
 80004b6:	1c04      	adds	r4, r0, #0
 80004b8:	408c      	lsls	r4, r1
 80004ba:	1c21      	adds	r1, r4, #0
 80004bc:	3260      	adds	r2, #96	; 0x60
 80004be:	0092      	lsls	r2, r2, #2
 80004c0:	50d1      	str	r1, [r2, r3]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80004c2:	4b07      	ldr	r3, [pc, #28]	; (80004e0 <nvicEnableVector.4300+0x80>)
 80004c4:	9a01      	ldr	r2, [sp, #4]
 80004c6:	0952      	lsrs	r2, r2, #5
 80004c8:	9801      	ldr	r0, [sp, #4]
 80004ca:	211f      	movs	r1, #31
 80004cc:	4001      	ands	r1, r0
 80004ce:	2001      	movs	r0, #1
 80004d0:	1c05      	adds	r5, r0, #0
 80004d2:	408d      	lsls	r5, r1
 80004d4:	1c29      	adds	r1, r5, #0
 80004d6:	0092      	lsls	r2, r2, #2
 80004d8:	50d1      	str	r1, [r2, r3]
}
 80004da:	b003      	add	sp, #12
 80004dc:	bd30      	pop	{r4, r5, pc}
 80004de:	46c0      	nop			; (mov r8, r8)
 80004e0:	e000e100 	.word	0xe000e100
 80004e4:	46c0      	nop			; (mov r8, r8)
 80004e6:	46c0      	nop			; (mov r8, r8)
 80004e8:	46c0      	nop			; (mov r8, r8)
 80004ea:	46c0      	nop			; (mov r8, r8)
 80004ec:	46c0      	nop			; (mov r8, r8)
 80004ee:	46c0      	nop			; (mov r8, r8)

080004f0 <hal_lld_backup_domain_init.6570.4287>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80004f0:	4b15      	ldr	r3, [pc, #84]	; (8000548 <hal_lld_backup_domain_init.6570.4287+0x58>)
 80004f2:	4a15      	ldr	r2, [pc, #84]	; (8000548 <hal_lld_backup_domain_init.6570.4287+0x58>)
 80004f4:	6812      	ldr	r2, [r2, #0]
 80004f6:	2180      	movs	r1, #128	; 0x80
 80004f8:	0049      	lsls	r1, r1, #1
 80004fa:	430a      	orrs	r2, r1
 80004fc:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80004fe:	4b13      	ldr	r3, [pc, #76]	; (800054c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 8000500:	6a1a      	ldr	r2, [r3, #32]
 8000502:	23c0      	movs	r3, #192	; 0xc0
 8000504:	009b      	lsls	r3, r3, #2
 8000506:	401a      	ands	r2, r3
 8000508:	2380      	movs	r3, #128	; 0x80
 800050a:	009b      	lsls	r3, r3, #2
 800050c:	429a      	cmp	r2, r3
 800050e:	d006      	beq.n	800051e <hal_lld_backup_domain_init.6570.4287+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000510:	4b0e      	ldr	r3, [pc, #56]	; (800054c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 8000512:	2280      	movs	r2, #128	; 0x80
 8000514:	0252      	lsls	r2, r2, #9
 8000516:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8000518:	4b0c      	ldr	r3, [pc, #48]	; (800054c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 800051a:	2200      	movs	r2, #0
 800051c:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800051e:	4b0b      	ldr	r3, [pc, #44]	; (800054c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 8000520:	6a1a      	ldr	r2, [r3, #32]
 8000522:	2380      	movs	r3, #128	; 0x80
 8000524:	021b      	lsls	r3, r3, #8
 8000526:	4013      	ands	r3, r2
 8000528:	d10d      	bne.n	8000546 <hal_lld_backup_domain_init.6570.4287+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 800052a:	4b08      	ldr	r3, [pc, #32]	; (800054c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 800052c:	4a07      	ldr	r2, [pc, #28]	; (800054c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 800052e:	6a12      	ldr	r2, [r2, #32]
 8000530:	2180      	movs	r1, #128	; 0x80
 8000532:	0089      	lsls	r1, r1, #2
 8000534:	430a      	orrs	r2, r1
 8000536:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000538:	4b04      	ldr	r3, [pc, #16]	; (800054c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 800053a:	4a04      	ldr	r2, [pc, #16]	; (800054c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 800053c:	6a12      	ldr	r2, [r2, #32]
 800053e:	2180      	movs	r1, #128	; 0x80
 8000540:	0209      	lsls	r1, r1, #8
 8000542:	430a      	orrs	r2, r1
 8000544:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 8000546:	4770      	bx	lr
 8000548:	40007000 	.word	0x40007000
 800054c:	40021000 	.word	0x40021000

08000550 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8000550:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000552:	4b12      	ldr	r3, [pc, #72]	; (800059c <hal_lld_init+0x4c>)
 8000554:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000556:	4b11      	ldr	r3, [pc, #68]	; (800059c <hal_lld_init+0x4c>)
 8000558:	2201      	movs	r2, #1
 800055a:	4252      	negs	r2, r2
 800055c:	629a      	str	r2, [r3, #40]	; 0x28
 800055e:	4b0f      	ldr	r3, [pc, #60]	; (800059c <hal_lld_init+0x4c>)
 8000560:	2200      	movs	r2, #0
 8000562:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000564:	4b0d      	ldr	r3, [pc, #52]	; (800059c <hal_lld_init+0x4c>)
 8000566:	691b      	ldr	r3, [r3, #16]
 8000568:	4b0c      	ldr	r3, [pc, #48]	; (800059c <hal_lld_init+0x4c>)
 800056a:	2201      	movs	r2, #1
 800056c:	4252      	negs	r2, r2
 800056e:	611a      	str	r2, [r3, #16]
 8000570:	4b0a      	ldr	r3, [pc, #40]	; (800059c <hal_lld_init+0x4c>)
 8000572:	2200      	movs	r2, #0
 8000574:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000576:	4b09      	ldr	r3, [pc, #36]	; (800059c <hal_lld_init+0x4c>)
 8000578:	4a08      	ldr	r2, [pc, #32]	; (800059c <hal_lld_init+0x4c>)
 800057a:	68d2      	ldr	r2, [r2, #12]
 800057c:	4908      	ldr	r1, [pc, #32]	; (80005a0 <hal_lld_init+0x50>)
 800057e:	430a      	orrs	r2, r1
 8000580:	60da      	str	r2, [r3, #12]
 8000582:	4b06      	ldr	r3, [pc, #24]	; (800059c <hal_lld_init+0x4c>)
 8000584:	2200      	movs	r2, #0
 8000586:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000588:	4b04      	ldr	r3, [pc, #16]	; (800059c <hal_lld_init+0x4c>)
 800058a:	4a04      	ldr	r2, [pc, #16]	; (800059c <hal_lld_init+0x4c>)
 800058c:	69d2      	ldr	r2, [r2, #28]
 800058e:	2180      	movs	r1, #128	; 0x80
 8000590:	0549      	lsls	r1, r1, #21
 8000592:	430a      	orrs	r2, r1
 8000594:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8000596:	f7ff ffab 	bl	80004f0 <hal_lld_backup_domain_init.6570.4287>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800059a:	bd08      	pop	{r3, pc}
 800059c:	40021000 	.word	0x40021000
 80005a0:	ffbfffff 	.word	0xffbfffff
 80005a4:	46c0      	nop			; (mov r8, r8)
 80005a6:	46c0      	nop			; (mov r8, r8)
 80005a8:	46c0      	nop			; (mov r8, r8)
 80005aa:	46c0      	nop			; (mov r8, r8)
 80005ac:	46c0      	nop			; (mov r8, r8)
 80005ae:	46c0      	nop			; (mov r8, r8)

080005b0 <stm32_clock_init.4282>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80005b0:	4b32      	ldr	r3, [pc, #200]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005b2:	4a32      	ldr	r2, [pc, #200]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005b4:	6812      	ldr	r2, [r2, #0]
 80005b6:	2101      	movs	r1, #1
 80005b8:	430a      	orrs	r2, r1
 80005ba:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80005bc:	4b2f      	ldr	r3, [pc, #188]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005be:	681a      	ldr	r2, [r3, #0]
 80005c0:	2302      	movs	r3, #2
 80005c2:	4013      	ands	r3, r2
 80005c4:	d0fa      	beq.n	80005bc <stm32_clock_init.4282+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80005c6:	4b2d      	ldr	r3, [pc, #180]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005c8:	4a2c      	ldr	r2, [pc, #176]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005ca:	6852      	ldr	r2, [r2, #4]
 80005cc:	2103      	movs	r1, #3
 80005ce:	438a      	bics	r2, r1
 80005d0:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80005d2:	4b2a      	ldr	r3, [pc, #168]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005d4:	4a29      	ldr	r2, [pc, #164]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005d6:	6852      	ldr	r2, [r2, #4]
 80005d8:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80005da:	4b28      	ldr	r3, [pc, #160]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005dc:	685a      	ldr	r2, [r3, #4]
 80005de:	230c      	movs	r3, #12
 80005e0:	4013      	ands	r3, r2
 80005e2:	d1fa      	bne.n	80005da <stm32_clock_init.4282+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80005e4:	4b25      	ldr	r3, [pc, #148]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005e6:	4a25      	ldr	r2, [pc, #148]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005e8:	6811      	ldr	r1, [r2, #0]
 80005ea:	22f9      	movs	r2, #249	; 0xf9
 80005ec:	400a      	ands	r2, r1
 80005ee:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80005f0:	4b22      	ldr	r3, [pc, #136]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005f2:	2200      	movs	r2, #0
 80005f4:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 80005f6:	4b21      	ldr	r3, [pc, #132]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005f8:	4a20      	ldr	r2, [pc, #128]	; (800067c <stm32_clock_init.4282+0xcc>)
 80005fa:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80005fc:	2101      	movs	r1, #1
 80005fe:	430a      	orrs	r2, r1
 8000600:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8000602:	4b1e      	ldr	r3, [pc, #120]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000604:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000606:	2302      	movs	r3, #2
 8000608:	4013      	ands	r3, r2
 800060a:	d0fa      	beq.n	8000602 <stm32_clock_init.4282+0x52>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800060c:	4b1b      	ldr	r3, [pc, #108]	; (800067c <stm32_clock_init.4282+0xcc>)
 800060e:	4a1b      	ldr	r2, [pc, #108]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000610:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000612:	2101      	movs	r1, #1
 8000614:	430a      	orrs	r2, r1
 8000616:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000618:	4b18      	ldr	r3, [pc, #96]	; (800067c <stm32_clock_init.4282+0xcc>)
 800061a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800061c:	2302      	movs	r3, #2
 800061e:	4013      	ands	r3, r2
 8000620:	d0fa      	beq.n	8000618 <stm32_clock_init.4282+0x68>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8000622:	4b16      	ldr	r3, [pc, #88]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000624:	22a0      	movs	r2, #160	; 0xa0
 8000626:	0392      	lsls	r2, r2, #14
 8000628:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 800062a:	4b14      	ldr	r3, [pc, #80]	; (800067c <stm32_clock_init.4282+0xcc>)
 800062c:	2200      	movs	r2, #0
 800062e:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8000630:	4b12      	ldr	r3, [pc, #72]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000632:	2200      	movs	r2, #0
 8000634:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000636:	4b11      	ldr	r3, [pc, #68]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000638:	4a10      	ldr	r2, [pc, #64]	; (800067c <stm32_clock_init.4282+0xcc>)
 800063a:	6812      	ldr	r2, [r2, #0]
 800063c:	2180      	movs	r1, #128	; 0x80
 800063e:	0449      	lsls	r1, r1, #17
 8000640:	430a      	orrs	r2, r1
 8000642:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000644:	4b0d      	ldr	r3, [pc, #52]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000646:	681a      	ldr	r2, [r3, #0]
 8000648:	2380      	movs	r3, #128	; 0x80
 800064a:	049b      	lsls	r3, r3, #18
 800064c:	4013      	ands	r3, r2
 800064e:	d0f9      	beq.n	8000644 <stm32_clock_init.4282+0x94>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000650:	4b0b      	ldr	r3, [pc, #44]	; (8000680 <stm32_clock_init.4282+0xd0>)
 8000652:	2211      	movs	r2, #17
 8000654:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8000656:	4b09      	ldr	r3, [pc, #36]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000658:	4a08      	ldr	r2, [pc, #32]	; (800067c <stm32_clock_init.4282+0xcc>)
 800065a:	6852      	ldr	r2, [r2, #4]
 800065c:	2102      	movs	r1, #2
 800065e:	430a      	orrs	r2, r1
 8000660:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000662:	4b06      	ldr	r3, [pc, #24]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000664:	685a      	ldr	r2, [r3, #4]
 8000666:	230c      	movs	r3, #12
 8000668:	4013      	ands	r3, r2
 800066a:	2b08      	cmp	r3, #8
 800066c:	d1f9      	bne.n	8000662 <stm32_clock_init.4282+0xb2>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800066e:	4b03      	ldr	r3, [pc, #12]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000670:	4a02      	ldr	r2, [pc, #8]	; (800067c <stm32_clock_init.4282+0xcc>)
 8000672:	6992      	ldr	r2, [r2, #24]
 8000674:	2101      	movs	r1, #1
 8000676:	430a      	orrs	r2, r1
 8000678:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 800067a:	4770      	bx	lr
 800067c:	40021000 	.word	0x40021000
 8000680:	40022000 	.word	0x40022000
 8000684:	46c0      	nop			; (mov r8, r8)
 8000686:	46c0      	nop			; (mov r8, r8)
 8000688:	46c0      	nop			; (mov r8, r8)
 800068a:	46c0      	nop			; (mov r8, r8)
 800068c:	46c0      	nop			; (mov r8, r8)
 800068e:	46c0      	nop			; (mov r8, r8)

08000690 <port_lock.6611.4280>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000690:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000692:	4770      	bx	lr
 8000694:	46c0      	nop			; (mov r8, r8)
 8000696:	46c0      	nop			; (mov r8, r8)
 8000698:	46c0      	nop			; (mov r8, r8)
 800069a:	46c0      	nop			; (mov r8, r8)
 800069c:	46c0      	nop			; (mov r8, r8)
 800069e:	46c0      	nop			; (mov r8, r8)

080006a0 <port_unlock.6614.4278>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80006a0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80006a2:	4770      	bx	lr
 80006a4:	46c0      	nop			; (mov r8, r8)
 80006a6:	46c0      	nop			; (mov r8, r8)
 80006a8:	46c0      	nop			; (mov r8, r8)
 80006aa:	46c0      	nop			; (mov r8, r8)
 80006ac:	46c0      	nop			; (mov r8, r8)
 80006ae:	46c0      	nop			; (mov r8, r8)

080006b0 <port_lock_from_isr.6616.4276>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80006b0:	b508      	push	{r3, lr}

  port_lock();
 80006b2:	f7ff ffed 	bl	8000690 <port_lock.6611.4280>
}
 80006b6:	bd08      	pop	{r3, pc}
 80006b8:	46c0      	nop			; (mov r8, r8)
 80006ba:	46c0      	nop			; (mov r8, r8)
 80006bc:	46c0      	nop			; (mov r8, r8)
 80006be:	46c0      	nop			; (mov r8, r8)

080006c0 <port_unlock_from_isr.6618.4274>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80006c0:	b508      	push	{r3, lr}

  port_unlock();
 80006c2:	f7ff ffed 	bl	80006a0 <port_unlock.6614.4278>
}
 80006c6:	bd08      	pop	{r3, pc}
 80006c8:	46c0      	nop			; (mov r8, r8)
 80006ca:	46c0      	nop			; (mov r8, r8)
 80006cc:	46c0      	nop			; (mov r8, r8)
 80006ce:	46c0      	nop			; (mov r8, r8)

080006d0 <chSysLockFromISR.6620.4272>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80006d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80006d2:	f7ff ffed 	bl	80006b0 <port_lock_from_isr.6616.4276>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80006d6:	bd08      	pop	{r3, pc}
 80006d8:	46c0      	nop			; (mov r8, r8)
 80006da:	46c0      	nop			; (mov r8, r8)
 80006dc:	46c0      	nop			; (mov r8, r8)
 80006de:	46c0      	nop			; (mov r8, r8)

080006e0 <chSysUnlockFromISR.6622.4270>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80006e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80006e2:	f7ff ffed 	bl	80006c0 <port_unlock_from_isr.6618.4274>
}
 80006e6:	bd08      	pop	{r3, pc}
 80006e8:	46c0      	nop			; (mov r8, r8)
 80006ea:	46c0      	nop			; (mov r8, r8)
 80006ec:	46c0      	nop			; (mov r8, r8)
 80006ee:	46c0      	nop			; (mov r8, r8)

080006f0 <osalSysLockFromISR.6624.4268>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80006f0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80006f2:	f7ff ffed 	bl	80006d0 <chSysLockFromISR.6620.4272>
}
 80006f6:	bd08      	pop	{r3, pc}
 80006f8:	46c0      	nop			; (mov r8, r8)
 80006fa:	46c0      	nop			; (mov r8, r8)
 80006fc:	46c0      	nop			; (mov r8, r8)
 80006fe:	46c0      	nop			; (mov r8, r8)

08000700 <osalSysUnlockFromISR.6626.4266>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000700:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8000702:	f7ff ffed 	bl	80006e0 <chSysUnlockFromISR.6622.4270>
}
 8000706:	bd08      	pop	{r3, pc}
 8000708:	46c0      	nop			; (mov r8, r8)
 800070a:	46c0      	nop			; (mov r8, r8)
 800070c:	46c0      	nop			; (mov r8, r8)
 800070e:	46c0      	nop			; (mov r8, r8)

08000710 <osalOsTimerHandlerI.6628.4264>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8000710:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8000712:	f001 f8e5 	bl	80018e0 <chSysTimerHandlerI>
}
 8000716:	bd08      	pop	{r3, pc}
 8000718:	46c0      	nop			; (mov r8, r8)
 800071a:	46c0      	nop			; (mov r8, r8)
 800071c:	46c0      	nop			; (mov r8, r8)
 800071e:	46c0      	nop			; (mov r8, r8)

08000720 <Vector80.4262>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000720:	b500      	push	{lr}
 8000722:	b083      	sub	sp, #12
 8000724:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000726:	9301      	str	r3, [sp, #4]

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000728:	4b09      	ldr	r3, [pc, #36]	; (8000750 <Vector80.4262+0x30>)
 800072a:	691a      	ldr	r2, [r3, #16]
 800072c:	2302      	movs	r3, #2
 800072e:	4013      	ands	r3, r2
 8000730:	d008      	beq.n	8000744 <Vector80.4262+0x24>
    STM32_ST_TIM->SR = 0U;
 8000732:	4b07      	ldr	r3, [pc, #28]	; (8000750 <Vector80.4262+0x30>)
 8000734:	2200      	movs	r2, #0
 8000736:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8000738:	f7ff ffda 	bl	80006f0 <osalSysLockFromISR.6624.4268>
    osalOsTimerHandlerI();
 800073c:	f7ff ffe8 	bl	8000710 <osalOsTimerHandlerI.6628.4264>
    osalSysUnlockFromISR();
 8000740:	f7ff ffde 	bl	8000700 <osalSysUnlockFromISR.6626.4266>
  }

  OSAL_IRQ_EPILOGUE();
 8000744:	9b01      	ldr	r3, [sp, #4]
 8000746:	1c18      	adds	r0, r3, #0
 8000748:	f000 fb9a 	bl	8000e80 <_port_irq_epilogue>
}
 800074c:	b003      	add	sp, #12
 800074e:	bd00      	pop	{pc}
 8000750:	40000400 	.word	0x40000400
 8000754:	46c0      	nop			; (mov r8, r8)
 8000756:	46c0      	nop			; (mov r8, r8)
 8000758:	46c0      	nop			; (mov r8, r8)
 800075a:	46c0      	nop			; (mov r8, r8)
 800075c:	46c0      	nop			; (mov r8, r8)
 800075e:	46c0      	nop			; (mov r8, r8)

08000760 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8000760:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000762:	4b14      	ldr	r3, [pc, #80]	; (80007b4 <st_lld_init+0x54>)
 8000764:	4a13      	ldr	r2, [pc, #76]	; (80007b4 <st_lld_init+0x54>)
 8000766:	69d2      	ldr	r2, [r2, #28]
 8000768:	2102      	movs	r1, #2
 800076a:	430a      	orrs	r2, r1
 800076c:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800076e:	4b12      	ldr	r3, [pc, #72]	; (80007b8 <st_lld_init+0x58>)
 8000770:	4a11      	ldr	r2, [pc, #68]	; (80007b8 <st_lld_init+0x58>)
 8000772:	6892      	ldr	r2, [r2, #8]
 8000774:	2102      	movs	r1, #2
 8000776:	430a      	orrs	r2, r1
 8000778:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800077a:	4b10      	ldr	r3, [pc, #64]	; (80007bc <st_lld_init+0x5c>)
 800077c:	4a10      	ldr	r2, [pc, #64]	; (80007c0 <st_lld_init+0x60>)
 800077e:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000780:	4b0e      	ldr	r3, [pc, #56]	; (80007bc <st_lld_init+0x5c>)
 8000782:	4a10      	ldr	r2, [pc, #64]	; (80007c4 <st_lld_init+0x64>)
 8000784:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8000786:	4b0d      	ldr	r3, [pc, #52]	; (80007bc <st_lld_init+0x5c>)
 8000788:	2200      	movs	r2, #0
 800078a:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 800078c:	4b0b      	ldr	r3, [pc, #44]	; (80007bc <st_lld_init+0x5c>)
 800078e:	2200      	movs	r2, #0
 8000790:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8000792:	4b0a      	ldr	r3, [pc, #40]	; (80007bc <st_lld_init+0x5c>)
 8000794:	2200      	movs	r2, #0
 8000796:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000798:	4b08      	ldr	r3, [pc, #32]	; (80007bc <st_lld_init+0x5c>)
 800079a:	2200      	movs	r2, #0
 800079c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800079e:	4b07      	ldr	r3, [pc, #28]	; (80007bc <st_lld_init+0x5c>)
 80007a0:	2201      	movs	r2, #1
 80007a2:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80007a4:	4b05      	ldr	r3, [pc, #20]	; (80007bc <st_lld_init+0x5c>)
 80007a6:	2201      	movs	r2, #1
 80007a8:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80007aa:	2010      	movs	r0, #16
 80007ac:	2102      	movs	r1, #2
 80007ae:	f7ff fe57 	bl	8000460 <nvicEnableVector.4300>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80007b2:	bd08      	pop	{r3, pc}
 80007b4:	40021000 	.word	0x40021000
 80007b8:	40015800 	.word	0x40015800
 80007bc:	40000400 	.word	0x40000400
 80007c0:	000012bf 	.word	0x000012bf
 80007c4:	0000ffff 	.word	0x0000ffff
 80007c8:	46c0      	nop			; (mov r8, r8)
 80007ca:	46c0      	nop			; (mov r8, r8)
 80007cc:	46c0      	nop			; (mov r8, r8)
 80007ce:	46c0      	nop			; (mov r8, r8)

080007d0 <initgpio.6689.4254>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 80007d0:	b082      	sub	sp, #8
 80007d2:	9001      	str	r0, [sp, #4]
 80007d4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 80007d6:	9b00      	ldr	r3, [sp, #0]
 80007d8:	685a      	ldr	r2, [r3, #4]
 80007da:	9b01      	ldr	r3, [sp, #4]
 80007dc:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80007de:	9b00      	ldr	r3, [sp, #0]
 80007e0:	689a      	ldr	r2, [r3, #8]
 80007e2:	9b01      	ldr	r3, [sp, #4]
 80007e4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80007e6:	9b00      	ldr	r3, [sp, #0]
 80007e8:	68da      	ldr	r2, [r3, #12]
 80007ea:	9b01      	ldr	r3, [sp, #4]
 80007ec:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80007ee:	9b00      	ldr	r3, [sp, #0]
 80007f0:	691a      	ldr	r2, [r3, #16]
 80007f2:	9b01      	ldr	r3, [sp, #4]
 80007f4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80007f6:	9b00      	ldr	r3, [sp, #0]
 80007f8:	695a      	ldr	r2, [r3, #20]
 80007fa:	9b01      	ldr	r3, [sp, #4]
 80007fc:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80007fe:	9b00      	ldr	r3, [sp, #0]
 8000800:	699a      	ldr	r2, [r3, #24]
 8000802:	9b01      	ldr	r3, [sp, #4]
 8000804:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000806:	9b00      	ldr	r3, [sp, #0]
 8000808:	681a      	ldr	r2, [r3, #0]
 800080a:	9b01      	ldr	r3, [sp, #4]
 800080c:	601a      	str	r2, [r3, #0]
}
 800080e:	b002      	add	sp, #8
 8000810:	4770      	bx	lr
 8000812:	46c0      	nop			; (mov r8, r8)
 8000814:	46c0      	nop			; (mov r8, r8)
 8000816:	46c0      	nop			; (mov r8, r8)
 8000818:	46c0      	nop			; (mov r8, r8)
 800081a:	46c0      	nop			; (mov r8, r8)
 800081c:	46c0      	nop			; (mov r8, r8)
 800081e:	46c0      	nop			; (mov r8, r8)

08000820 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8000820:	b500      	push	{lr}
 8000822:	b083      	sub	sp, #12
 8000824:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000826:	4b12      	ldr	r3, [pc, #72]	; (8000870 <_pal_lld_init+0x50>)
 8000828:	4a11      	ldr	r2, [pc, #68]	; (8000870 <_pal_lld_init+0x50>)
 800082a:	6952      	ldr	r2, [r2, #20]
 800082c:	219c      	movs	r1, #156	; 0x9c
 800082e:	03c9      	lsls	r1, r1, #15
 8000830:	430a      	orrs	r2, r1
 8000832:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8000834:	9b01      	ldr	r3, [sp, #4]
 8000836:	2290      	movs	r2, #144	; 0x90
 8000838:	05d2      	lsls	r2, r2, #23
 800083a:	1c10      	adds	r0, r2, #0
 800083c:	1c19      	adds	r1, r3, #0
 800083e:	f7ff ffc7 	bl	80007d0 <initgpio.6689.4254>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8000842:	9b01      	ldr	r3, [sp, #4]
 8000844:	331c      	adds	r3, #28
 8000846:	4a0b      	ldr	r2, [pc, #44]	; (8000874 <_pal_lld_init+0x54>)
 8000848:	1c10      	adds	r0, r2, #0
 800084a:	1c19      	adds	r1, r3, #0
 800084c:	f7ff ffc0 	bl	80007d0 <initgpio.6689.4254>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8000850:	9b01      	ldr	r3, [sp, #4]
 8000852:	3338      	adds	r3, #56	; 0x38
 8000854:	4a08      	ldr	r2, [pc, #32]	; (8000878 <_pal_lld_init+0x58>)
 8000856:	1c10      	adds	r0, r2, #0
 8000858:	1c19      	adds	r1, r3, #0
 800085a:	f7ff ffb9 	bl	80007d0 <initgpio.6689.4254>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 800085e:	9b01      	ldr	r3, [sp, #4]
 8000860:	3354      	adds	r3, #84	; 0x54
 8000862:	4a06      	ldr	r2, [pc, #24]	; (800087c <_pal_lld_init+0x5c>)
 8000864:	1c10      	adds	r0, r2, #0
 8000866:	1c19      	adds	r1, r3, #0
 8000868:	f7ff ffb2 	bl	80007d0 <initgpio.6689.4254>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 800086c:	b003      	add	sp, #12
 800086e:	bd00      	pop	{pc}
 8000870:	40021000 	.word	0x40021000
 8000874:	48000400 	.word	0x48000400
 8000878:	48000800 	.word	0x48000800
 800087c:	48001400 	.word	0x48001400

08000880 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000880:	b08e      	sub	sp, #56	; 0x38
 8000882:	9003      	str	r0, [sp, #12]
 8000884:	9102      	str	r1, [sp, #8]
 8000886:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000888:	9a01      	ldr	r2, [sp, #4]
 800088a:	2303      	movs	r3, #3
 800088c:	4013      	ands	r3, r2
 800088e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000890:	9a01      	ldr	r2, [sp, #4]
 8000892:	2304      	movs	r3, #4
 8000894:	4013      	ands	r3, r2
 8000896:	089b      	lsrs	r3, r3, #2
 8000898:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800089a:	9a01      	ldr	r2, [sp, #4]
 800089c:	2318      	movs	r3, #24
 800089e:	4013      	ands	r3, r2
 80008a0:	08db      	lsrs	r3, r3, #3
 80008a2:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 80008a4:	9a01      	ldr	r2, [sp, #4]
 80008a6:	2360      	movs	r3, #96	; 0x60
 80008a8:	4013      	ands	r3, r2
 80008aa:	095b      	lsrs	r3, r3, #5
 80008ac:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80008ae:	9a01      	ldr	r2, [sp, #4]
 80008b0:	23f0      	movs	r3, #240	; 0xf0
 80008b2:	00db      	lsls	r3, r3, #3
 80008b4:	4013      	ands	r3, r2
 80008b6:	09db      	lsrs	r3, r3, #7
 80008b8:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 80008ba:	2300      	movs	r3, #0
 80008bc:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 80008be:	9a02      	ldr	r2, [sp, #8]
 80008c0:	2301      	movs	r3, #1
 80008c2:	4013      	ands	r3, r2
 80008c4:	d058      	beq.n	8000978 <_pal_lld_setgroupmode+0xf8>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80008c6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80008c8:	2307      	movs	r3, #7
 80008ca:	4013      	ands	r3, r2
 80008cc:	009b      	lsls	r3, r3, #2
 80008ce:	9a08      	ldr	r2, [sp, #32]
 80008d0:	1c11      	adds	r1, r2, #0
 80008d2:	4099      	lsls	r1, r3
 80008d4:	1c0b      	adds	r3, r1, #0
 80008d6:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
 80008d8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80008da:	2307      	movs	r3, #7
 80008dc:	4013      	ands	r3, r2
 80008de:	009b      	lsls	r3, r3, #2
 80008e0:	220f      	movs	r2, #15
 80008e2:	1c11      	adds	r1, r2, #0
 80008e4:	4099      	lsls	r1, r3
 80008e6:	1c0b      	adds	r3, r1, #0
 80008e8:	9306      	str	r3, [sp, #24]
      if (bit < 8)
 80008ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008ec:	2b07      	cmp	r3, #7
 80008ee:	d809      	bhi.n	8000904 <_pal_lld_setgroupmode+0x84>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 80008f0:	9b03      	ldr	r3, [sp, #12]
 80008f2:	6a1b      	ldr	r3, [r3, #32]
 80008f4:	9a06      	ldr	r2, [sp, #24]
 80008f6:	43d2      	mvns	r2, r2
 80008f8:	401a      	ands	r2, r3
 80008fa:	9b07      	ldr	r3, [sp, #28]
 80008fc:	431a      	orrs	r2, r3
 80008fe:	9b03      	ldr	r3, [sp, #12]
 8000900:	621a      	str	r2, [r3, #32]
 8000902:	e008      	b.n	8000916 <_pal_lld_setgroupmode+0x96>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000904:	9b03      	ldr	r3, [sp, #12]
 8000906:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000908:	9a06      	ldr	r2, [sp, #24]
 800090a:	43d2      	mvns	r2, r2
 800090c:	401a      	ands	r2, r3
 800090e:	9b07      	ldr	r3, [sp, #28]
 8000910:	431a      	orrs	r2, r3
 8000912:	9b03      	ldr	r3, [sp, #12]
 8000914:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
 8000916:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000918:	2201      	movs	r2, #1
 800091a:	1c11      	adds	r1, r2, #0
 800091c:	4099      	lsls	r1, r3
 800091e:	1c0b      	adds	r3, r1, #0
 8000920:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000922:	9b03      	ldr	r3, [sp, #12]
 8000924:	685b      	ldr	r3, [r3, #4]
 8000926:	9a05      	ldr	r2, [sp, #20]
 8000928:	43d2      	mvns	r2, r2
 800092a:	401a      	ands	r2, r3
 800092c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800092e:	431a      	orrs	r2, r3
 8000930:	9b03      	ldr	r3, [sp, #12]
 8000932:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
 8000934:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000936:	005b      	lsls	r3, r3, #1
 8000938:	2203      	movs	r2, #3
 800093a:	1c11      	adds	r1, r2, #0
 800093c:	4099      	lsls	r1, r3
 800093e:	1c0b      	adds	r3, r1, #0
 8000940:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000942:	9b03      	ldr	r3, [sp, #12]
 8000944:	689b      	ldr	r3, [r3, #8]
 8000946:	9a04      	ldr	r2, [sp, #16]
 8000948:	43d2      	mvns	r2, r2
 800094a:	401a      	ands	r2, r3
 800094c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800094e:	431a      	orrs	r2, r3
 8000950:	9b03      	ldr	r3, [sp, #12]
 8000952:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000954:	9b03      	ldr	r3, [sp, #12]
 8000956:	68db      	ldr	r3, [r3, #12]
 8000958:	9a04      	ldr	r2, [sp, #16]
 800095a:	43d2      	mvns	r2, r2
 800095c:	401a      	ands	r2, r3
 800095e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000960:	431a      	orrs	r2, r3
 8000962:	9b03      	ldr	r3, [sp, #12]
 8000964:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 8000966:	9b03      	ldr	r3, [sp, #12]
 8000968:	681b      	ldr	r3, [r3, #0]
 800096a:	9a04      	ldr	r2, [sp, #16]
 800096c:	43d2      	mvns	r2, r2
 800096e:	401a      	ands	r2, r3
 8000970:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8000972:	431a      	orrs	r2, r3
 8000974:	9b03      	ldr	r3, [sp, #12]
 8000976:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
 8000978:	9b02      	ldr	r3, [sp, #8]
 800097a:	085b      	lsrs	r3, r3, #1
 800097c:	9302      	str	r3, [sp, #8]
    if (!mask)
 800097e:	9b02      	ldr	r3, [sp, #8]
 8000980:	2b00      	cmp	r3, #0
 8000982:	d00f      	beq.n	80009a4 <_pal_lld_setgroupmode+0x124>
      return;
    otyper <<= 1;
 8000984:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000986:	005b      	lsls	r3, r3, #1
 8000988:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 800098a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800098c:	009b      	lsls	r3, r3, #2
 800098e:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8000990:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000992:	009b      	lsls	r3, r3, #2
 8000994:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8000996:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8000998:	009b      	lsls	r3, r3, #2
 800099a:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800099c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800099e:	3301      	adds	r3, #1
 80009a0:	9309      	str	r3, [sp, #36]	; 0x24
 80009a2:	e78c      	b.n	80008be <_pal_lld_setgroupmode+0x3e>
  }
}
 80009a4:	b00e      	add	sp, #56	; 0x38
 80009a6:	4770      	bx	lr
 80009a8:	46c0      	nop			; (mov r8, r8)
 80009aa:	46c0      	nop			; (mov r8, r8)
 80009ac:	46c0      	nop			; (mov r8, r8)
 80009ae:	46c0      	nop			; (mov r8, r8)

080009b0 <port_lock.6760.4204>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80009b0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80009b2:	4770      	bx	lr
 80009b4:	46c0      	nop			; (mov r8, r8)
 80009b6:	46c0      	nop			; (mov r8, r8)
 80009b8:	46c0      	nop			; (mov r8, r8)
 80009ba:	46c0      	nop			; (mov r8, r8)
 80009bc:	46c0      	nop			; (mov r8, r8)
 80009be:	46c0      	nop			; (mov r8, r8)

080009c0 <port_unlock.6763.4202>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009c0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80009c2:	4770      	bx	lr
 80009c4:	46c0      	nop			; (mov r8, r8)
 80009c6:	46c0      	nop			; (mov r8, r8)
 80009c8:	46c0      	nop			; (mov r8, r8)
 80009ca:	46c0      	nop			; (mov r8, r8)
 80009cc:	46c0      	nop			; (mov r8, r8)
 80009ce:	46c0      	nop			; (mov r8, r8)

080009d0 <port_lock_from_isr.6765.4200>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80009d0:	b508      	push	{r3, lr}

  port_lock();
 80009d2:	f7ff ffed 	bl	80009b0 <port_lock.6760.4204>
}
 80009d6:	bd08      	pop	{r3, pc}
 80009d8:	46c0      	nop			; (mov r8, r8)
 80009da:	46c0      	nop			; (mov r8, r8)
 80009dc:	46c0      	nop			; (mov r8, r8)
 80009de:	46c0      	nop			; (mov r8, r8)

080009e0 <port_unlock_from_isr.6767.4198>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80009e0:	b508      	push	{r3, lr}

  port_unlock();
 80009e2:	f7ff ffed 	bl	80009c0 <port_unlock.6763.4202>
}
 80009e6:	bd08      	pop	{r3, pc}
 80009e8:	46c0      	nop			; (mov r8, r8)
 80009ea:	46c0      	nop			; (mov r8, r8)
 80009ec:	46c0      	nop			; (mov r8, r8)
 80009ee:	46c0      	nop			; (mov r8, r8)

080009f0 <chSysLockFromISR.6769.4196>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80009f0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80009f2:	f7ff ffed 	bl	80009d0 <port_lock_from_isr.6765.4200>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80009f6:	bd08      	pop	{r3, pc}
 80009f8:	46c0      	nop			; (mov r8, r8)
 80009fa:	46c0      	nop			; (mov r8, r8)
 80009fc:	46c0      	nop			; (mov r8, r8)
 80009fe:	46c0      	nop			; (mov r8, r8)

08000a00 <chSysUnlockFromISR.6771.4194>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000a00:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000a02:	f7ff ffed 	bl	80009e0 <port_unlock_from_isr.6767.4198>
}
 8000a06:	bd08      	pop	{r3, pc}
 8000a08:	46c0      	nop			; (mov r8, r8)
 8000a0a:	46c0      	nop			; (mov r8, r8)
 8000a0c:	46c0      	nop			; (mov r8, r8)
 8000a0e:	46c0      	nop			; (mov r8, r8)

08000a10 <osalSysLockFromISR.6773.4192>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000a10:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8000a12:	f7ff ffed 	bl	80009f0 <chSysLockFromISR.6769.4196>
}
 8000a16:	bd08      	pop	{r3, pc}
 8000a18:	46c0      	nop			; (mov r8, r8)
 8000a1a:	46c0      	nop			; (mov r8, r8)
 8000a1c:	46c0      	nop			; (mov r8, r8)
 8000a1e:	46c0      	nop			; (mov r8, r8)

08000a20 <osalSysUnlockFromISR.6775.4190>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000a20:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8000a22:	f7ff ffed 	bl	8000a00 <chSysUnlockFromISR.6771.4194>
}
 8000a26:	bd08      	pop	{r3, pc}
 8000a28:	46c0      	nop			; (mov r8, r8)
 8000a2a:	46c0      	nop			; (mov r8, r8)
 8000a2c:	46c0      	nop			; (mov r8, r8)
 8000a2e:	46c0      	nop			; (mov r8, r8)

08000a30 <osalEventBroadcastFlagsI.6777.4186>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8000a30:	b082      	sub	sp, #8
 8000a32:	9001      	str	r0, [sp, #4]
 8000a34:	9100      	str	r1, [sp, #0]

  esp->flags |= flags;
 8000a36:	9b01      	ldr	r3, [sp, #4]
 8000a38:	681a      	ldr	r2, [r3, #0]
 8000a3a:	9b00      	ldr	r3, [sp, #0]
 8000a3c:	431a      	orrs	r2, r3
 8000a3e:	9b01      	ldr	r3, [sp, #4]
 8000a40:	601a      	str	r2, [r3, #0]
}
 8000a42:	b002      	add	sp, #8
 8000a44:	4770      	bx	lr
 8000a46:	46c0      	nop			; (mov r8, r8)
 8000a48:	46c0      	nop			; (mov r8, r8)
 8000a4a:	46c0      	nop			; (mov r8, r8)
 8000a4c:	46c0      	nop			; (mov r8, r8)
 8000a4e:	46c0      	nop			; (mov r8, r8)

08000a50 <set_error.6918.4175>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 8000a50:	b500      	push	{lr}
 8000a52:	b085      	sub	sp, #20
 8000a54:	9001      	str	r0, [sp, #4]
 8000a56:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 8000a58:	2300      	movs	r3, #0
 8000a5a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 8000a5c:	9a00      	ldr	r2, [sp, #0]
 8000a5e:	2308      	movs	r3, #8
 8000a60:	4013      	ands	r3, r2
 8000a62:	d003      	beq.n	8000a6c <set_error.6918.4175+0x1c>
    sts |= SD_OVERRUN_ERROR;
 8000a64:	9b03      	ldr	r3, [sp, #12]
 8000a66:	2280      	movs	r2, #128	; 0x80
 8000a68:	4313      	orrs	r3, r2
 8000a6a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 8000a6c:	9a00      	ldr	r2, [sp, #0]
 8000a6e:	2301      	movs	r3, #1
 8000a70:	4013      	ands	r3, r2
 8000a72:	d003      	beq.n	8000a7c <set_error.6918.4175+0x2c>
    sts |= SD_PARITY_ERROR;
 8000a74:	9b03      	ldr	r3, [sp, #12]
 8000a76:	2220      	movs	r2, #32
 8000a78:	4313      	orrs	r3, r2
 8000a7a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 8000a7c:	9a00      	ldr	r2, [sp, #0]
 8000a7e:	2302      	movs	r3, #2
 8000a80:	4013      	ands	r3, r2
 8000a82:	d003      	beq.n	8000a8c <set_error.6918.4175+0x3c>
    sts |= SD_FRAMING_ERROR;
 8000a84:	9b03      	ldr	r3, [sp, #12]
 8000a86:	2240      	movs	r2, #64	; 0x40
 8000a88:	4313      	orrs	r3, r2
 8000a8a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 8000a8c:	9a00      	ldr	r2, [sp, #0]
 8000a8e:	2304      	movs	r3, #4
 8000a90:	4013      	ands	r3, r2
 8000a92:	d004      	beq.n	8000a9e <set_error.6918.4175+0x4e>
    sts |= SD_NOISE_ERROR;
 8000a94:	9b03      	ldr	r3, [sp, #12]
 8000a96:	2280      	movs	r2, #128	; 0x80
 8000a98:	0052      	lsls	r2, r2, #1
 8000a9a:	4313      	orrs	r3, r2
 8000a9c:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 8000a9e:	f7ff ffb7 	bl	8000a10 <osalSysLockFromISR.6773.4192>
  chnAddFlagsI(sdp, sts);
 8000aa2:	9b01      	ldr	r3, [sp, #4]
 8000aa4:	1d1a      	adds	r2, r3, #4
 8000aa6:	9b03      	ldr	r3, [sp, #12]
 8000aa8:	1c10      	adds	r0, r2, #0
 8000aaa:	1c19      	adds	r1, r3, #0
 8000aac:	f7ff ffc0 	bl	8000a30 <osalEventBroadcastFlagsI.6777.4186>
  osalSysUnlockFromISR();
 8000ab0:	f7ff ffb6 	bl	8000a20 <osalSysUnlockFromISR.6775.4190>
}
 8000ab4:	b005      	add	sp, #20
 8000ab6:	bd00      	pop	{pc}
 8000ab8:	46c0      	nop			; (mov r8, r8)
 8000aba:	46c0      	nop			; (mov r8, r8)
 8000abc:	46c0      	nop			; (mov r8, r8)
 8000abe:	46c0      	nop			; (mov r8, r8)

08000ac0 <serve_interrupt.6922.4172>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000ac0:	b500      	push	{lr}
 8000ac2:	b087      	sub	sp, #28
 8000ac4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8000ac6:	9b01      	ldr	r3, [sp, #4]
 8000ac8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8000aca:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 8000acc:	9b05      	ldr	r3, [sp, #20]
 8000ace:	681b      	ldr	r3, [r3, #0]
 8000ad0:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000ad2:	9b05      	ldr	r3, [sp, #20]
 8000ad4:	69db      	ldr	r3, [r3, #28]
 8000ad6:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 8000ad8:	9b05      	ldr	r3, [sp, #20]
 8000ada:	9a03      	ldr	r2, [sp, #12]
 8000adc:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000ade:	9a03      	ldr	r2, [sp, #12]
 8000ae0:	230f      	movs	r3, #15
 8000ae2:	4013      	ands	r3, r2
 8000ae4:	d005      	beq.n	8000af2 <serve_interrupt.6922.4172+0x32>
    set_error(sdp, isr);
 8000ae6:	9a01      	ldr	r2, [sp, #4]
 8000ae8:	9b03      	ldr	r3, [sp, #12]
 8000aea:	1c10      	adds	r0, r2, #0
 8000aec:	1c19      	adds	r1, r3, #0
 8000aee:	f7ff ffaf 	bl	8000a50 <set_error.6918.4175>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000af2:	9a03      	ldr	r2, [sp, #12]
 8000af4:	2380      	movs	r3, #128	; 0x80
 8000af6:	005b      	lsls	r3, r3, #1
 8000af8:	4013      	ands	r3, r2
 8000afa:	d00b      	beq.n	8000b14 <serve_interrupt.6922.4172+0x54>
    osalSysLockFromISR();
 8000afc:	f7ff ff88 	bl	8000a10 <osalSysLockFromISR.6773.4192>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8000b00:	9b01      	ldr	r3, [sp, #4]
 8000b02:	1d1a      	adds	r2, r3, #4
 8000b04:	2380      	movs	r3, #128	; 0x80
 8000b06:	009b      	lsls	r3, r3, #2
 8000b08:	1c10      	adds	r0, r2, #0
 8000b0a:	1c19      	adds	r1, r3, #0
 8000b0c:	f7ff ff90 	bl	8000a30 <osalEventBroadcastFlagsI.6777.4186>
    osalSysUnlockFromISR();
 8000b10:	f7ff ff86 	bl	8000a20 <osalSysUnlockFromISR.6775.4190>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000b14:	9a03      	ldr	r2, [sp, #12]
 8000b16:	2320      	movs	r3, #32
 8000b18:	4013      	ands	r3, r2
 8000b1a:	d00c      	beq.n	8000b36 <serve_interrupt.6922.4172+0x76>
    osalSysLockFromISR();
 8000b1c:	f7ff ff78 	bl	8000a10 <osalSysLockFromISR.6773.4192>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000b20:	9b05      	ldr	r3, [sp, #20]
 8000b22:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000b24:	b29b      	uxth	r3, r3
 8000b26:	b2db      	uxtb	r3, r3
 8000b28:	9a01      	ldr	r2, [sp, #4]
 8000b2a:	1c10      	adds	r0, r2, #0
 8000b2c:	1c19      	adds	r1, r3, #0
 8000b2e:	f7ff fc6f 	bl	8000410 <sdIncomingDataI.4314>
    osalSysUnlockFromISR();
 8000b32:	f7ff ff75 	bl	8000a20 <osalSysUnlockFromISR.6775.4190>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000b36:	9a04      	ldr	r2, [sp, #16]
 8000b38:	2380      	movs	r3, #128	; 0x80
 8000b3a:	4013      	ands	r3, r2
 8000b3c:	d023      	beq.n	8000b86 <serve_interrupt.6922.4172+0xc6>
 8000b3e:	9a03      	ldr	r2, [sp, #12]
 8000b40:	2380      	movs	r3, #128	; 0x80
 8000b42:	4013      	ands	r3, r2
 8000b44:	d01f      	beq.n	8000b86 <serve_interrupt.6922.4172+0xc6>
    msg_t b;
    osalSysLockFromISR();
 8000b46:	f7ff ff63 	bl	8000a10 <osalSysLockFromISR.6773.4192>
    b = oqGetI(&sdp->oqueue);
 8000b4a:	9b01      	ldr	r3, [sp, #4]
 8000b4c:	3330      	adds	r3, #48	; 0x30
 8000b4e:	1c18      	adds	r0, r3, #0
 8000b50:	f000 fc46 	bl	80013e0 <oqGetI>
 8000b54:	1c03      	adds	r3, r0, #0
 8000b56:	9302      	str	r3, [sp, #8]
    if (b < Q_OK) {
 8000b58:	9b02      	ldr	r3, [sp, #8]
 8000b5a:	2b00      	cmp	r3, #0
 8000b5c:	da0d      	bge.n	8000b7a <serve_interrupt.6922.4172+0xba>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000b5e:	9b01      	ldr	r3, [sp, #4]
 8000b60:	3304      	adds	r3, #4
 8000b62:	1c18      	adds	r0, r3, #0
 8000b64:	2108      	movs	r1, #8
 8000b66:	f7ff ff63 	bl	8000a30 <osalEventBroadcastFlagsI.6777.4186>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000b6a:	9b04      	ldr	r3, [sp, #16]
 8000b6c:	22c0      	movs	r2, #192	; 0xc0
 8000b6e:	4393      	bics	r3, r2
 8000b70:	2240      	movs	r2, #64	; 0x40
 8000b72:	431a      	orrs	r2, r3
 8000b74:	9b05      	ldr	r3, [sp, #20]
 8000b76:	601a      	str	r2, [r3, #0]
 8000b78:	e003      	b.n	8000b82 <serve_interrupt.6922.4172+0xc2>
    }
    else
      u->TDR = b;
 8000b7a:	9b02      	ldr	r3, [sp, #8]
 8000b7c:	b29a      	uxth	r2, r3
 8000b7e:	9b05      	ldr	r3, [sp, #20]
 8000b80:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 8000b82:	f7ff ff4d 	bl	8000a20 <osalSysUnlockFromISR.6775.4190>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000b86:	9a03      	ldr	r2, [sp, #12]
 8000b88:	2340      	movs	r3, #64	; 0x40
 8000b8a:	4013      	ands	r3, r2
 8000b8c:	d023      	beq.n	8000bd6 <serve_interrupt.6922.4172+0x116>
    osalSysLockFromISR();
 8000b8e:	f7ff ff3f 	bl	8000a10 <osalSysLockFromISR.6773.4192>
    if (oqIsEmptyI(&sdp->oqueue))
 8000b92:	9b01      	ldr	r3, [sp, #4]
 8000b94:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000b96:	9b01      	ldr	r3, [sp, #4]
 8000b98:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000b9a:	429a      	cmp	r2, r3
 8000b9c:	d105      	bne.n	8000baa <serve_interrupt.6922.4172+0xea>
 8000b9e:	9b01      	ldr	r3, [sp, #4]
 8000ba0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000ba2:	2b00      	cmp	r3, #0
 8000ba4:	d001      	beq.n	8000baa <serve_interrupt.6922.4172+0xea>
 8000ba6:	2301      	movs	r3, #1
 8000ba8:	e000      	b.n	8000bac <serve_interrupt.6922.4172+0xec>
 8000baa:	2300      	movs	r3, #0
 8000bac:	1c1a      	adds	r2, r3, #0
 8000bae:	2301      	movs	r3, #1
 8000bb0:	4013      	ands	r3, r2
 8000bb2:	b2db      	uxtb	r3, r3
 8000bb4:	2b00      	cmp	r3, #0
 8000bb6:	d005      	beq.n	8000bc4 <serve_interrupt.6922.4172+0x104>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000bb8:	9b01      	ldr	r3, [sp, #4]
 8000bba:	3304      	adds	r3, #4
 8000bbc:	1c18      	adds	r0, r3, #0
 8000bbe:	2110      	movs	r1, #16
 8000bc0:	f7ff ff36 	bl	8000a30 <osalEventBroadcastFlagsI.6777.4186>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000bc4:	9b04      	ldr	r3, [sp, #16]
 8000bc6:	2240      	movs	r2, #64	; 0x40
 8000bc8:	1c19      	adds	r1, r3, #0
 8000bca:	4391      	bics	r1, r2
 8000bcc:	1c0a      	adds	r2, r1, #0
 8000bce:	9b05      	ldr	r3, [sp, #20]
 8000bd0:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8000bd2:	f7ff ff25 	bl	8000a20 <osalSysUnlockFromISR.6775.4190>
  }
}
 8000bd6:	b007      	add	sp, #28
 8000bd8:	bd00      	pop	{pc}
 8000bda:	46c0      	nop			; (mov r8, r8)
 8000bdc:	46c0      	nop			; (mov r8, r8)
 8000bde:	46c0      	nop			; (mov r8, r8)

08000be0 <notify1.6787.4167>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 8000be0:	b082      	sub	sp, #8
 8000be2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000be4:	4b03      	ldr	r3, [pc, #12]	; (8000bf4 <notify1.6787.4167+0x14>)
 8000be6:	4a03      	ldr	r2, [pc, #12]	; (8000bf4 <notify1.6787.4167+0x14>)
 8000be8:	6812      	ldr	r2, [r2, #0]
 8000bea:	2180      	movs	r1, #128	; 0x80
 8000bec:	430a      	orrs	r2, r1
 8000bee:	601a      	str	r2, [r3, #0]
}
 8000bf0:	b002      	add	sp, #8
 8000bf2:	4770      	bx	lr
 8000bf4:	40013800 	.word	0x40013800
 8000bf8:	46c0      	nop			; (mov r8, r8)
 8000bfa:	46c0      	nop			; (mov r8, r8)
 8000bfc:	46c0      	nop			; (mov r8, r8)
 8000bfe:	46c0      	nop			; (mov r8, r8)

08000c00 <VectorAC.4170>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000c00:	b500      	push	{lr}
 8000c02:	b083      	sub	sp, #12
 8000c04:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000c06:	9301      	str	r3, [sp, #4]

  serve_interrupt(&SD1);
 8000c08:	4b04      	ldr	r3, [pc, #16]	; (8000c1c <VectorAC.4170+0x1c>)
 8000c0a:	1c18      	adds	r0, r3, #0
 8000c0c:	f7ff ff58 	bl	8000ac0 <serve_interrupt.6922.4172>

  OSAL_IRQ_EPILOGUE();
 8000c10:	9b01      	ldr	r3, [sp, #4]
 8000c12:	1c18      	adds	r0, r3, #0
 8000c14:	f000 f934 	bl	8000e80 <_port_irq_epilogue>
}
 8000c18:	b003      	add	sp, #12
 8000c1a:	bd00      	pop	{pc}
 8000c1c:	20000450 	.word	0x20000450

08000c20 <sd_lld_init.4165>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8000c20:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8000c22:	4a09      	ldr	r2, [pc, #36]	; (8000c48 <sd_lld_init.4165+0x28>)
 8000c24:	4b09      	ldr	r3, [pc, #36]	; (8000c4c <sd_lld_init.4165+0x2c>)
 8000c26:	1c10      	adds	r0, r2, #0
 8000c28:	2100      	movs	r1, #0
 8000c2a:	1c1a      	adds	r2, r3, #0
 8000c2c:	f7ff fbc0 	bl	80003b0 <sdObjectInit.4325>
  SD1.usart = USART1;
 8000c30:	4b05      	ldr	r3, [pc, #20]	; (8000c48 <sd_lld_init.4165+0x28>)
 8000c32:	4a07      	ldr	r2, [pc, #28]	; (8000c50 <sd_lld_init.4165+0x30>)
 8000c34:	675a      	str	r2, [r3, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 8000c36:	4b04      	ldr	r3, [pc, #16]	; (8000c48 <sd_lld_init.4165+0x28>)
 8000c38:	4a06      	ldr	r2, [pc, #24]	; (8000c54 <sd_lld_init.4165+0x34>)
 8000c3a:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_USART1_NUMBER)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8000c3c:	201b      	movs	r0, #27
 8000c3e:	2103      	movs	r1, #3
 8000c40:	f7ff fc0e 	bl	8000460 <nvicEnableVector.4300>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8000c44:	bd08      	pop	{r3, pc}
 8000c46:	46c0      	nop			; (mov r8, r8)
 8000c48:	20000450 	.word	0x20000450
 8000c4c:	08000be1 	.word	0x08000be1
 8000c50:	40013800 	.word	0x40013800
 8000c54:	02dc6c00 	.word	0x02dc6c00
 8000c58:	46c0      	nop			; (mov r8, r8)
 8000c5a:	46c0      	nop			; (mov r8, r8)
 8000c5c:	46c0      	nop			; (mov r8, r8)
 8000c5e:	46c0      	nop			; (mov r8, r8)

08000c60 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8000c60:	b508      	push	{r3, lr}

  stm32_clock_init();
 8000c62:	f7ff fca5 	bl	80005b0 <stm32_clock_init.4282>
}
 8000c66:	bd08      	pop	{r3, pc}
 8000c68:	46c0      	nop			; (mov r8, r8)
 8000c6a:	46c0      	nop			; (mov r8, r8)
 8000c6c:	46c0      	nop			; (mov r8, r8)
 8000c6e:	46c0      	nop			; (mov r8, r8)

08000c70 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8000c70:	4770      	bx	lr
 8000c72:	46c0      	nop			; (mov r8, r8)
 8000c74:	46c0      	nop			; (mov r8, r8)
 8000c76:	46c0      	nop			; (mov r8, r8)
 8000c78:	46c0      	nop			; (mov r8, r8)
 8000c7a:	46c0      	nop			; (mov r8, r8)
 8000c7c:	46c0      	nop			; (mov r8, r8)
 8000c7e:	46c0      	nop			; (mov r8, r8)

08000c80 <main>:
#include "hal.h"
#include "ch.h"

int main(void)
{
 8000c80:	b500      	push	{lr}
 8000c82:	b083      	sub	sp, #12
	halInit();
 8000c84:	f000 f934 	bl	8000ef0 <halInit>
	chSysInit();
 8000c88:	f000 fdea 	bl	8001860 <chSysInit>
    palSetPadMode(GPIOA, GPIOA_PIN5, PAL_MODE_OUTPUT_PUSHPULL);
 8000c8c:	2390      	movs	r3, #144	; 0x90
 8000c8e:	05db      	lsls	r3, r3, #23
 8000c90:	1c18      	adds	r0, r3, #0
 8000c92:	2120      	movs	r1, #32
 8000c94:	2201      	movs	r2, #1
 8000c96:	f7ff fdf3 	bl	8000880 <_pal_lld_setgroupmode>

	volatile long i,j;
	while(!0)
	{		
		palClearPad(GPIOA, GPIOA_PIN5); 
 8000c9a:	2390      	movs	r3, #144	; 0x90
 8000c9c:	05db      	lsls	r3, r3, #23
 8000c9e:	2220      	movs	r2, #32
 8000ca0:	835a      	strh	r2, [r3, #26]
		for(i = 0; i < 10000000; i++)
 8000ca2:	2300      	movs	r3, #0
 8000ca4:	9301      	str	r3, [sp, #4]
 8000ca6:	e005      	b.n	8000cb4 <main+0x34>
			j++;
 8000ca8:	9b00      	ldr	r3, [sp, #0]
 8000caa:	3301      	adds	r3, #1
 8000cac:	9300      	str	r3, [sp, #0]

	volatile long i,j;
	while(!0)
	{		
		palClearPad(GPIOA, GPIOA_PIN5); 
		for(i = 0; i < 10000000; i++)
 8000cae:	9b01      	ldr	r3, [sp, #4]
 8000cb0:	3301      	adds	r3, #1
 8000cb2:	9301      	str	r3, [sp, #4]
 8000cb4:	9a01      	ldr	r2, [sp, #4]
 8000cb6:	4b0a      	ldr	r3, [pc, #40]	; (8000ce0 <main+0x60>)
 8000cb8:	429a      	cmp	r2, r3
 8000cba:	ddf5      	ble.n	8000ca8 <main+0x28>
			j++;
		//chThdSleepMilliseconds(100);
		palSetPad(GPIOA, GPIOA_PIN5);
 8000cbc:	2390      	movs	r3, #144	; 0x90
 8000cbe:	05db      	lsls	r3, r3, #23
 8000cc0:	2220      	movs	r2, #32
 8000cc2:	831a      	strh	r2, [r3, #24]
		for(i = 0; i < 10000000; i++)
 8000cc4:	2300      	movs	r3, #0
 8000cc6:	9301      	str	r3, [sp, #4]
 8000cc8:	e005      	b.n	8000cd6 <main+0x56>
			j++;
 8000cca:	9b00      	ldr	r3, [sp, #0]
 8000ccc:	3301      	adds	r3, #1
 8000cce:	9300      	str	r3, [sp, #0]
		palClearPad(GPIOA, GPIOA_PIN5); 
		for(i = 0; i < 10000000; i++)
			j++;
		//chThdSleepMilliseconds(100);
		palSetPad(GPIOA, GPIOA_PIN5);
		for(i = 0; i < 10000000; i++)
 8000cd0:	9b01      	ldr	r3, [sp, #4]
 8000cd2:	3301      	adds	r3, #1
 8000cd4:	9301      	str	r3, [sp, #4]
 8000cd6:	9a01      	ldr	r2, [sp, #4]
 8000cd8:	4b01      	ldr	r3, [pc, #4]	; (8000ce0 <main+0x60>)
 8000cda:	429a      	cmp	r2, r3
 8000cdc:	ddf5      	ble.n	8000cca <main+0x4a>
 8000cde:	e7dc      	b.n	8000c9a <main+0x1a>
 8000ce0:	0098967f 	.word	0x0098967f
 8000ce4:	46c0      	nop			; (mov r8, r8)
 8000ce6:	46c0      	nop			; (mov r8, r8)
 8000ce8:	46c0      	nop			; (mov r8, r8)
 8000cea:	46c0      	nop			; (mov r8, r8)
 8000cec:	46c0      	nop			; (mov r8, r8)
 8000cee:	46c0      	nop			; (mov r8, r8)

08000cf0 <port_lock.5714.4332>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cf0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000cf2:	4770      	bx	lr
 8000cf4:	46c0      	nop			; (mov r8, r8)
 8000cf6:	46c0      	nop			; (mov r8, r8)
 8000cf8:	46c0      	nop			; (mov r8, r8)
 8000cfa:	46c0      	nop			; (mov r8, r8)
 8000cfc:	46c0      	nop			; (mov r8, r8)
 8000cfe:	46c0      	nop			; (mov r8, r8)

08000d00 <port_unlock.5717.4330>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d00:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000d02:	4770      	bx	lr
 8000d04:	46c0      	nop			; (mov r8, r8)
 8000d06:	46c0      	nop			; (mov r8, r8)
 8000d08:	46c0      	nop			; (mov r8, r8)
 8000d0a:	46c0      	nop			; (mov r8, r8)
 8000d0c:	46c0      	nop			; (mov r8, r8)
 8000d0e:	46c0      	nop			; (mov r8, r8)

08000d10 <chSysLock.5719.4328>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8000d10:	b508      	push	{r3, lr}

  port_lock();
 8000d12:	f7ff ffed 	bl	8000cf0 <port_lock.5714.4332>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8000d16:	bd08      	pop	{r3, pc}
 8000d18:	46c0      	nop			; (mov r8, r8)
 8000d1a:	46c0      	nop			; (mov r8, r8)
 8000d1c:	46c0      	nop			; (mov r8, r8)
 8000d1e:	46c0      	nop			; (mov r8, r8)

08000d20 <chSysUnlock.5721.4326>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000d20:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8000d22:	f7ff ffed 	bl	8000d00 <port_unlock.5717.4330>
}
 8000d26:	bd08      	pop	{r3, pc}
 8000d28:	46c0      	nop			; (mov r8, r8)
 8000d2a:	46c0      	nop			; (mov r8, r8)
 8000d2c:	46c0      	nop			; (mov r8, r8)
 8000d2e:	46c0      	nop			; (mov r8, r8)

08000d30 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d30:	4b06      	ldr	r3, [pc, #24]	; (8000d4c <_core_init+0x1c>)
 8000d32:	3307      	adds	r3, #7
 8000d34:	2207      	movs	r2, #7
 8000d36:	4393      	bics	r3, r2
 8000d38:	1c1a      	adds	r2, r3, #0
 8000d3a:	4b05      	ldr	r3, [pc, #20]	; (8000d50 <_core_init+0x20>)
 8000d3c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d3e:	4b05      	ldr	r3, [pc, #20]	; (8000d54 <_core_init+0x24>)
 8000d40:	2207      	movs	r2, #7
 8000d42:	4393      	bics	r3, r2
 8000d44:	1c1a      	adds	r2, r3, #0
 8000d46:	4b04      	ldr	r3, [pc, #16]	; (8000d58 <_core_init+0x28>)
 8000d48:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 8000d4a:	4770      	bx	lr
 8000d4c:	200004d0 	.word	0x200004d0
 8000d50:	20000428 	.word	0x20000428
 8000d54:	20001000 	.word	0x20001000
 8000d58:	2000042c 	.word	0x2000042c
 8000d5c:	46c0      	nop			; (mov r8, r8)
 8000d5e:	46c0      	nop			; (mov r8, r8)

08000d60 <chCoreAlloc.4316>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8000d60:	b500      	push	{lr}
 8000d62:	b085      	sub	sp, #20
 8000d64:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8000d66:	f7ff ffd3 	bl	8000d10 <chSysLock.5719.4328>
  p = chCoreAllocI(size);
 8000d6a:	9b01      	ldr	r3, [sp, #4]
 8000d6c:	1c18      	adds	r0, r3, #0
 8000d6e:	f000 f80f 	bl	8000d90 <chCoreAllocI.4321>
 8000d72:	1c03      	adds	r3, r0, #0
 8000d74:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8000d76:	f7ff ffd3 	bl	8000d20 <chSysUnlock.5721.4326>

  return p;
 8000d7a:	9b03      	ldr	r3, [sp, #12]
}
 8000d7c:	1c18      	adds	r0, r3, #0
 8000d7e:	b005      	add	sp, #20
 8000d80:	bd00      	pop	{pc}
 8000d82:	46c0      	nop			; (mov r8, r8)
 8000d84:	46c0      	nop			; (mov r8, r8)
 8000d86:	46c0      	nop			; (mov r8, r8)
 8000d88:	46c0      	nop			; (mov r8, r8)
 8000d8a:	46c0      	nop			; (mov r8, r8)
 8000d8c:	46c0      	nop			; (mov r8, r8)
 8000d8e:	46c0      	nop			; (mov r8, r8)

08000d90 <chCoreAllocI.4321>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8000d90:	b084      	sub	sp, #16
 8000d92:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000d94:	9b01      	ldr	r3, [sp, #4]
 8000d96:	3307      	adds	r3, #7
 8000d98:	2207      	movs	r2, #7
 8000d9a:	4393      	bics	r3, r2
 8000d9c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000d9e:	4b0c      	ldr	r3, [pc, #48]	; (8000dd0 <chCoreAllocI.4321+0x40>)
 8000da0:	681b      	ldr	r3, [r3, #0]
 8000da2:	1c1a      	adds	r2, r3, #0
 8000da4:	4b0b      	ldr	r3, [pc, #44]	; (8000dd4 <chCoreAllocI.4321+0x44>)
 8000da6:	681b      	ldr	r3, [r3, #0]
 8000da8:	1ad3      	subs	r3, r2, r3
 8000daa:	1c1a      	adds	r2, r3, #0
 8000dac:	9b01      	ldr	r3, [sp, #4]
 8000dae:	429a      	cmp	r2, r3
 8000db0:	d201      	bcs.n	8000db6 <chCoreAllocI.4321+0x26>
  /*lint -restore*/
    return NULL;
 8000db2:	2300      	movs	r3, #0
 8000db4:	e009      	b.n	8000dca <chCoreAllocI.4321+0x3a>
  }
  p = nextmem;
 8000db6:	4b07      	ldr	r3, [pc, #28]	; (8000dd4 <chCoreAllocI.4321+0x44>)
 8000db8:	681b      	ldr	r3, [r3, #0]
 8000dba:	9303      	str	r3, [sp, #12]
  nextmem += size;
 8000dbc:	4b05      	ldr	r3, [pc, #20]	; (8000dd4 <chCoreAllocI.4321+0x44>)
 8000dbe:	681a      	ldr	r2, [r3, #0]
 8000dc0:	9b01      	ldr	r3, [sp, #4]
 8000dc2:	18d2      	adds	r2, r2, r3
 8000dc4:	4b03      	ldr	r3, [pc, #12]	; (8000dd4 <chCoreAllocI.4321+0x44>)
 8000dc6:	601a      	str	r2, [r3, #0]

  return p;
 8000dc8:	9b03      	ldr	r3, [sp, #12]
}
 8000dca:	1c18      	adds	r0, r3, #0
 8000dcc:	b004      	add	sp, #16
 8000dce:	4770      	bx	lr
 8000dd0:	2000042c 	.word	0x2000042c
 8000dd4:	20000428 	.word	0x20000428
 8000dd8:	46c0      	nop			; (mov r8, r8)
 8000dda:	46c0      	nop			; (mov r8, r8)
 8000ddc:	46c0      	nop			; (mov r8, r8)
 8000dde:	46c0      	nop			; (mov r8, r8)

08000de0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8000de0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 8000de2:	4b07      	ldr	r3, [pc, #28]	; (8000e00 <_heap_init+0x20>)
 8000de4:	4a07      	ldr	r2, [pc, #28]	; (8000e04 <_heap_init+0x24>)
 8000de6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8000de8:	4b05      	ldr	r3, [pc, #20]	; (8000e00 <_heap_init+0x20>)
 8000dea:	2200      	movs	r2, #0
 8000dec:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8000dee:	4b04      	ldr	r3, [pc, #16]	; (8000e00 <_heap_init+0x20>)
 8000df0:	2200      	movs	r2, #0
 8000df2:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8000df4:	4b04      	ldr	r3, [pc, #16]	; (8000e08 <_heap_init+0x28>)
 8000df6:	1c18      	adds	r0, r3, #0
 8000df8:	f001 fa6a 	bl	80022d0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 8000dfc:	bd08      	pop	{r3, pc}
 8000dfe:	46c0      	nop			; (mov r8, r8)
 8000e00:	20000430 	.word	0x20000430
 8000e04:	08000d61 	.word	0x08000d61
 8000e08:	20000440 	.word	0x20000440
 8000e0c:	46c0      	nop			; (mov r8, r8)
 8000e0e:	46c0      	nop			; (mov r8, r8)

08000e10 <port_lock.5920.4276>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e10:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000e12:	4770      	bx	lr
 8000e14:	46c0      	nop			; (mov r8, r8)
 8000e16:	46c0      	nop			; (mov r8, r8)
 8000e18:	46c0      	nop			; (mov r8, r8)
 8000e1a:	46c0      	nop			; (mov r8, r8)
 8000e1c:	46c0      	nop			; (mov r8, r8)
 8000e1e:	46c0      	nop			; (mov r8, r8)

08000e20 <port_unlock.5923.4274>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e20:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000e22:	4770      	bx	lr
 8000e24:	46c0      	nop			; (mov r8, r8)
 8000e26:	46c0      	nop			; (mov r8, r8)
 8000e28:	46c0      	nop			; (mov r8, r8)
 8000e2a:	46c0      	nop			; (mov r8, r8)
 8000e2c:	46c0      	nop			; (mov r8, r8)
 8000e2e:	46c0      	nop			; (mov r8, r8)

08000e30 <port_lock_from_isr.5925.4272>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000e30:	b508      	push	{r3, lr}

  port_lock();
 8000e32:	f7ff ffed 	bl	8000e10 <port_lock.5920.4276>
}
 8000e36:	bd08      	pop	{r3, pc}
 8000e38:	46c0      	nop			; (mov r8, r8)
 8000e3a:	46c0      	nop			; (mov r8, r8)
 8000e3c:	46c0      	nop			; (mov r8, r8)
 8000e3e:	46c0      	nop			; (mov r8, r8)

08000e40 <port_unlock_from_isr.5927.4270>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000e40:	b508      	push	{r3, lr}

  port_unlock();
 8000e42:	f7ff ffed 	bl	8000e20 <port_unlock.5923.4274>
}
 8000e46:	bd08      	pop	{r3, pc}
 8000e48:	46c0      	nop			; (mov r8, r8)
 8000e4a:	46c0      	nop			; (mov r8, r8)
 8000e4c:	46c0      	nop			; (mov r8, r8)
 8000e4e:	46c0      	nop			; (mov r8, r8)

08000e50 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8000e50:	b510      	push	{r4, lr}
 8000e52:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e54:	f3ef 8309 	mrs	r3, PSP
 8000e58:	1c1c      	adds	r4, r3, #0
  return(result);
 8000e5a:	1c23      	adds	r3, r4, #0
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 8000e5c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000e5e:	9b01      	ldr	r3, [sp, #4]
 8000e60:	3320      	adds	r3, #32
 8000e62:	9301      	str	r3, [sp, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8000e64:	9b01      	ldr	r3, [sp, #4]
 8000e66:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000e68:	9b00      	ldr	r3, [sp, #0]
 8000e6a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8000e6e:	f7ff ffe7 	bl	8000e40 <port_unlock_from_isr.5927.4270>
}
 8000e72:	b002      	add	sp, #8
 8000e74:	bd10      	pop	{r4, pc}
 8000e76:	46c0      	nop			; (mov r8, r8)
 8000e78:	46c0      	nop			; (mov r8, r8)
 8000e7a:	46c0      	nop			; (mov r8, r8)
 8000e7c:	46c0      	nop			; (mov r8, r8)
 8000e7e:	46c0      	nop			; (mov r8, r8)

08000e80 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 8000e80:	b510      	push	{r4, lr}
 8000e82:	b084      	sub	sp, #16
 8000e84:	9001      	str	r0, [sp, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000e86:	9b01      	ldr	r3, [sp, #4]
 8000e88:	1c1a      	adds	r2, r3, #0
 8000e8a:	320f      	adds	r2, #15
 8000e8c:	d01e      	beq.n	8000ecc <_port_irq_epilogue+0x4c>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 8000e8e:	f7ff ffcf 	bl	8000e30 <port_lock_from_isr.5925.4272>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e92:	f3ef 8309 	mrs	r3, PSP
 8000e96:	1c1c      	adds	r4, r3, #0
  return(result);
 8000e98:	1c23      	adds	r3, r4, #0

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8000e9a:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000e9c:	9b03      	ldr	r3, [sp, #12]
 8000e9e:	3b20      	subs	r3, #32
 8000ea0:	9303      	str	r3, [sp, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8000ea2:	9b03      	ldr	r3, [sp, #12]
 8000ea4:	9302      	str	r3, [sp, #8]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000ea6:	9b02      	ldr	r3, [sp, #8]
 8000ea8:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000eac:	9b03      	ldr	r3, [sp, #12]
 8000eae:	2280      	movs	r2, #128	; 0x80
 8000eb0:	0452      	lsls	r2, r2, #17
 8000eb2:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000eb4:	f001 f844 	bl	8001f40 <chSchIsPreemptionRequired>
 8000eb8:	1c03      	adds	r3, r0, #0
 8000eba:	2b00      	cmp	r3, #0
 8000ebc:	d003      	beq.n	8000ec6 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000ebe:	9b03      	ldr	r3, [sp, #12]
 8000ec0:	4a03      	ldr	r2, [pc, #12]	; (8000ed0 <_port_irq_epilogue+0x50>)
 8000ec2:	619a      	str	r2, [r3, #24]
 8000ec4:	e002      	b.n	8000ecc <_port_irq_epilogue+0x4c>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000ec6:	9b03      	ldr	r3, [sp, #12]
 8000ec8:	4a02      	ldr	r2, [pc, #8]	; (8000ed4 <_port_irq_epilogue+0x54>)
 8000eca:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000ecc:	b004      	add	sp, #16
 8000ece:	bd10      	pop	{r4, pc}
 8000ed0:	080001bd 	.word	0x080001bd
 8000ed4:	080001c0 	.word	0x080001c0
 8000ed8:	46c0      	nop			; (mov r8, r8)
 8000eda:	46c0      	nop			; (mov r8, r8)
 8000edc:	46c0      	nop			; (mov r8, r8)
 8000ede:	46c0      	nop			; (mov r8, r8)

08000ee0 <osalInit.5962.4260>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000ee0:	4770      	bx	lr
 8000ee2:	46c0      	nop			; (mov r8, r8)
 8000ee4:	46c0      	nop			; (mov r8, r8)
 8000ee6:	46c0      	nop			; (mov r8, r8)
 8000ee8:	46c0      	nop			; (mov r8, r8)
 8000eea:	46c0      	nop			; (mov r8, r8)
 8000eec:	46c0      	nop			; (mov r8, r8)
 8000eee:	46c0      	nop			; (mov r8, r8)

08000ef0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000ef0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000ef2:	f7ff fff5 	bl	8000ee0 <osalInit.5962.4260>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000ef6:	f7ff fb2b 	bl	8000550 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8000efa:	4b05      	ldr	r3, [pc, #20]	; (8000f10 <halInit+0x20>)
 8000efc:	1c18      	adds	r0, r3, #0
 8000efe:	f7ff fc8f 	bl	8000820 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000f02:	f7ff fa4d 	bl	80003a0 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000f06:	f7ff feb3 	bl	8000c70 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8000f0a:	f000 f839 	bl	8000f80 <stInit.4245>
#endif
}
 8000f0e:	bd08      	pop	{r3, pc}
 8000f10:	08002340 	.word	0x08002340
 8000f14:	46c0      	nop			; (mov r8, r8)
 8000f16:	46c0      	nop			; (mov r8, r8)
 8000f18:	46c0      	nop			; (mov r8, r8)
 8000f1a:	46c0      	nop			; (mov r8, r8)
 8000f1c:	46c0      	nop			; (mov r8, r8)
 8000f1e:	46c0      	nop			; (mov r8, r8)

08000f20 <st_lld_start_alarm.5990.4254>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8000f20:	b082      	sub	sp, #8
 8000f22:	1c02      	adds	r2, r0, #0
 8000f24:	466b      	mov	r3, sp
 8000f26:	3306      	adds	r3, #6
 8000f28:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000f2a:	4b06      	ldr	r3, [pc, #24]	; (8000f44 <st_lld_start_alarm.5990.4254+0x24>)
 8000f2c:	466a      	mov	r2, sp
 8000f2e:	3206      	adds	r2, #6
 8000f30:	8812      	ldrh	r2, [r2, #0]
 8000f32:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000f34:	4b03      	ldr	r3, [pc, #12]	; (8000f44 <st_lld_start_alarm.5990.4254+0x24>)
 8000f36:	2200      	movs	r2, #0
 8000f38:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000f3a:	4b02      	ldr	r3, [pc, #8]	; (8000f44 <st_lld_start_alarm.5990.4254+0x24>)
 8000f3c:	2202      	movs	r2, #2
 8000f3e:	60da      	str	r2, [r3, #12]
}
 8000f40:	b002      	add	sp, #8
 8000f42:	4770      	bx	lr
 8000f44:	40000400 	.word	0x40000400
 8000f48:	46c0      	nop			; (mov r8, r8)
 8000f4a:	46c0      	nop			; (mov r8, r8)
 8000f4c:	46c0      	nop			; (mov r8, r8)
 8000f4e:	46c0      	nop			; (mov r8, r8)

08000f50 <st_lld_stop_alarm.5997.4252>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000f50:	4b01      	ldr	r3, [pc, #4]	; (8000f58 <st_lld_stop_alarm.5997.4252+0x8>)
 8000f52:	2200      	movs	r2, #0
 8000f54:	60da      	str	r2, [r3, #12]
}
 8000f56:	4770      	bx	lr
 8000f58:	40000400 	.word	0x40000400
 8000f5c:	46c0      	nop			; (mov r8, r8)
 8000f5e:	46c0      	nop			; (mov r8, r8)

08000f60 <st_lld_set_alarm.5999.4249>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8000f60:	b082      	sub	sp, #8
 8000f62:	1c02      	adds	r2, r0, #0
 8000f64:	466b      	mov	r3, sp
 8000f66:	3306      	adds	r3, #6
 8000f68:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000f6a:	4b03      	ldr	r3, [pc, #12]	; (8000f78 <st_lld_set_alarm.5999.4249+0x18>)
 8000f6c:	466a      	mov	r2, sp
 8000f6e:	3206      	adds	r2, #6
 8000f70:	8812      	ldrh	r2, [r2, #0]
 8000f72:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000f74:	b002      	add	sp, #8
 8000f76:	4770      	bx	lr
 8000f78:	40000400 	.word	0x40000400
 8000f7c:	46c0      	nop			; (mov r8, r8)
 8000f7e:	46c0      	nop			; (mov r8, r8)

08000f80 <stInit.4245>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000f80:	b508      	push	{r3, lr}

  st_lld_init();
 8000f82:	f7ff fbed 	bl	8000760 <st_lld_init>
}
 8000f86:	bd08      	pop	{r3, pc}
 8000f88:	46c0      	nop			; (mov r8, r8)
 8000f8a:	46c0      	nop			; (mov r8, r8)
 8000f8c:	46c0      	nop			; (mov r8, r8)
 8000f8e:	46c0      	nop			; (mov r8, r8)

08000f90 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000f90:	b500      	push	{lr}
 8000f92:	b083      	sub	sp, #12
 8000f94:	1c02      	adds	r2, r0, #0
 8000f96:	466b      	mov	r3, sp
 8000f98:	3306      	adds	r3, #6
 8000f9a:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8000f9c:	466b      	mov	r3, sp
 8000f9e:	3306      	adds	r3, #6
 8000fa0:	881b      	ldrh	r3, [r3, #0]
 8000fa2:	1c18      	adds	r0, r3, #0
 8000fa4:	f7ff ffbc 	bl	8000f20 <st_lld_start_alarm.5990.4254>
}
 8000fa8:	b003      	add	sp, #12
 8000faa:	bd00      	pop	{pc}
 8000fac:	46c0      	nop			; (mov r8, r8)
 8000fae:	46c0      	nop			; (mov r8, r8)

08000fb0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000fb0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8000fb2:	f7ff ffcd 	bl	8000f50 <st_lld_stop_alarm.5997.4252>
}
 8000fb6:	bd08      	pop	{r3, pc}
 8000fb8:	46c0      	nop			; (mov r8, r8)
 8000fba:	46c0      	nop			; (mov r8, r8)
 8000fbc:	46c0      	nop			; (mov r8, r8)
 8000fbe:	46c0      	nop			; (mov r8, r8)

08000fc0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000fc0:	b500      	push	{lr}
 8000fc2:	b083      	sub	sp, #12
 8000fc4:	1c02      	adds	r2, r0, #0
 8000fc6:	466b      	mov	r3, sp
 8000fc8:	3306      	adds	r3, #6
 8000fca:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8000fcc:	466b      	mov	r3, sp
 8000fce:	3306      	adds	r3, #6
 8000fd0:	881b      	ldrh	r3, [r3, #0]
 8000fd2:	1c18      	adds	r0, r3, #0
 8000fd4:	f7ff ffc4 	bl	8000f60 <st_lld_set_alarm.5999.4249>
}
 8000fd8:	b003      	add	sp, #12
 8000fda:	bd00      	pop	{pc}
 8000fdc:	46c0      	nop			; (mov r8, r8)
 8000fde:	46c0      	nop			; (mov r8, r8)

08000fe0 <port_lock.6048.4232>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000fe0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000fe2:	4770      	bx	lr
 8000fe4:	46c0      	nop			; (mov r8, r8)
 8000fe6:	46c0      	nop			; (mov r8, r8)
 8000fe8:	46c0      	nop			; (mov r8, r8)
 8000fea:	46c0      	nop			; (mov r8, r8)
 8000fec:	46c0      	nop			; (mov r8, r8)
 8000fee:	46c0      	nop			; (mov r8, r8)

08000ff0 <port_unlock.6051.4230>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000ff0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000ff2:	4770      	bx	lr
 8000ff4:	46c0      	nop			; (mov r8, r8)
 8000ff6:	46c0      	nop			; (mov r8, r8)
 8000ff8:	46c0      	nop			; (mov r8, r8)
 8000ffa:	46c0      	nop			; (mov r8, r8)
 8000ffc:	46c0      	nop			; (mov r8, r8)
 8000ffe:	46c0      	nop			; (mov r8, r8)

08001000 <queue_init.6053.4227>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001000:	b082      	sub	sp, #8
 8001002:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001004:	9b01      	ldr	r3, [sp, #4]
 8001006:	9a01      	ldr	r2, [sp, #4]
 8001008:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800100a:	9b01      	ldr	r3, [sp, #4]
 800100c:	9a01      	ldr	r2, [sp, #4]
 800100e:	605a      	str	r2, [r3, #4]
}
 8001010:	b002      	add	sp, #8
 8001012:	4770      	bx	lr
 8001014:	46c0      	nop			; (mov r8, r8)
 8001016:	46c0      	nop			; (mov r8, r8)
 8001018:	46c0      	nop			; (mov r8, r8)
 800101a:	46c0      	nop			; (mov r8, r8)
 800101c:	46c0      	nop			; (mov r8, r8)
 800101e:	46c0      	nop			; (mov r8, r8)

08001020 <chSysLock.6119.4225>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8001020:	b508      	push	{r3, lr}

  port_lock();
 8001022:	f7ff ffdd 	bl	8000fe0 <port_lock.6048.4232>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001026:	bd08      	pop	{r3, pc}
 8001028:	46c0      	nop			; (mov r8, r8)
 800102a:	46c0      	nop			; (mov r8, r8)
 800102c:	46c0      	nop			; (mov r8, r8)
 800102e:	46c0      	nop			; (mov r8, r8)

08001030 <chSysUnlock.6121.4223>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001030:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001032:	f7ff ffdd 	bl	8000ff0 <port_unlock.6051.4230>
}
 8001036:	bd08      	pop	{r3, pc}
 8001038:	46c0      	nop			; (mov r8, r8)
 800103a:	46c0      	nop			; (mov r8, r8)
 800103c:	46c0      	nop			; (mov r8, r8)
 800103e:	46c0      	nop			; (mov r8, r8)

08001040 <chThdQueueObjectInit.6123.4220>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8001040:	b500      	push	{lr}
 8001042:	b083      	sub	sp, #12
 8001044:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8001046:	9b01      	ldr	r3, [sp, #4]
 8001048:	1c18      	adds	r0, r3, #0
 800104a:	f7ff ffd9 	bl	8001000 <queue_init.6053.4227>
}
 800104e:	b003      	add	sp, #12
 8001050:	bd00      	pop	{pc}
 8001052:	46c0      	nop			; (mov r8, r8)
 8001054:	46c0      	nop			; (mov r8, r8)
 8001056:	46c0      	nop			; (mov r8, r8)
 8001058:	46c0      	nop			; (mov r8, r8)
 800105a:	46c0      	nop			; (mov r8, r8)
 800105c:	46c0      	nop			; (mov r8, r8)
 800105e:	46c0      	nop			; (mov r8, r8)

08001060 <osalSysLock.6126.4218>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8001060:	b508      	push	{r3, lr}

  chSysLock();
 8001062:	f7ff ffdd 	bl	8001020 <chSysLock.6119.4225>
}
 8001066:	bd08      	pop	{r3, pc}
 8001068:	46c0      	nop			; (mov r8, r8)
 800106a:	46c0      	nop			; (mov r8, r8)
 800106c:	46c0      	nop			; (mov r8, r8)
 800106e:	46c0      	nop			; (mov r8, r8)

08001070 <osalSysUnlock.6128.4216>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8001070:	b508      	push	{r3, lr}

  chSysUnlock();
 8001072:	f7ff ffdd 	bl	8001030 <chSysUnlock.6121.4223>
}
 8001076:	bd08      	pop	{r3, pc}
 8001078:	46c0      	nop			; (mov r8, r8)
 800107a:	46c0      	nop			; (mov r8, r8)
 800107c:	46c0      	nop			; (mov r8, r8)
 800107e:	46c0      	nop			; (mov r8, r8)

08001080 <osalThreadQueueObjectInit.6130.4213>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8001080:	b500      	push	{lr}
 8001082:	b083      	sub	sp, #12
 8001084:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8001086:	9b01      	ldr	r3, [sp, #4]
 8001088:	1c18      	adds	r0, r3, #0
 800108a:	f7ff ffd9 	bl	8001040 <chThdQueueObjectInit.6123.4220>
}
 800108e:	b003      	add	sp, #12
 8001090:	bd00      	pop	{pc}
 8001092:	46c0      	nop			; (mov r8, r8)
 8001094:	46c0      	nop			; (mov r8, r8)
 8001096:	46c0      	nop			; (mov r8, r8)
 8001098:	46c0      	nop			; (mov r8, r8)
 800109a:	46c0      	nop			; (mov r8, r8)
 800109c:	46c0      	nop			; (mov r8, r8)
 800109e:	46c0      	nop			; (mov r8, r8)

080010a0 <osalThreadEnqueueTimeoutS.6141.4209>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 80010a0:	b500      	push	{lr}
 80010a2:	b083      	sub	sp, #12
 80010a4:	9001      	str	r0, [sp, #4]
 80010a6:	1c0a      	adds	r2, r1, #0
 80010a8:	466b      	mov	r3, sp
 80010aa:	3302      	adds	r3, #2
 80010ac:	801a      	strh	r2, [r3, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 80010ae:	9a01      	ldr	r2, [sp, #4]
 80010b0:	466b      	mov	r3, sp
 80010b2:	3302      	adds	r3, #2
 80010b4:	881b      	ldrh	r3, [r3, #0]
 80010b6:	1c10      	adds	r0, r2, #0
 80010b8:	1c19      	adds	r1, r3, #0
 80010ba:	f001 f8b9 	bl	8002230 <chThdEnqueueTimeoutS>
 80010be:	1c03      	adds	r3, r0, #0
}
 80010c0:	1c18      	adds	r0, r3, #0
 80010c2:	b003      	add	sp, #12
 80010c4:	bd00      	pop	{pc}
 80010c6:	46c0      	nop			; (mov r8, r8)
 80010c8:	46c0      	nop			; (mov r8, r8)
 80010ca:	46c0      	nop			; (mov r8, r8)
 80010cc:	46c0      	nop			; (mov r8, r8)
 80010ce:	46c0      	nop			; (mov r8, r8)

080010d0 <osalThreadDequeueNextI.6137.4205>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80010d0:	b500      	push	{lr}
 80010d2:	b083      	sub	sp, #12
 80010d4:	9001      	str	r0, [sp, #4]
 80010d6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 80010d8:	9a01      	ldr	r2, [sp, #4]
 80010da:	9b00      	ldr	r3, [sp, #0]
 80010dc:	1c10      	adds	r0, r2, #0
 80010de:	1c19      	adds	r1, r3, #0
 80010e0:	f001 f8ce 	bl	8002280 <chThdDequeueNextI>
}
 80010e4:	b003      	add	sp, #12
 80010e6:	bd00      	pop	{pc}
 80010e8:	46c0      	nop			; (mov r8, r8)
 80010ea:	46c0      	nop			; (mov r8, r8)
 80010ec:	46c0      	nop			; (mov r8, r8)
 80010ee:	46c0      	nop			; (mov r8, r8)

080010f0 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 80010f0:	b500      	push	{lr}
 80010f2:	b085      	sub	sp, #20
 80010f4:	9003      	str	r0, [sp, #12]
 80010f6:	9102      	str	r1, [sp, #8]
 80010f8:	9201      	str	r2, [sp, #4]
 80010fa:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 80010fc:	9b03      	ldr	r3, [sp, #12]
 80010fe:	1c18      	adds	r0, r3, #0
 8001100:	f7ff ffbe 	bl	8001080 <osalThreadQueueObjectInit.6130.4213>
  iqp->q_counter = 0;
 8001104:	9b03      	ldr	r3, [sp, #12]
 8001106:	2200      	movs	r2, #0
 8001108:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800110a:	9b03      	ldr	r3, [sp, #12]
 800110c:	9a02      	ldr	r2, [sp, #8]
 800110e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8001110:	9b03      	ldr	r3, [sp, #12]
 8001112:	9a02      	ldr	r2, [sp, #8]
 8001114:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8001116:	9b03      	ldr	r3, [sp, #12]
 8001118:	9a02      	ldr	r2, [sp, #8]
 800111a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800111c:	9a02      	ldr	r2, [sp, #8]
 800111e:	9b01      	ldr	r3, [sp, #4]
 8001120:	18d2      	adds	r2, r2, r3
 8001122:	9b03      	ldr	r3, [sp, #12]
 8001124:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8001126:	9b03      	ldr	r3, [sp, #12]
 8001128:	9a00      	ldr	r2, [sp, #0]
 800112a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800112c:	9b03      	ldr	r3, [sp, #12]
 800112e:	9a06      	ldr	r2, [sp, #24]
 8001130:	621a      	str	r2, [r3, #32]
}
 8001132:	b005      	add	sp, #20
 8001134:	bd00      	pop	{pc}
 8001136:	46c0      	nop			; (mov r8, r8)
 8001138:	46c0      	nop			; (mov r8, r8)
 800113a:	46c0      	nop			; (mov r8, r8)
 800113c:	46c0      	nop			; (mov r8, r8)
 800113e:	46c0      	nop			; (mov r8, r8)

08001140 <iqPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8001140:	b500      	push	{lr}
 8001142:	b083      	sub	sp, #12
 8001144:	9001      	str	r0, [sp, #4]
 8001146:	1c0a      	adds	r2, r1, #0
 8001148:	466b      	mov	r3, sp
 800114a:	3303      	adds	r3, #3
 800114c:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 800114e:	9b01      	ldr	r3, [sp, #4]
 8001150:	695a      	ldr	r2, [r3, #20]
 8001152:	9b01      	ldr	r3, [sp, #4]
 8001154:	699b      	ldr	r3, [r3, #24]
 8001156:	429a      	cmp	r2, r3
 8001158:	d105      	bne.n	8001166 <iqPutI+0x26>
 800115a:	9b01      	ldr	r3, [sp, #4]
 800115c:	689b      	ldr	r3, [r3, #8]
 800115e:	2b00      	cmp	r3, #0
 8001160:	d001      	beq.n	8001166 <iqPutI+0x26>
 8001162:	2301      	movs	r3, #1
 8001164:	e000      	b.n	8001168 <iqPutI+0x28>
 8001166:	2300      	movs	r3, #0
 8001168:	1c1a      	adds	r2, r3, #0
 800116a:	2301      	movs	r3, #1
 800116c:	4013      	ands	r3, r2
 800116e:	b2db      	uxtb	r3, r3
 8001170:	2b00      	cmp	r3, #0
 8001172:	d002      	beq.n	800117a <iqPutI+0x3a>
    return Q_FULL;
 8001174:	2304      	movs	r3, #4
 8001176:	425b      	negs	r3, r3
 8001178:	e01d      	b.n	80011b6 <iqPutI+0x76>
  }

  iqp->q_counter++;
 800117a:	9b01      	ldr	r3, [sp, #4]
 800117c:	689b      	ldr	r3, [r3, #8]
 800117e:	1c5a      	adds	r2, r3, #1
 8001180:	9b01      	ldr	r3, [sp, #4]
 8001182:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8001184:	9b01      	ldr	r3, [sp, #4]
 8001186:	695b      	ldr	r3, [r3, #20]
 8001188:	1c59      	adds	r1, r3, #1
 800118a:	9a01      	ldr	r2, [sp, #4]
 800118c:	6151      	str	r1, [r2, #20]
 800118e:	466a      	mov	r2, sp
 8001190:	3203      	adds	r2, #3
 8001192:	7812      	ldrb	r2, [r2, #0]
 8001194:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8001196:	9b01      	ldr	r3, [sp, #4]
 8001198:	695a      	ldr	r2, [r3, #20]
 800119a:	9b01      	ldr	r3, [sp, #4]
 800119c:	691b      	ldr	r3, [r3, #16]
 800119e:	429a      	cmp	r2, r3
 80011a0:	d303      	bcc.n	80011aa <iqPutI+0x6a>
    iqp->q_wrptr = iqp->q_buffer;
 80011a2:	9b01      	ldr	r3, [sp, #4]
 80011a4:	68da      	ldr	r2, [r3, #12]
 80011a6:	9b01      	ldr	r3, [sp, #4]
 80011a8:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, Q_OK);
 80011aa:	9b01      	ldr	r3, [sp, #4]
 80011ac:	1c18      	adds	r0, r3, #0
 80011ae:	2100      	movs	r1, #0
 80011b0:	f7ff ff8e 	bl	80010d0 <osalThreadDequeueNextI.6137.4205>

  return Q_OK;
 80011b4:	2300      	movs	r3, #0
}
 80011b6:	1c18      	adds	r0, r3, #0
 80011b8:	b003      	add	sp, #12
 80011ba:	bd00      	pop	{pc}
 80011bc:	46c0      	nop			; (mov r8, r8)
 80011be:	46c0      	nop			; (mov r8, r8)

080011c0 <iqGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 80011c0:	b500      	push	{lr}
 80011c2:	b085      	sub	sp, #20
 80011c4:	9001      	str	r0, [sp, #4]
 80011c6:	1c0a      	adds	r2, r1, #0
 80011c8:	466b      	mov	r3, sp
 80011ca:	3302      	adds	r3, #2
 80011cc:	801a      	strh	r2, [r3, #0]
  uint8_t b;

  osalSysLock();
 80011ce:	f7ff ff47 	bl	8001060 <osalSysLock.6126.4218>
  if (iqp->q_notify != NULL) {
 80011d2:	9b01      	ldr	r3, [sp, #4]
 80011d4:	69db      	ldr	r3, [r3, #28]
 80011d6:	2b00      	cmp	r3, #0
 80011d8:	d016      	beq.n	8001208 <iqGetTimeout+0x48>
    iqp->q_notify(iqp);
 80011da:	9b01      	ldr	r3, [sp, #4]
 80011dc:	69db      	ldr	r3, [r3, #28]
 80011de:	9a01      	ldr	r2, [sp, #4]
 80011e0:	1c10      	adds	r0, r2, #0
 80011e2:	4798      	blx	r3
 80011e4:	e010      	b.n	8001208 <iqGetTimeout+0x48>
  }

  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80011e6:	9a01      	ldr	r2, [sp, #4]
 80011e8:	466b      	mov	r3, sp
 80011ea:	3302      	adds	r3, #2
 80011ec:	881b      	ldrh	r3, [r3, #0]
 80011ee:	1c10      	adds	r0, r2, #0
 80011f0:	1c19      	adds	r1, r3, #0
 80011f2:	f7ff ff55 	bl	80010a0 <osalThreadEnqueueTimeoutS.6141.4209>
 80011f6:	1c03      	adds	r3, r0, #0
 80011f8:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 80011fa:	9b03      	ldr	r3, [sp, #12]
 80011fc:	2b00      	cmp	r3, #0
 80011fe:	da03      	bge.n	8001208 <iqGetTimeout+0x48>
      osalSysUnlock();
 8001200:	f7ff ff36 	bl	8001070 <osalSysUnlock.6128.4216>
      return msg;
 8001204:	9b03      	ldr	r3, [sp, #12]
 8001206:	e020      	b.n	800124a <iqGetTimeout+0x8a>
  osalSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (iqIsEmptyI(iqp)) {
 8001208:	9b01      	ldr	r3, [sp, #4]
 800120a:	689b      	ldr	r3, [r3, #8]
 800120c:	2b00      	cmp	r3, #0
 800120e:	d0ea      	beq.n	80011e6 <iqGetTimeout+0x26>
      osalSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001210:	9b01      	ldr	r3, [sp, #4]
 8001212:	689b      	ldr	r3, [r3, #8]
 8001214:	1e5a      	subs	r2, r3, #1
 8001216:	9b01      	ldr	r3, [sp, #4]
 8001218:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800121a:	9b01      	ldr	r3, [sp, #4]
 800121c:	699b      	ldr	r3, [r3, #24]
 800121e:	1c59      	adds	r1, r3, #1
 8001220:	9a01      	ldr	r2, [sp, #4]
 8001222:	6191      	str	r1, [r2, #24]
 8001224:	466a      	mov	r2, sp
 8001226:	320b      	adds	r2, #11
 8001228:	781b      	ldrb	r3, [r3, #0]
 800122a:	7013      	strb	r3, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 800122c:	9b01      	ldr	r3, [sp, #4]
 800122e:	699a      	ldr	r2, [r3, #24]
 8001230:	9b01      	ldr	r3, [sp, #4]
 8001232:	691b      	ldr	r3, [r3, #16]
 8001234:	429a      	cmp	r2, r3
 8001236:	d303      	bcc.n	8001240 <iqGetTimeout+0x80>
    iqp->q_rdptr = iqp->q_buffer;
 8001238:	9b01      	ldr	r3, [sp, #4]
 800123a:	68da      	ldr	r2, [r3, #12]
 800123c:	9b01      	ldr	r3, [sp, #4]
 800123e:	619a      	str	r2, [r3, #24]
  }
  osalSysUnlock();
 8001240:	f7ff ff16 	bl	8001070 <osalSysUnlock.6128.4216>

  return (msg_t)b;
 8001244:	466b      	mov	r3, sp
 8001246:	330b      	adds	r3, #11
 8001248:	781b      	ldrb	r3, [r3, #0]
}
 800124a:	1c18      	adds	r0, r3, #0
 800124c:	b005      	add	sp, #20
 800124e:	bd00      	pop	{pc}

08001250 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8001250:	b500      	push	{lr}
 8001252:	b087      	sub	sp, #28
 8001254:	9003      	str	r0, [sp, #12]
 8001256:	9102      	str	r1, [sp, #8]
 8001258:	9201      	str	r2, [sp, #4]
 800125a:	1c1a      	adds	r2, r3, #0
 800125c:	466b      	mov	r3, sp
 800125e:	3302      	adds	r3, #2
 8001260:	801a      	strh	r2, [r3, #0]
  qnotify_t nfy = iqp->q_notify;
 8001262:	9b03      	ldr	r3, [sp, #12]
 8001264:	69db      	ldr	r3, [r3, #28]
 8001266:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8001268:	2300      	movs	r3, #0
 800126a:	9305      	str	r3, [sp, #20]

  osalDbgCheck(n > 0U);

  osalSysLock();
 800126c:	f7ff fef8 	bl	8001060 <osalSysLock.6126.4218>
  while (true) {
    if (nfy != NULL) {
 8001270:	9b04      	ldr	r3, [sp, #16]
 8001272:	2b00      	cmp	r3, #0
 8001274:	d013      	beq.n	800129e <iqReadTimeout+0x4e>
      nfy(iqp);
 8001276:	9a03      	ldr	r2, [sp, #12]
 8001278:	9b04      	ldr	r3, [sp, #16]
 800127a:	1c10      	adds	r0, r2, #0
 800127c:	4798      	blx	r3
 800127e:	e00e      	b.n	800129e <iqReadTimeout+0x4e>
    }

    while (iqIsEmptyI(iqp)) {
      if (osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8001280:	9a03      	ldr	r2, [sp, #12]
 8001282:	466b      	mov	r3, sp
 8001284:	3302      	adds	r3, #2
 8001286:	881b      	ldrh	r3, [r3, #0]
 8001288:	1c10      	adds	r0, r2, #0
 800128a:	1c19      	adds	r1, r3, #0
 800128c:	f7ff ff08 	bl	80010a0 <osalThreadEnqueueTimeoutS.6141.4209>
 8001290:	1c03      	adds	r3, r0, #0
 8001292:	2b00      	cmp	r3, #0
 8001294:	d003      	beq.n	800129e <iqReadTimeout+0x4e>
        osalSysUnlock();
 8001296:	f7ff feeb 	bl	8001070 <osalSysUnlock.6128.4216>
        return r;
 800129a:	9b05      	ldr	r3, [sp, #20]
 800129c:	e02c      	b.n	80012f8 <iqReadTimeout+0xa8>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (iqIsEmptyI(iqp)) {
 800129e:	9b03      	ldr	r3, [sp, #12]
 80012a0:	689b      	ldr	r3, [r3, #8]
 80012a2:	2b00      	cmp	r3, #0
 80012a4:	d0ec      	beq.n	8001280 <iqReadTimeout+0x30>
        osalSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80012a6:	9b03      	ldr	r3, [sp, #12]
 80012a8:	689b      	ldr	r3, [r3, #8]
 80012aa:	1e5a      	subs	r2, r3, #1
 80012ac:	9b03      	ldr	r3, [sp, #12]
 80012ae:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 80012b0:	9b02      	ldr	r3, [sp, #8]
 80012b2:	1c5a      	adds	r2, r3, #1
 80012b4:	9202      	str	r2, [sp, #8]
 80012b6:	9a03      	ldr	r2, [sp, #12]
 80012b8:	6992      	ldr	r2, [r2, #24]
 80012ba:	1c50      	adds	r0, r2, #1
 80012bc:	9903      	ldr	r1, [sp, #12]
 80012be:	6188      	str	r0, [r1, #24]
 80012c0:	7812      	ldrb	r2, [r2, #0]
 80012c2:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 80012c4:	9b03      	ldr	r3, [sp, #12]
 80012c6:	699a      	ldr	r2, [r3, #24]
 80012c8:	9b03      	ldr	r3, [sp, #12]
 80012ca:	691b      	ldr	r3, [r3, #16]
 80012cc:	429a      	cmp	r2, r3
 80012ce:	d303      	bcc.n	80012d8 <iqReadTimeout+0x88>
      iqp->q_rdptr = iqp->q_buffer;
 80012d0:	9b03      	ldr	r3, [sp, #12]
 80012d2:	68da      	ldr	r2, [r3, #12]
 80012d4:	9b03      	ldr	r3, [sp, #12]
 80012d6:	619a      	str	r2, [r3, #24]
    }
    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80012d8:	f7ff feca 	bl	8001070 <osalSysUnlock.6128.4216>

    r++;
 80012dc:	9b05      	ldr	r3, [sp, #20]
 80012de:	3301      	adds	r3, #1
 80012e0:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80012e2:	9b01      	ldr	r3, [sp, #4]
 80012e4:	3b01      	subs	r3, #1
 80012e6:	9301      	str	r3, [sp, #4]
 80012e8:	9b01      	ldr	r3, [sp, #4]
 80012ea:	2b00      	cmp	r3, #0
 80012ec:	d101      	bne.n	80012f2 <iqReadTimeout+0xa2>
      return r;
 80012ee:	9b05      	ldr	r3, [sp, #20]
 80012f0:	e002      	b.n	80012f8 <iqReadTimeout+0xa8>
    }

    osalSysLock();
 80012f2:	f7ff feb5 	bl	8001060 <osalSysLock.6126.4218>
 80012f6:	e7bb      	b.n	8001270 <iqReadTimeout+0x20>
  }
}
 80012f8:	1c18      	adds	r0, r3, #0
 80012fa:	b007      	add	sp, #28
 80012fc:	bd00      	pop	{pc}
 80012fe:	46c0      	nop			; (mov r8, r8)

08001300 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8001300:	b500      	push	{lr}
 8001302:	b085      	sub	sp, #20
 8001304:	9003      	str	r0, [sp, #12]
 8001306:	9102      	str	r1, [sp, #8]
 8001308:	9201      	str	r2, [sp, #4]
 800130a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 800130c:	9b03      	ldr	r3, [sp, #12]
 800130e:	1c18      	adds	r0, r3, #0
 8001310:	f7ff feb6 	bl	8001080 <osalThreadQueueObjectInit.6130.4213>
  oqp->q_counter = size;
 8001314:	9b03      	ldr	r3, [sp, #12]
 8001316:	9a01      	ldr	r2, [sp, #4]
 8001318:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800131a:	9b03      	ldr	r3, [sp, #12]
 800131c:	9a02      	ldr	r2, [sp, #8]
 800131e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8001320:	9b03      	ldr	r3, [sp, #12]
 8001322:	9a02      	ldr	r2, [sp, #8]
 8001324:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8001326:	9b03      	ldr	r3, [sp, #12]
 8001328:	9a02      	ldr	r2, [sp, #8]
 800132a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800132c:	9a02      	ldr	r2, [sp, #8]
 800132e:	9b01      	ldr	r3, [sp, #4]
 8001330:	18d2      	adds	r2, r2, r3
 8001332:	9b03      	ldr	r3, [sp, #12]
 8001334:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8001336:	9b03      	ldr	r3, [sp, #12]
 8001338:	9a00      	ldr	r2, [sp, #0]
 800133a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800133c:	9b03      	ldr	r3, [sp, #12]
 800133e:	9a06      	ldr	r2, [sp, #24]
 8001340:	621a      	str	r2, [r3, #32]
}
 8001342:	b005      	add	sp, #20
 8001344:	bd00      	pop	{pc}
 8001346:	46c0      	nop			; (mov r8, r8)
 8001348:	46c0      	nop			; (mov r8, r8)
 800134a:	46c0      	nop			; (mov r8, r8)
 800134c:	46c0      	nop			; (mov r8, r8)
 800134e:	46c0      	nop			; (mov r8, r8)

08001350 <oqPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001350:	b500      	push	{lr}
 8001352:	b085      	sub	sp, #20
 8001354:	9001      	str	r0, [sp, #4]
 8001356:	466b      	mov	r3, sp
 8001358:	3303      	adds	r3, #3
 800135a:	7019      	strb	r1, [r3, #0]
 800135c:	466b      	mov	r3, sp
 800135e:	801a      	strh	r2, [r3, #0]

  osalSysLock();
 8001360:	f7ff fe7e 	bl	8001060 <osalSysLock.6126.4218>
 8001364:	e00f      	b.n	8001386 <oqPutTimeout+0x36>
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001366:	9a01      	ldr	r2, [sp, #4]
 8001368:	466b      	mov	r3, sp
 800136a:	881b      	ldrh	r3, [r3, #0]
 800136c:	1c10      	adds	r0, r2, #0
 800136e:	1c19      	adds	r1, r3, #0
 8001370:	f7ff fe96 	bl	80010a0 <osalThreadEnqueueTimeoutS.6141.4209>
 8001374:	1c03      	adds	r3, r0, #0
 8001376:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 8001378:	9b03      	ldr	r3, [sp, #12]
 800137a:	2b00      	cmp	r3, #0
 800137c:	da03      	bge.n	8001386 <oqPutTimeout+0x36>
      osalSysUnlock();
 800137e:	f7ff fe77 	bl	8001070 <osalSysUnlock.6128.4216>
      return msg;
 8001382:	9b03      	ldr	r3, [sp, #12]
 8001384:	e027      	b.n	80013d6 <oqPutTimeout+0x86>
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();
  while (oqIsFullI(oqp)) {
 8001386:	9b01      	ldr	r3, [sp, #4]
 8001388:	689b      	ldr	r3, [r3, #8]
 800138a:	2b00      	cmp	r3, #0
 800138c:	d0eb      	beq.n	8001366 <oqPutTimeout+0x16>
      osalSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800138e:	9b01      	ldr	r3, [sp, #4]
 8001390:	689b      	ldr	r3, [r3, #8]
 8001392:	1e5a      	subs	r2, r3, #1
 8001394:	9b01      	ldr	r3, [sp, #4]
 8001396:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8001398:	9b01      	ldr	r3, [sp, #4]
 800139a:	695b      	ldr	r3, [r3, #20]
 800139c:	1c59      	adds	r1, r3, #1
 800139e:	9a01      	ldr	r2, [sp, #4]
 80013a0:	6151      	str	r1, [r2, #20]
 80013a2:	466a      	mov	r2, sp
 80013a4:	3203      	adds	r2, #3
 80013a6:	7812      	ldrb	r2, [r2, #0]
 80013a8:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80013aa:	9b01      	ldr	r3, [sp, #4]
 80013ac:	695a      	ldr	r2, [r3, #20]
 80013ae:	9b01      	ldr	r3, [sp, #4]
 80013b0:	691b      	ldr	r3, [r3, #16]
 80013b2:	429a      	cmp	r2, r3
 80013b4:	d303      	bcc.n	80013be <oqPutTimeout+0x6e>
    oqp->q_wrptr = oqp->q_buffer;
 80013b6:	9b01      	ldr	r3, [sp, #4]
 80013b8:	68da      	ldr	r2, [r3, #12]
 80013ba:	9b01      	ldr	r3, [sp, #4]
 80013bc:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80013be:	9b01      	ldr	r3, [sp, #4]
 80013c0:	69db      	ldr	r3, [r3, #28]
 80013c2:	2b00      	cmp	r3, #0
 80013c4:	d004      	beq.n	80013d0 <oqPutTimeout+0x80>
    oqp->q_notify(oqp);
 80013c6:	9b01      	ldr	r3, [sp, #4]
 80013c8:	69db      	ldr	r3, [r3, #28]
 80013ca:	9a01      	ldr	r2, [sp, #4]
 80013cc:	1c10      	adds	r0, r2, #0
 80013ce:	4798      	blx	r3
  }
  osalSysUnlock();
 80013d0:	f7ff fe4e 	bl	8001070 <osalSysUnlock.6128.4216>

  return Q_OK;
 80013d4:	2300      	movs	r3, #0
}
 80013d6:	1c18      	adds	r0, r3, #0
 80013d8:	b005      	add	sp, #20
 80013da:	bd00      	pop	{pc}
 80013dc:	46c0      	nop			; (mov r8, r8)
 80013de:	46c0      	nop			; (mov r8, r8)

080013e0 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 80013e0:	b500      	push	{lr}
 80013e2:	b085      	sub	sp, #20
 80013e4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 80013e6:	9b01      	ldr	r3, [sp, #4]
 80013e8:	695a      	ldr	r2, [r3, #20]
 80013ea:	9b01      	ldr	r3, [sp, #4]
 80013ec:	699b      	ldr	r3, [r3, #24]
 80013ee:	429a      	cmp	r2, r3
 80013f0:	d105      	bne.n	80013fe <oqGetI+0x1e>
 80013f2:	9b01      	ldr	r3, [sp, #4]
 80013f4:	689b      	ldr	r3, [r3, #8]
 80013f6:	2b00      	cmp	r3, #0
 80013f8:	d001      	beq.n	80013fe <oqGetI+0x1e>
 80013fa:	2301      	movs	r3, #1
 80013fc:	e000      	b.n	8001400 <oqGetI+0x20>
 80013fe:	2300      	movs	r3, #0
 8001400:	1c1a      	adds	r2, r3, #0
 8001402:	2301      	movs	r3, #1
 8001404:	4013      	ands	r3, r2
 8001406:	b2db      	uxtb	r3, r3
 8001408:	2b00      	cmp	r3, #0
 800140a:	d002      	beq.n	8001412 <oqGetI+0x32>
    return Q_EMPTY;
 800140c:	2303      	movs	r3, #3
 800140e:	425b      	negs	r3, r3
 8001410:	e01f      	b.n	8001452 <oqGetI+0x72>
  }

  oqp->q_counter++;
 8001412:	9b01      	ldr	r3, [sp, #4]
 8001414:	689b      	ldr	r3, [r3, #8]
 8001416:	1c5a      	adds	r2, r3, #1
 8001418:	9b01      	ldr	r3, [sp, #4]
 800141a:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 800141c:	9b01      	ldr	r3, [sp, #4]
 800141e:	699b      	ldr	r3, [r3, #24]
 8001420:	1c59      	adds	r1, r3, #1
 8001422:	9a01      	ldr	r2, [sp, #4]
 8001424:	6191      	str	r1, [r2, #24]
 8001426:	466a      	mov	r2, sp
 8001428:	320f      	adds	r2, #15
 800142a:	781b      	ldrb	r3, [r3, #0]
 800142c:	7013      	strb	r3, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 800142e:	9b01      	ldr	r3, [sp, #4]
 8001430:	699a      	ldr	r2, [r3, #24]
 8001432:	9b01      	ldr	r3, [sp, #4]
 8001434:	691b      	ldr	r3, [r3, #16]
 8001436:	429a      	cmp	r2, r3
 8001438:	d303      	bcc.n	8001442 <oqGetI+0x62>
    oqp->q_rdptr = oqp->q_buffer;
 800143a:	9b01      	ldr	r3, [sp, #4]
 800143c:	68da      	ldr	r2, [r3, #12]
 800143e:	9b01      	ldr	r3, [sp, #4]
 8001440:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, Q_OK);
 8001442:	9b01      	ldr	r3, [sp, #4]
 8001444:	1c18      	adds	r0, r3, #0
 8001446:	2100      	movs	r1, #0
 8001448:	f7ff fe42 	bl	80010d0 <osalThreadDequeueNextI.6137.4205>

  return (msg_t)b;
 800144c:	466b      	mov	r3, sp
 800144e:	330f      	adds	r3, #15
 8001450:	781b      	ldrb	r3, [r3, #0]
}
 8001452:	1c18      	adds	r0, r3, #0
 8001454:	b005      	add	sp, #20
 8001456:	bd00      	pop	{pc}
 8001458:	46c0      	nop			; (mov r8, r8)
 800145a:	46c0      	nop			; (mov r8, r8)
 800145c:	46c0      	nop			; (mov r8, r8)
 800145e:	46c0      	nop			; (mov r8, r8)

08001460 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8001460:	b500      	push	{lr}
 8001462:	b087      	sub	sp, #28
 8001464:	9003      	str	r0, [sp, #12]
 8001466:	9102      	str	r1, [sp, #8]
 8001468:	9201      	str	r2, [sp, #4]
 800146a:	1c1a      	adds	r2, r3, #0
 800146c:	466b      	mov	r3, sp
 800146e:	3302      	adds	r3, #2
 8001470:	801a      	strh	r2, [r3, #0]
  qnotify_t nfy = oqp->q_notify;
 8001472:	9b03      	ldr	r3, [sp, #12]
 8001474:	69db      	ldr	r3, [r3, #28]
 8001476:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8001478:	2300      	movs	r3, #0
 800147a:	9305      	str	r3, [sp, #20]

  osalDbgCheck(n > 0U);

  osalSysLock();
 800147c:	f7ff fdf0 	bl	8001060 <osalSysLock.6126.4218>
 8001480:	e00e      	b.n	80014a0 <oqWriteTimeout+0x40>
  while (true) {
    while (oqIsFullI(oqp)) {
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8001482:	9a03      	ldr	r2, [sp, #12]
 8001484:	466b      	mov	r3, sp
 8001486:	3302      	adds	r3, #2
 8001488:	881b      	ldrh	r3, [r3, #0]
 800148a:	1c10      	adds	r0, r2, #0
 800148c:	1c19      	adds	r1, r3, #0
 800148e:	f7ff fe07 	bl	80010a0 <osalThreadEnqueueTimeoutS.6141.4209>
 8001492:	1c03      	adds	r3, r0, #0
 8001494:	2b00      	cmp	r3, #0
 8001496:	d003      	beq.n	80014a0 <oqWriteTimeout+0x40>
        osalSysUnlock();
 8001498:	f7ff fdea 	bl	8001070 <osalSysUnlock.6128.4216>
        return w;
 800149c:	9b05      	ldr	r3, [sp, #20]
 800149e:	e033      	b.n	8001508 <oqWriteTimeout+0xa8>

  osalDbgCheck(n > 0U);

  osalSysLock();
  while (true) {
    while (oqIsFullI(oqp)) {
 80014a0:	9b03      	ldr	r3, [sp, #12]
 80014a2:	689b      	ldr	r3, [r3, #8]
 80014a4:	2b00      	cmp	r3, #0
 80014a6:	d0ec      	beq.n	8001482 <oqWriteTimeout+0x22>
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
        osalSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 80014a8:	9b03      	ldr	r3, [sp, #12]
 80014aa:	689b      	ldr	r3, [r3, #8]
 80014ac:	1e5a      	subs	r2, r3, #1
 80014ae:	9b03      	ldr	r3, [sp, #12]
 80014b0:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 80014b2:	9b03      	ldr	r3, [sp, #12]
 80014b4:	695b      	ldr	r3, [r3, #20]
 80014b6:	1c59      	adds	r1, r3, #1
 80014b8:	9a03      	ldr	r2, [sp, #12]
 80014ba:	6151      	str	r1, [r2, #20]
 80014bc:	9a02      	ldr	r2, [sp, #8]
 80014be:	1c51      	adds	r1, r2, #1
 80014c0:	9102      	str	r1, [sp, #8]
 80014c2:	7812      	ldrb	r2, [r2, #0]
 80014c4:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80014c6:	9b03      	ldr	r3, [sp, #12]
 80014c8:	695a      	ldr	r2, [r3, #20]
 80014ca:	9b03      	ldr	r3, [sp, #12]
 80014cc:	691b      	ldr	r3, [r3, #16]
 80014ce:	429a      	cmp	r2, r3
 80014d0:	d303      	bcc.n	80014da <oqWriteTimeout+0x7a>
      oqp->q_wrptr = oqp->q_buffer;
 80014d2:	9b03      	ldr	r3, [sp, #12]
 80014d4:	68da      	ldr	r2, [r3, #12]
 80014d6:	9b03      	ldr	r3, [sp, #12]
 80014d8:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80014da:	9b04      	ldr	r3, [sp, #16]
 80014dc:	2b00      	cmp	r3, #0
 80014de:	d003      	beq.n	80014e8 <oqWriteTimeout+0x88>
      nfy(oqp);
 80014e0:	9a03      	ldr	r2, [sp, #12]
 80014e2:	9b04      	ldr	r3, [sp, #16]
 80014e4:	1c10      	adds	r0, r2, #0
 80014e6:	4798      	blx	r3
    }
    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80014e8:	f7ff fdc2 	bl	8001070 <osalSysUnlock.6128.4216>

    w++;
 80014ec:	9b05      	ldr	r3, [sp, #20]
 80014ee:	3301      	adds	r3, #1
 80014f0:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80014f2:	9b01      	ldr	r3, [sp, #4]
 80014f4:	3b01      	subs	r3, #1
 80014f6:	9301      	str	r3, [sp, #4]
 80014f8:	9b01      	ldr	r3, [sp, #4]
 80014fa:	2b00      	cmp	r3, #0
 80014fc:	d101      	bne.n	8001502 <oqWriteTimeout+0xa2>
      return w;
 80014fe:	9b05      	ldr	r3, [sp, #20]
 8001500:	e002      	b.n	8001508 <oqWriteTimeout+0xa8>
    }

    osalSysLock();
 8001502:	f7ff fdad 	bl	8001060 <osalSysLock.6126.4218>
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);

  osalSysLock();
 8001506:	e7cb      	b.n	80014a0 <oqWriteTimeout+0x40>
      return w;
    }

    osalSysLock();
  }
}
 8001508:	1c18      	adds	r0, r3, #0
 800150a:	b007      	add	sp, #28
 800150c:	bd00      	pop	{pc}
 800150e:	46c0      	nop			; (mov r8, r8)

08001510 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001510:	4770      	bx	lr
 8001512:	46c0      	nop			; (mov r8, r8)
 8001514:	46c0      	nop			; (mov r8, r8)
 8001516:	46c0      	nop			; (mov r8, r8)
 8001518:	46c0      	nop			; (mov r8, r8)
 800151a:	46c0      	nop			; (mov r8, r8)
 800151c:	46c0      	nop			; (mov r8, r8)
 800151e:	46c0      	nop			; (mov r8, r8)

08001520 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001520:	4770      	bx	lr
 8001522:	46c0      	nop			; (mov r8, r8)
 8001524:	46c0      	nop			; (mov r8, r8)
 8001526:	46c0      	nop			; (mov r8, r8)
 8001528:	46c0      	nop			; (mov r8, r8)
 800152a:	46c0      	nop			; (mov r8, r8)
 800152c:	46c0      	nop			; (mov r8, r8)
 800152e:	46c0      	nop			; (mov r8, r8)

08001530 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001530:	e7fe      	b.n	8001530 <__default_exit>
 8001532:	46c0      	nop			; (mov r8, r8)
 8001534:	46c0      	nop			; (mov r8, r8)
 8001536:	46c0      	nop			; (mov r8, r8)
 8001538:	46c0      	nop			; (mov r8, r8)
 800153a:	46c0      	nop			; (mov r8, r8)
 800153c:	46c0      	nop			; (mov r8, r8)
 800153e:	46c0      	nop			; (mov r8, r8)

08001540 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001540:	e7fe      	b.n	8001540 <BusFault_Handler>
 8001542:	46c0      	nop			; (mov r8, r8)
 8001544:	46c0      	nop			; (mov r8, r8)
 8001546:	46c0      	nop			; (mov r8, r8)
 8001548:	46c0      	nop			; (mov r8, r8)
 800154a:	46c0      	nop			; (mov r8, r8)
 800154c:	46c0      	nop			; (mov r8, r8)
 800154e:	46c0      	nop			; (mov r8, r8)

08001550 <NVIC_SetPriority.4097.4486>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001550:	b530      	push	{r4, r5, lr}
 8001552:	b083      	sub	sp, #12
 8001554:	1c02      	adds	r2, r0, #0
 8001556:	9100      	str	r1, [sp, #0]
 8001558:	466b      	mov	r3, sp
 800155a:	3307      	adds	r3, #7
 800155c:	701a      	strb	r2, [r3, #0]
  if((int32_t)(IRQn) < 0) {
 800155e:	466b      	mov	r3, sp
 8001560:	3307      	adds	r3, #7
 8001562:	781b      	ldrb	r3, [r3, #0]
 8001564:	2b7f      	cmp	r3, #127	; 0x7f
 8001566:	d936      	bls.n	80015d6 <NVIC_SetPriority.4097.4486+0x86>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001568:	4933      	ldr	r1, [pc, #204]	; (8001638 <NVIC_SetPriority.4097.4486+0xe8>)
 800156a:	466b      	mov	r3, sp
 800156c:	3307      	adds	r3, #7
 800156e:	781b      	ldrb	r3, [r3, #0]
 8001570:	1c1a      	adds	r2, r3, #0
 8001572:	230f      	movs	r3, #15
 8001574:	4013      	ands	r3, r2
 8001576:	3b08      	subs	r3, #8
 8001578:	0898      	lsrs	r0, r3, #2
 800157a:	4a2f      	ldr	r2, [pc, #188]	; (8001638 <NVIC_SetPriority.4097.4486+0xe8>)
 800157c:	466b      	mov	r3, sp
 800157e:	3307      	adds	r3, #7
 8001580:	781b      	ldrb	r3, [r3, #0]
 8001582:	1c1c      	adds	r4, r3, #0
 8001584:	230f      	movs	r3, #15
 8001586:	4023      	ands	r3, r4
 8001588:	3b08      	subs	r3, #8
 800158a:	089b      	lsrs	r3, r3, #2
 800158c:	3306      	adds	r3, #6
 800158e:	009b      	lsls	r3, r3, #2
 8001590:	18d3      	adds	r3, r2, r3
 8001592:	685b      	ldr	r3, [r3, #4]
 8001594:	466a      	mov	r2, sp
 8001596:	3207      	adds	r2, #7
 8001598:	7812      	ldrb	r2, [r2, #0]
 800159a:	1c14      	adds	r4, r2, #0
 800159c:	2203      	movs	r2, #3
 800159e:	4022      	ands	r2, r4
 80015a0:	00d2      	lsls	r2, r2, #3
 80015a2:	24ff      	movs	r4, #255	; 0xff
 80015a4:	1c25      	adds	r5, r4, #0
 80015a6:	4095      	lsls	r5, r2
 80015a8:	1c2a      	adds	r2, r5, #0
 80015aa:	43d2      	mvns	r2, r2
 80015ac:	401a      	ands	r2, r3
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80015ae:	9b00      	ldr	r3, [sp, #0]
 80015b0:	019c      	lsls	r4, r3, #6
 80015b2:	23ff      	movs	r3, #255	; 0xff
 80015b4:	401c      	ands	r4, r3
 80015b6:	466b      	mov	r3, sp
 80015b8:	3307      	adds	r3, #7
 80015ba:	781b      	ldrb	r3, [r3, #0]
 80015bc:	1c1d      	adds	r5, r3, #0
 80015be:	2303      	movs	r3, #3
 80015c0:	402b      	ands	r3, r5
 80015c2:	00db      	lsls	r3, r3, #3
 80015c4:	1c25      	adds	r5, r4, #0
 80015c6:	409d      	lsls	r5, r3
 80015c8:	1c2b      	adds	r3, r5, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80015ca:	431a      	orrs	r2, r3
 80015cc:	1d83      	adds	r3, r0, #6
 80015ce:	009b      	lsls	r3, r3, #2
 80015d0:	18cb      	adds	r3, r1, r3
 80015d2:	605a      	str	r2, [r3, #4]
 80015d4:	e02d      	b.n	8001632 <NVIC_SetPriority.4097.4486+0xe2>
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80015d6:	4b19      	ldr	r3, [pc, #100]	; (800163c <NVIC_SetPriority.4097.4486+0xec>)
 80015d8:	466a      	mov	r2, sp
 80015da:	3207      	adds	r2, #7
 80015dc:	7812      	ldrb	r2, [r2, #0]
 80015de:	b252      	sxtb	r2, r2
 80015e0:	0892      	lsrs	r2, r2, #2
 80015e2:	4916      	ldr	r1, [pc, #88]	; (800163c <NVIC_SetPriority.4097.4486+0xec>)
 80015e4:	4668      	mov	r0, sp
 80015e6:	3007      	adds	r0, #7
 80015e8:	7800      	ldrb	r0, [r0, #0]
 80015ea:	b240      	sxtb	r0, r0
 80015ec:	0880      	lsrs	r0, r0, #2
 80015ee:	30c0      	adds	r0, #192	; 0xc0
 80015f0:	0080      	lsls	r0, r0, #2
 80015f2:	5841      	ldr	r1, [r0, r1]
 80015f4:	4668      	mov	r0, sp
 80015f6:	3007      	adds	r0, #7
 80015f8:	7800      	ldrb	r0, [r0, #0]
 80015fa:	1c04      	adds	r4, r0, #0
 80015fc:	2003      	movs	r0, #3
 80015fe:	4020      	ands	r0, r4
 8001600:	00c0      	lsls	r0, r0, #3
 8001602:	24ff      	movs	r4, #255	; 0xff
 8001604:	1c25      	adds	r5, r4, #0
 8001606:	4085      	lsls	r5, r0
 8001608:	1c28      	adds	r0, r5, #0
 800160a:	43c0      	mvns	r0, r0
 800160c:	4008      	ands	r0, r1
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800160e:	9900      	ldr	r1, [sp, #0]
 8001610:	018c      	lsls	r4, r1, #6
 8001612:	21ff      	movs	r1, #255	; 0xff
 8001614:	400c      	ands	r4, r1
 8001616:	4669      	mov	r1, sp
 8001618:	3107      	adds	r1, #7
 800161a:	7809      	ldrb	r1, [r1, #0]
 800161c:	1c0d      	adds	r5, r1, #0
 800161e:	2103      	movs	r1, #3
 8001620:	4029      	ands	r1, r5
 8001622:	00c9      	lsls	r1, r1, #3
 8001624:	1c25      	adds	r5, r4, #0
 8001626:	408d      	lsls	r5, r1
 8001628:	1c29      	adds	r1, r5, #0
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800162a:	4301      	orrs	r1, r0
 800162c:	32c0      	adds	r2, #192	; 0xc0
 800162e:	0092      	lsls	r2, r2, #2
 8001630:	50d1      	str	r1, [r2, r3]
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8001632:	b003      	add	sp, #12
 8001634:	bd30      	pop	{r4, r5, pc}
 8001636:	46c0      	nop			; (mov r8, r8)
 8001638:	e000ed00 	.word	0xe000ed00
 800163c:	e000e100 	.word	0xe000e100

08001640 <port_init.4106.4484>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8001640:	b508      	push	{r3, lr}

  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8001642:	2302      	movs	r3, #2
 8001644:	425b      	negs	r3, r3
 8001646:	1c18      	adds	r0, r3, #0
 8001648:	2100      	movs	r1, #0
 800164a:	f7ff ff81 	bl	8001550 <NVIC_SetPriority.4097.4486>
}
 800164e:	bd08      	pop	{r3, pc}

08001650 <port_lock.4117.4475>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001650:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001652:	4770      	bx	lr
 8001654:	46c0      	nop			; (mov r8, r8)
 8001656:	46c0      	nop			; (mov r8, r8)
 8001658:	46c0      	nop			; (mov r8, r8)
 800165a:	46c0      	nop			; (mov r8, r8)
 800165c:	46c0      	nop			; (mov r8, r8)
 800165e:	46c0      	nop			; (mov r8, r8)

08001660 <port_unlock.4119.4473>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001660:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001662:	4770      	bx	lr
 8001664:	46c0      	nop			; (mov r8, r8)
 8001666:	46c0      	nop			; (mov r8, r8)
 8001668:	46c0      	nop			; (mov r8, r8)
 800166a:	46c0      	nop			; (mov r8, r8)
 800166c:	46c0      	nop			; (mov r8, r8)
 800166e:	46c0      	nop			; (mov r8, r8)

08001670 <port_lock_from_isr.4121.4471>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001670:	b508      	push	{r3, lr}

  port_lock();
 8001672:	f7ff ffed 	bl	8001650 <port_lock.4117.4475>
}
 8001676:	bd08      	pop	{r3, pc}
 8001678:	46c0      	nop			; (mov r8, r8)
 800167a:	46c0      	nop			; (mov r8, r8)
 800167c:	46c0      	nop			; (mov r8, r8)
 800167e:	46c0      	nop			; (mov r8, r8)

08001680 <port_unlock_from_isr.4123.4469>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001680:	b508      	push	{r3, lr}

  port_unlock();
 8001682:	f7ff ffed 	bl	8001660 <port_unlock.4119.4473>
}
 8001686:	bd08      	pop	{r3, pc}
 8001688:	46c0      	nop			; (mov r8, r8)
 800168a:	46c0      	nop			; (mov r8, r8)
 800168c:	46c0      	nop			; (mov r8, r8)
 800168e:	46c0      	nop			; (mov r8, r8)

08001690 <port_enable.4127.4465>:
 8001690:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 8001692:	4770      	bx	lr
 8001694:	46c0      	nop			; (mov r8, r8)
 8001696:	46c0      	nop			; (mov r8, r8)
 8001698:	46c0      	nop			; (mov r8, r8)
 800169a:	46c0      	nop			; (mov r8, r8)
 800169c:	46c0      	nop			; (mov r8, r8)
 800169e:	46c0      	nop			; (mov r8, r8)

080016a0 <port_wait_for_interrupt.4129.4463>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 80016a0:	4770      	bx	lr
 80016a2:	46c0      	nop			; (mov r8, r8)
 80016a4:	46c0      	nop			; (mov r8, r8)
 80016a6:	46c0      	nop			; (mov r8, r8)
 80016a8:	46c0      	nop			; (mov r8, r8)
 80016aa:	46c0      	nop			; (mov r8, r8)
 80016ac:	46c0      	nop			; (mov r8, r8)
 80016ae:	46c0      	nop			; (mov r8, r8)

080016b0 <st_lld_get_counter.4131.4461>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80016b0:	4b02      	ldr	r3, [pc, #8]	; (80016bc <st_lld_get_counter.4131.4461+0xc>)
 80016b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80016b4:	b29b      	uxth	r3, r3
}
 80016b6:	1c18      	adds	r0, r3, #0
 80016b8:	4770      	bx	lr
 80016ba:	46c0      	nop			; (mov r8, r8)
 80016bc:	40000400 	.word	0x40000400

080016c0 <port_timer_stop_alarm.4221.4459>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 80016c0:	b508      	push	{r3, lr}

  stStopAlarm();
 80016c2:	f7ff fc75 	bl	8000fb0 <stStopAlarm>
}
 80016c6:	bd08      	pop	{r3, pc}
 80016c8:	46c0      	nop			; (mov r8, r8)
 80016ca:	46c0      	nop			; (mov r8, r8)
 80016cc:	46c0      	nop			; (mov r8, r8)
 80016ce:	46c0      	nop			; (mov r8, r8)

080016d0 <port_timer_set_alarm.4223.4456>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 80016d0:	b500      	push	{lr}
 80016d2:	b083      	sub	sp, #12
 80016d4:	1c02      	adds	r2, r0, #0
 80016d6:	466b      	mov	r3, sp
 80016d8:	3306      	adds	r3, #6
 80016da:	801a      	strh	r2, [r3, #0]

  stSetAlarm(time);
 80016dc:	466b      	mov	r3, sp
 80016de:	3306      	adds	r3, #6
 80016e0:	881b      	ldrh	r3, [r3, #0]
 80016e2:	1c18      	adds	r0, r3, #0
 80016e4:	f7ff fc6c 	bl	8000fc0 <stSetAlarm>
}
 80016e8:	b003      	add	sp, #12
 80016ea:	bd00      	pop	{pc}
 80016ec:	46c0      	nop			; (mov r8, r8)
 80016ee:	46c0      	nop			; (mov r8, r8)

080016f0 <port_timer_get_time.4136.4454>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80016f0:	b508      	push	{r3, lr}

  return stGetCounter();
 80016f2:	f7ff ffdd 	bl	80016b0 <st_lld_get_counter.4131.4461>
 80016f6:	1c03      	adds	r3, r0, #0
}
 80016f8:	1c18      	adds	r0, r3, #0
 80016fa:	bd08      	pop	{r3, pc}
 80016fc:	46c0      	nop			; (mov r8, r8)
 80016fe:	46c0      	nop			; (mov r8, r8)

08001700 <chSysEnable.4138.4452>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8001700:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 8001702:	f7ff ffc5 	bl	8001690 <port_enable.4127.4465>
}
 8001706:	bd08      	pop	{r3, pc}
 8001708:	46c0      	nop			; (mov r8, r8)
 800170a:	46c0      	nop			; (mov r8, r8)
 800170c:	46c0      	nop			; (mov r8, r8)
 800170e:	46c0      	nop			; (mov r8, r8)

08001710 <chSysLockFromISR.4144.4446>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001710:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001712:	f7ff ffad 	bl	8001670 <port_lock_from_isr.4121.4471>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001716:	bd08      	pop	{r3, pc}
 8001718:	46c0      	nop			; (mov r8, r8)
 800171a:	46c0      	nop			; (mov r8, r8)
 800171c:	46c0      	nop			; (mov r8, r8)
 800171e:	46c0      	nop			; (mov r8, r8)

08001720 <chSysUnlockFromISR.4146.4444>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001720:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001722:	f7ff ffad 	bl	8001680 <port_unlock_from_isr.4123.4469>
}
 8001726:	bd08      	pop	{r3, pc}
 8001728:	46c0      	nop			; (mov r8, r8)
 800172a:	46c0      	nop			; (mov r8, r8)
 800172c:	46c0      	nop			; (mov r8, r8)
 800172e:	46c0      	nop			; (mov r8, r8)

08001730 <chVTGetSystemTimeX.4148.4442>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8001730:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8001732:	f7ff ffdd 	bl	80016f0 <port_timer_get_time.4136.4454>
 8001736:	1c03      	adds	r3, r0, #0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001738:	1c18      	adds	r0, r3, #0
 800173a:	bd08      	pop	{r3, pc}
 800173c:	46c0      	nop			; (mov r8, r8)
 800173e:	46c0      	nop			; (mov r8, r8)

08001740 <chVTDoTickI.4226.4440>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8001740:	b510      	push	{r4, lr}
 8001742:	b084      	sub	sp, #16
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8001744:	4b33      	ldr	r3, [pc, #204]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 8001746:	69db      	ldr	r3, [r3, #28]
 8001748:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 800174a:	466c      	mov	r4, sp
 800174c:	340a      	adds	r4, #10
 800174e:	f7ff ffef 	bl	8001730 <chVTGetSystemTimeX.4148.4442>
 8001752:	1c03      	adds	r3, r0, #0
 8001754:	8023      	strh	r3, [r4, #0]
 8001756:	e02e      	b.n	80017b6 <chVTDoTickI.4226.4440+0x76>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001758:	4b2e      	ldr	r3, [pc, #184]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 800175a:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800175c:	9b03      	ldr	r3, [sp, #12]
 800175e:	891b      	ldrh	r3, [r3, #8]
 8001760:	18d3      	adds	r3, r2, r3
 8001762:	b29a      	uxth	r2, r3
 8001764:	4b2b      	ldr	r3, [pc, #172]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 8001766:	84da      	strh	r2, [r3, #38]	; 0x26

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001768:	9b03      	ldr	r3, [sp, #12]
 800176a:	681b      	ldr	r3, [r3, #0]
 800176c:	4a2a      	ldr	r2, [pc, #168]	; (8001818 <chVTDoTickI.4226.4440+0xd8>)
 800176e:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8001770:	9b03      	ldr	r3, [sp, #12]
 8001772:	681a      	ldr	r2, [r3, #0]
 8001774:	4b27      	ldr	r3, [pc, #156]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 8001776:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
 8001778:	9b03      	ldr	r3, [sp, #12]
 800177a:	68db      	ldr	r3, [r3, #12]
 800177c:	9301      	str	r3, [sp, #4]
    vtp->vt_func = NULL;
 800177e:	9b03      	ldr	r3, [sp, #12]
 8001780:	2200      	movs	r2, #0
 8001782:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8001784:	4b23      	ldr	r3, [pc, #140]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 8001786:	69da      	ldr	r2, [r3, #28]
 8001788:	4b23      	ldr	r3, [pc, #140]	; (8001818 <chVTDoTickI.4226.4440+0xd8>)
 800178a:	429a      	cmp	r2, r3
 800178c:	d101      	bne.n	8001792 <chVTDoTickI.4226.4440+0x52>
      port_timer_stop_alarm();
 800178e:	f7ff ff97 	bl	80016c0 <port_timer_stop_alarm.4221.4459>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 8001792:	f7ff ffc5 	bl	8001720 <chSysUnlockFromISR.4146.4444>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8001796:	9b03      	ldr	r3, [sp, #12]
 8001798:	691a      	ldr	r2, [r3, #16]
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	1c10      	adds	r0, r2, #0
 800179e:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 80017a0:	f7ff ffb6 	bl	8001710 <chSysLockFromISR.4144.4446>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 80017a4:	4b1b      	ldr	r3, [pc, #108]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 80017a6:	69db      	ldr	r3, [r3, #28]
 80017a8:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 80017aa:	466c      	mov	r4, sp
 80017ac:	340a      	adds	r4, #10
 80017ae:	f7ff ffbf 	bl	8001730 <chVTGetSystemTimeX.4148.4442>
 80017b2:	1c03      	adds	r3, r0, #0
 80017b4:	8023      	strh	r3, [r4, #0]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80017b6:	9b03      	ldr	r3, [sp, #12]
 80017b8:	891a      	ldrh	r2, [r3, #8]
 80017ba:	4b16      	ldr	r3, [pc, #88]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 80017bc:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 80017be:	4669      	mov	r1, sp
 80017c0:	310a      	adds	r1, #10
 80017c2:	8809      	ldrh	r1, [r1, #0]
 80017c4:	1acb      	subs	r3, r1, r3
 80017c6:	b29b      	uxth	r3, r3
 80017c8:	429a      	cmp	r2, r3
 80017ca:	d9c5      	bls.n	8001758 <chVTDoTickI.4226.4440+0x18>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80017cc:	4b11      	ldr	r3, [pc, #68]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 80017ce:	69da      	ldr	r2, [r3, #28]
 80017d0:	4b11      	ldr	r3, [pc, #68]	; (8001818 <chVTDoTickI.4226.4440+0xd8>)
 80017d2:	429a      	cmp	r2, r3
 80017d4:	d01c      	beq.n	8001810 <chVTDoTickI.4226.4440+0xd0>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 80017d6:	4b0f      	ldr	r3, [pc, #60]	; (8001814 <chVTDoTickI.4226.4440+0xd4>)
 80017d8:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 80017da:	9b03      	ldr	r3, [sp, #12]
 80017dc:	891b      	ldrh	r3, [r3, #8]
 80017de:	18d3      	adds	r3, r2, r3
 80017e0:	b299      	uxth	r1, r3
 80017e2:	ab02      	add	r3, sp, #8
 80017e4:	466a      	mov	r2, sp
 80017e6:	320a      	adds	r2, #10
 80017e8:	8812      	ldrh	r2, [r2, #0]
 80017ea:	1a8a      	subs	r2, r1, r2
 80017ec:	801a      	strh	r2, [r3, #0]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80017ee:	ab02      	add	r3, sp, #8
 80017f0:	881b      	ldrh	r3, [r3, #0]
 80017f2:	2b04      	cmp	r3, #4
 80017f4:	d802      	bhi.n	80017fc <chVTDoTickI.4226.4440+0xbc>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80017f6:	ab02      	add	r3, sp, #8
 80017f8:	2205      	movs	r2, #5
 80017fa:	801a      	strh	r2, [r3, #0]
  }
  port_timer_set_alarm(now + delta);
 80017fc:	466a      	mov	r2, sp
 80017fe:	320a      	adds	r2, #10
 8001800:	ab02      	add	r3, sp, #8
 8001802:	8812      	ldrh	r2, [r2, #0]
 8001804:	881b      	ldrh	r3, [r3, #0]
 8001806:	18d3      	adds	r3, r2, r3
 8001808:	b29b      	uxth	r3, r3
 800180a:	1c18      	adds	r0, r3, #0
 800180c:	f7ff ff60 	bl	80016d0 <port_timer_set_alarm.4223.4456>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001810:	b004      	add	sp, #16
 8001812:	bd10      	pop	{r4, pc}
 8001814:	20000300 	.word	0x20000300
 8001818:	2000031c 	.word	0x2000031c
 800181c:	46c0      	nop			; (mov r8, r8)
 800181e:	46c0      	nop			; (mov r8, r8)

08001820 <chRegSetThreadName.4150.4437>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8001820:	b082      	sub	sp, #8
 8001822:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001824:	4b02      	ldr	r3, [pc, #8]	; (8001830 <chRegSetThreadName.4150.4437+0x10>)
 8001826:	699b      	ldr	r3, [r3, #24]
 8001828:	9a01      	ldr	r2, [sp, #4]
 800182a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800182c:	b002      	add	sp, #8
 800182e:	4770      	bx	lr
 8001830:	20000300 	.word	0x20000300
 8001834:	46c0      	nop			; (mov r8, r8)
 8001836:	46c0      	nop			; (mov r8, r8)
 8001838:	46c0      	nop			; (mov r8, r8)
 800183a:	46c0      	nop			; (mov r8, r8)
 800183c:	46c0      	nop			; (mov r8, r8)
 800183e:	46c0      	nop			; (mov r8, r8)

08001840 <chRegSetThreadNameX.4154.4433>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8001840:	b082      	sub	sp, #8
 8001842:	9001      	str	r0, [sp, #4]
 8001844:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8001846:	9b01      	ldr	r3, [sp, #4]
 8001848:	9a00      	ldr	r2, [sp, #0]
 800184a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800184c:	b002      	add	sp, #8
 800184e:	4770      	bx	lr

08001850 <_idle_thread.4218.4430>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001850:	b500      	push	{lr}
 8001852:	b083      	sub	sp, #12
 8001854:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8001856:	f7ff ff23 	bl	80016a0 <port_wait_for_interrupt.4129.4463>
 800185a:	e7fc      	b.n	8001856 <_idle_thread.4218.4430+0x6>
 800185c:	46c0      	nop			; (mov r8, r8)
 800185e:	46c0      	nop			; (mov r8, r8)

08001860 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8001860:	b500      	push	{lr}
 8001862:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8001864:	f7ff feec 	bl	8001640 <port_init.4106.4484>
  _scheduler_init();
 8001868:	f000 fa12 	bl	8001c90 <_scheduler_init.4355>
  _vt_init();
 800186c:	f000 f880 	bl	8001970 <_vt_init.4398>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8001870:	f7ff fa5e 	bl	8000d30 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8001874:	f7ff fab4 	bl	8000de0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8001878:	4b12      	ldr	r3, [pc, #72]	; (80018c4 <chSysInit+0x64>)
 800187a:	1c18      	adds	r0, r3, #0
 800187c:	2140      	movs	r1, #64	; 0x40
 800187e:	f000 fc17 	bl	80020b0 <_thread_init.4256>
 8001882:	1c02      	adds	r2, r0, #0
 8001884:	4b10      	ldr	r3, [pc, #64]	; (80018c8 <chSysInit+0x68>)
 8001886:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8001888:	4b0f      	ldr	r3, [pc, #60]	; (80018c8 <chSysInit+0x68>)
 800188a:	699b      	ldr	r3, [r3, #24]
 800188c:	2201      	movs	r2, #1
 800188e:	771a      	strb	r2, [r3, #28]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 8001890:	f7ff ff36 	bl	8001700 <chSysEnable.4138.4452>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 8001894:	4b0d      	ldr	r3, [pc, #52]	; (80018cc <chSysInit+0x6c>)
 8001896:	1c18      	adds	r0, r3, #0
 8001898:	f7ff ffc2 	bl	8001820 <chRegSetThreadName.4150.4437>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 800189c:	4a0c      	ldr	r2, [pc, #48]	; (80018d0 <chSysInit+0x70>)
 800189e:	4b0d      	ldr	r3, [pc, #52]	; (80018d4 <chSysInit+0x74>)
 80018a0:	2100      	movs	r1, #0
 80018a2:	9100      	str	r1, [sp, #0]
 80018a4:	1c10      	adds	r0, r2, #0
 80018a6:	21c8      	movs	r1, #200	; 0xc8
 80018a8:	2201      	movs	r2, #1
 80018aa:	f000 fc59 	bl	8002160 <chThdCreateStatic.4239>
 80018ae:	1c03      	adds	r3, r0, #0
 80018b0:	9303      	str	r3, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 80018b2:	9a03      	ldr	r2, [sp, #12]
 80018b4:	4b08      	ldr	r3, [pc, #32]	; (80018d8 <chSysInit+0x78>)
 80018b6:	1c10      	adds	r0, r2, #0
 80018b8:	1c19      	adds	r1, r3, #0
 80018ba:	f7ff ffc1 	bl	8001840 <chRegSetThreadNameX.4154.4433>
  }
#endif
}
 80018be:	b005      	add	sp, #20
 80018c0:	bd00      	pop	{pc}
 80018c2:	46c0      	nop			; (mov r8, r8)
 80018c4:	2000032c 	.word	0x2000032c
 80018c8:	20000300 	.word	0x20000300
 80018cc:	08002300 	.word	0x08002300
 80018d0:	20000360 	.word	0x20000360
 80018d4:	08001851 	.word	0x08001851
 80018d8:	080022f0 	.word	0x080022f0
 80018dc:	46c0      	nop			; (mov r8, r8)
 80018de:	46c0      	nop			; (mov r8, r8)

080018e0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80018e0:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 80018e2:	f7ff ff2d 	bl	8001740 <chVTDoTickI.4226.4440>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 80018e6:	bd08      	pop	{r3, pc}
 80018e8:	46c0      	nop			; (mov r8, r8)
 80018ea:	46c0      	nop			; (mov r8, r8)
 80018ec:	46c0      	nop			; (mov r8, r8)
 80018ee:	46c0      	nop			; (mov r8, r8)

080018f0 <st_lld_get_counter.4377.4412>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80018f0:	4b02      	ldr	r3, [pc, #8]	; (80018fc <st_lld_get_counter.4377.4412+0xc>)
 80018f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80018f4:	b29b      	uxth	r3, r3
}
 80018f6:	1c18      	adds	r0, r3, #0
 80018f8:	4770      	bx	lr
 80018fa:	46c0      	nop			; (mov r8, r8)
 80018fc:	40000400 	.word	0x40000400

08001900 <port_timer_start_alarm.4387.4409>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8001900:	b500      	push	{lr}
 8001902:	b083      	sub	sp, #12
 8001904:	1c02      	adds	r2, r0, #0
 8001906:	466b      	mov	r3, sp
 8001908:	3306      	adds	r3, #6
 800190a:	801a      	strh	r2, [r3, #0]

  stStartAlarm(time);
 800190c:	466b      	mov	r3, sp
 800190e:	3306      	adds	r3, #6
 8001910:	881b      	ldrh	r3, [r3, #0]
 8001912:	1c18      	adds	r0, r3, #0
 8001914:	f7ff fb3c 	bl	8000f90 <stStartAlarm>
}
 8001918:	b003      	add	sp, #12
 800191a:	bd00      	pop	{pc}
 800191c:	46c0      	nop			; (mov r8, r8)
 800191e:	46c0      	nop			; (mov r8, r8)

08001920 <port_timer_stop_alarm.4393.4407>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8001920:	b508      	push	{r3, lr}

  stStopAlarm();
 8001922:	f7ff fb45 	bl	8000fb0 <stStopAlarm>
}
 8001926:	bd08      	pop	{r3, pc}
 8001928:	46c0      	nop			; (mov r8, r8)
 800192a:	46c0      	nop			; (mov r8, r8)
 800192c:	46c0      	nop			; (mov r8, r8)
 800192e:	46c0      	nop			; (mov r8, r8)

08001930 <port_timer_set_alarm.4390.4404>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8001930:	b500      	push	{lr}
 8001932:	b083      	sub	sp, #12
 8001934:	1c02      	adds	r2, r0, #0
 8001936:	466b      	mov	r3, sp
 8001938:	3306      	adds	r3, #6
 800193a:	801a      	strh	r2, [r3, #0]

  stSetAlarm(time);
 800193c:	466b      	mov	r3, sp
 800193e:	3306      	adds	r3, #6
 8001940:	881b      	ldrh	r3, [r3, #0]
 8001942:	1c18      	adds	r0, r3, #0
 8001944:	f7ff fb3c 	bl	8000fc0 <stSetAlarm>
}
 8001948:	b003      	add	sp, #12
 800194a:	bd00      	pop	{pc}
 800194c:	46c0      	nop			; (mov r8, r8)
 800194e:	46c0      	nop			; (mov r8, r8)

08001950 <port_timer_get_time.4383.4402>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8001950:	b508      	push	{r3, lr}

  return stGetCounter();
 8001952:	f7ff ffcd 	bl	80018f0 <st_lld_get_counter.4377.4412>
 8001956:	1c03      	adds	r3, r0, #0
}
 8001958:	1c18      	adds	r0, r3, #0
 800195a:	bd08      	pop	{r3, pc}
 800195c:	46c0      	nop			; (mov r8, r8)
 800195e:	46c0      	nop			; (mov r8, r8)

08001960 <chVTGetSystemTimeX.4385.4400>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8001960:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8001962:	f7ff fff5 	bl	8001950 <port_timer_get_time.4383.4402>
 8001966:	1c03      	adds	r3, r0, #0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001968:	1c18      	adds	r0, r3, #0
 800196a:	bd08      	pop	{r3, pc}
 800196c:	46c0      	nop			; (mov r8, r8)
 800196e:	46c0      	nop			; (mov r8, r8)

08001970 <_vt_init.4398>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001970:	4b06      	ldr	r3, [pc, #24]	; (800198c <_vt_init.4398+0x1c>)
 8001972:	4a07      	ldr	r2, [pc, #28]	; (8001990 <_vt_init.4398+0x20>)
 8001974:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001976:	4b05      	ldr	r3, [pc, #20]	; (800198c <_vt_init.4398+0x1c>)
 8001978:	4a05      	ldr	r2, [pc, #20]	; (8001990 <_vt_init.4398+0x20>)
 800197a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800197c:	4b03      	ldr	r3, [pc, #12]	; (800198c <_vt_init.4398+0x1c>)
 800197e:	2201      	movs	r2, #1
 8001980:	4252      	negs	r2, r2
 8001982:	849a      	strh	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8001984:	4b01      	ldr	r3, [pc, #4]	; (800198c <_vt_init.4398+0x1c>)
 8001986:	2200      	movs	r2, #0
 8001988:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800198a:	4770      	bx	lr
 800198c:	20000300 	.word	0x20000300
 8001990:	2000031c 	.word	0x2000031c
 8001994:	46c0      	nop			; (mov r8, r8)
 8001996:	46c0      	nop			; (mov r8, r8)
 8001998:	46c0      	nop			; (mov r8, r8)
 800199a:	46c0      	nop			; (mov r8, r8)
 800199c:	46c0      	nop			; (mov r8, r8)
 800199e:	46c0      	nop			; (mov r8, r8)

080019a0 <chVTDoSetI.4392>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80019a0:	b510      	push	{r4, lr}
 80019a2:	b086      	sub	sp, #24
 80019a4:	9003      	str	r0, [sp, #12]
 80019a6:	9201      	str	r2, [sp, #4]
 80019a8:	9300      	str	r3, [sp, #0]
 80019aa:	466b      	mov	r3, sp
 80019ac:	330a      	adds	r3, #10
 80019ae:	1c0a      	adds	r2, r1, #0
 80019b0:	801a      	strh	r2, [r3, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80019b2:	9b03      	ldr	r3, [sp, #12]
 80019b4:	9a00      	ldr	r2, [sp, #0]
 80019b6:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 80019b8:	9b03      	ldr	r3, [sp, #12]
 80019ba:	9a01      	ldr	r2, [sp, #4]
 80019bc:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 80019be:	ac04      	add	r4, sp, #16
 80019c0:	f7ff ffce 	bl	8001960 <chVTGetSystemTimeX.4385.4400>
 80019c4:	1c03      	adds	r3, r0, #0
 80019c6:	8023      	strh	r3, [r4, #0]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80019c8:	466b      	mov	r3, sp
 80019ca:	330a      	adds	r3, #10
 80019cc:	881b      	ldrh	r3, [r3, #0]
 80019ce:	2b04      	cmp	r3, #4
 80019d0:	d803      	bhi.n	80019da <chVTDoSetI.4392+0x3a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80019d2:	466b      	mov	r3, sp
 80019d4:	330a      	adds	r3, #10
 80019d6:	2205      	movs	r2, #5
 80019d8:	801a      	strh	r2, [r3, #0]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80019da:	4b3f      	ldr	r3, [pc, #252]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 80019dc:	69da      	ldr	r2, [r3, #28]
 80019de:	4b3f      	ldr	r3, [pc, #252]	; (8001adc <chVTDoSetI.4392+0x13c>)
 80019e0:	429a      	cmp	r2, r3
 80019e2:	d11f      	bne.n	8001a24 <chVTDoSetI.4392+0x84>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 80019e4:	4b3c      	ldr	r3, [pc, #240]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 80019e6:	aa04      	add	r2, sp, #16
 80019e8:	8812      	ldrh	r2, [r2, #0]
 80019ea:	84da      	strh	r2, [r3, #38]	; 0x26
      ch.vtlist.vt_next = vtp;
 80019ec:	4b3a      	ldr	r3, [pc, #232]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 80019ee:	9a03      	ldr	r2, [sp, #12]
 80019f0:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
 80019f2:	4b39      	ldr	r3, [pc, #228]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 80019f4:	9a03      	ldr	r2, [sp, #12]
 80019f6:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 80019f8:	9b03      	ldr	r3, [sp, #12]
 80019fa:	4a38      	ldr	r2, [pc, #224]	; (8001adc <chVTDoSetI.4392+0x13c>)
 80019fc:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80019fe:	9b03      	ldr	r3, [sp, #12]
 8001a00:	4a36      	ldr	r2, [pc, #216]	; (8001adc <chVTDoSetI.4392+0x13c>)
 8001a02:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 8001a04:	9b03      	ldr	r3, [sp, #12]
 8001a06:	466a      	mov	r2, sp
 8001a08:	320a      	adds	r2, #10
 8001a0a:	8812      	ldrh	r2, [r2, #0]
 8001a0c:	811a      	strh	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8001a0e:	4b32      	ldr	r3, [pc, #200]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 8001a10:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001a12:	466b      	mov	r3, sp
 8001a14:	330a      	adds	r3, #10
 8001a16:	881b      	ldrh	r3, [r3, #0]
 8001a18:	18d3      	adds	r3, r2, r3
 8001a1a:	b29b      	uxth	r3, r3
 8001a1c:	1c18      	adds	r0, r3, #0
 8001a1e:	f7ff ff6f 	bl	8001900 <port_timer_start_alarm.4387.4409>
 8001a22:	e056      	b.n	8001ad2 <chVTDoSetI.4392+0x132>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001a24:	aa04      	add	r2, sp, #16
 8001a26:	466b      	mov	r3, sp
 8001a28:	330a      	adds	r3, #10
 8001a2a:	8812      	ldrh	r2, [r2, #0]
 8001a2c:	881b      	ldrh	r3, [r3, #0]
 8001a2e:	18d3      	adds	r3, r2, r3
 8001a30:	b299      	uxth	r1, r3
 8001a32:	4b29      	ldr	r3, [pc, #164]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 8001a34:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001a36:	466b      	mov	r3, sp
 8001a38:	3312      	adds	r3, #18
 8001a3a:	1a8a      	subs	r2, r1, r2
 8001a3c:	801a      	strh	r2, [r3, #0]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001a3e:	4b26      	ldr	r3, [pc, #152]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 8001a40:	69db      	ldr	r3, [r3, #28]
 8001a42:	891b      	ldrh	r3, [r3, #8]
 8001a44:	466a      	mov	r2, sp
 8001a46:	3212      	adds	r2, #18
 8001a48:	8812      	ldrh	r2, [r2, #0]
 8001a4a:	429a      	cmp	r2, r3
 8001a4c:	d209      	bcs.n	8001a62 <chVTDoSetI.4392+0xc2>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 8001a4e:	4b22      	ldr	r3, [pc, #136]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 8001a50:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001a52:	466b      	mov	r3, sp
 8001a54:	3312      	adds	r3, #18
 8001a56:	881b      	ldrh	r3, [r3, #0]
 8001a58:	18d3      	adds	r3, r2, r3
 8001a5a:	b29b      	uxth	r3, r3
 8001a5c:	1c18      	adds	r0, r3, #0
 8001a5e:	f7ff ff67 	bl	8001930 <port_timer_set_alarm.4390.4404>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8001a62:	4b1d      	ldr	r3, [pc, #116]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 8001a64:	69db      	ldr	r3, [r3, #28]
 8001a66:	9305      	str	r3, [sp, #20]
 8001a68:	e00b      	b.n	8001a82 <chVTDoSetI.4392+0xe2>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001a6a:	9b05      	ldr	r3, [sp, #20]
 8001a6c:	891a      	ldrh	r2, [r3, #8]
 8001a6e:	466b      	mov	r3, sp
 8001a70:	3312      	adds	r3, #18
 8001a72:	4669      	mov	r1, sp
 8001a74:	3112      	adds	r1, #18
 8001a76:	8809      	ldrh	r1, [r1, #0]
 8001a78:	1a8a      	subs	r2, r1, r2
 8001a7a:	801a      	strh	r2, [r3, #0]
    p = p->vt_next;
 8001a7c:	9b05      	ldr	r3, [sp, #20]
 8001a7e:	681b      	ldr	r3, [r3, #0]
 8001a80:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001a82:	9b05      	ldr	r3, [sp, #20]
 8001a84:	891b      	ldrh	r3, [r3, #8]
 8001a86:	466a      	mov	r2, sp
 8001a88:	3212      	adds	r2, #18
 8001a8a:	8812      	ldrh	r2, [r2, #0]
 8001a8c:	429a      	cmp	r2, r3
 8001a8e:	d8ec      	bhi.n	8001a6a <chVTDoSetI.4392+0xca>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8001a90:	9b03      	ldr	r3, [sp, #12]
 8001a92:	9a05      	ldr	r2, [sp, #20]
 8001a94:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001a96:	9b03      	ldr	r3, [sp, #12]
 8001a98:	681b      	ldr	r3, [r3, #0]
 8001a9a:	685a      	ldr	r2, [r3, #4]
 8001a9c:	9b03      	ldr	r3, [sp, #12]
 8001a9e:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 8001aa0:	9b03      	ldr	r3, [sp, #12]
 8001aa2:	685b      	ldr	r3, [r3, #4]
 8001aa4:	9a03      	ldr	r2, [sp, #12]
 8001aa6:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 8001aa8:	9b05      	ldr	r3, [sp, #20]
 8001aaa:	9a03      	ldr	r2, [sp, #12]
 8001aac:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 8001aae:	9b03      	ldr	r3, [sp, #12]
 8001ab0:	466a      	mov	r2, sp
 8001ab2:	3212      	adds	r2, #18
 8001ab4:	8812      	ldrh	r2, [r2, #0]
 8001ab6:	811a      	strh	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001ab8:	9b05      	ldr	r3, [sp, #20]
 8001aba:	891a      	ldrh	r2, [r3, #8]
 8001abc:	466b      	mov	r3, sp
 8001abe:	3312      	adds	r3, #18
 8001ac0:	881b      	ldrh	r3, [r3, #0]
 8001ac2:	1ad3      	subs	r3, r2, r3
 8001ac4:	b29a      	uxth	r2, r3
 8001ac6:	9b05      	ldr	r3, [sp, #20]
 8001ac8:	811a      	strh	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001aca:	4b03      	ldr	r3, [pc, #12]	; (8001ad8 <chVTDoSetI.4392+0x138>)
 8001acc:	2201      	movs	r2, #1
 8001ace:	4252      	negs	r2, r2
 8001ad0:	849a      	strh	r2, [r3, #36]	; 0x24
}
 8001ad2:	b006      	add	sp, #24
 8001ad4:	bd10      	pop	{r4, pc}
 8001ad6:	46c0      	nop			; (mov r8, r8)
 8001ad8:	20000300 	.word	0x20000300
 8001adc:	2000031c 	.word	0x2000031c

08001ae0 <chVTDoResetI.4388>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001ae0:	b500      	push	{lr}
 8001ae2:	b085      	sub	sp, #20
 8001ae4:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8001ae6:	4b38      	ldr	r3, [pc, #224]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001ae8:	69da      	ldr	r2, [r3, #28]
 8001aea:	9b01      	ldr	r3, [sp, #4]
 8001aec:	429a      	cmp	r2, r3
 8001aee:	d01c      	beq.n	8001b2a <chVTDoResetI.4388+0x4a>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8001af0:	9b01      	ldr	r3, [sp, #4]
 8001af2:	685b      	ldr	r3, [r3, #4]
 8001af4:	9a01      	ldr	r2, [sp, #4]
 8001af6:	6812      	ldr	r2, [r2, #0]
 8001af8:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8001afa:	9b01      	ldr	r3, [sp, #4]
 8001afc:	681b      	ldr	r3, [r3, #0]
 8001afe:	9a01      	ldr	r2, [sp, #4]
 8001b00:	6852      	ldr	r2, [r2, #4]
 8001b02:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8001b04:	9b01      	ldr	r3, [sp, #4]
 8001b06:	2200      	movs	r2, #0
 8001b08:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001b0a:	9b01      	ldr	r3, [sp, #4]
 8001b0c:	681a      	ldr	r2, [r3, #0]
 8001b0e:	4b2f      	ldr	r3, [pc, #188]	; (8001bcc <chVTDoResetI.4388+0xec>)
 8001b10:	429a      	cmp	r2, r3
 8001b12:	d057      	beq.n	8001bc4 <chVTDoResetI.4388+0xe4>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8001b14:	9b01      	ldr	r3, [sp, #4]
 8001b16:	681a      	ldr	r2, [r3, #0]
 8001b18:	9b01      	ldr	r3, [sp, #4]
 8001b1a:	681b      	ldr	r3, [r3, #0]
 8001b1c:	8919      	ldrh	r1, [r3, #8]
 8001b1e:	9b01      	ldr	r3, [sp, #4]
 8001b20:	891b      	ldrh	r3, [r3, #8]
 8001b22:	18cb      	adds	r3, r1, r3
 8001b24:	b29b      	uxth	r3, r3
 8001b26:	8113      	strh	r3, [r2, #8]
 8001b28:	e04c      	b.n	8001bc4 <chVTDoResetI.4388+0xe4>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8001b2a:	9b01      	ldr	r3, [sp, #4]
 8001b2c:	681a      	ldr	r2, [r3, #0]
 8001b2e:	4b26      	ldr	r3, [pc, #152]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001b30:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001b32:	4b25      	ldr	r3, [pc, #148]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001b34:	69db      	ldr	r3, [r3, #28]
 8001b36:	4a25      	ldr	r2, [pc, #148]	; (8001bcc <chVTDoResetI.4388+0xec>)
 8001b38:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8001b3a:	9b01      	ldr	r3, [sp, #4]
 8001b3c:	2200      	movs	r2, #0
 8001b3e:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001b40:	4b21      	ldr	r3, [pc, #132]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001b42:	69da      	ldr	r2, [r3, #28]
 8001b44:	4b21      	ldr	r3, [pc, #132]	; (8001bcc <chVTDoResetI.4388+0xec>)
 8001b46:	429a      	cmp	r2, r3
 8001b48:	d102      	bne.n	8001b50 <chVTDoResetI.4388+0x70>
    port_timer_stop_alarm();
 8001b4a:	f7ff fee9 	bl	8001920 <port_timer_stop_alarm.4393.4407>
 8001b4e:	e039      	b.n	8001bc4 <chVTDoResetI.4388+0xe4>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8001b50:	4b1d      	ldr	r3, [pc, #116]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001b52:	69da      	ldr	r2, [r3, #28]
 8001b54:	4b1c      	ldr	r3, [pc, #112]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001b56:	69db      	ldr	r3, [r3, #28]
 8001b58:	8919      	ldrh	r1, [r3, #8]
 8001b5a:	9b01      	ldr	r3, [sp, #4]
 8001b5c:	891b      	ldrh	r3, [r3, #8]
 8001b5e:	18cb      	adds	r3, r1, r3
 8001b60:	b29b      	uxth	r3, r3
 8001b62:	8113      	strh	r3, [r2, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8001b64:	f7ff fefc 	bl	8001960 <chVTGetSystemTimeX.4385.4400>
 8001b68:	1c03      	adds	r3, r0, #0
 8001b6a:	1c19      	adds	r1, r3, #0
 8001b6c:	4b16      	ldr	r3, [pc, #88]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001b6e:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001b70:	ab03      	add	r3, sp, #12
 8001b72:	1a8a      	subs	r2, r1, r2
 8001b74:	801a      	strh	r2, [r3, #0]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8001b76:	4b14      	ldr	r3, [pc, #80]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001b78:	69db      	ldr	r3, [r3, #28]
 8001b7a:	891b      	ldrh	r3, [r3, #8]
 8001b7c:	aa03      	add	r2, sp, #12
 8001b7e:	8812      	ldrh	r2, [r2, #0]
 8001b80:	429a      	cmp	r2, r3
 8001b82:	d21f      	bcs.n	8001bc4 <chVTDoResetI.4388+0xe4>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8001b84:	4b10      	ldr	r3, [pc, #64]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001b86:	69db      	ldr	r3, [r3, #28]
 8001b88:	8919      	ldrh	r1, [r3, #8]
 8001b8a:	466b      	mov	r3, sp
 8001b8c:	330e      	adds	r3, #14
 8001b8e:	aa03      	add	r2, sp, #12
 8001b90:	8812      	ldrh	r2, [r2, #0]
 8001b92:	1a8a      	subs	r2, r1, r2
 8001b94:	801a      	strh	r2, [r3, #0]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8001b96:	466b      	mov	r3, sp
 8001b98:	330e      	adds	r3, #14
 8001b9a:	881b      	ldrh	r3, [r3, #0]
 8001b9c:	2b04      	cmp	r3, #4
 8001b9e:	d803      	bhi.n	8001ba8 <chVTDoResetI.4388+0xc8>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001ba0:	466b      	mov	r3, sp
 8001ba2:	330e      	adds	r3, #14
 8001ba4:	2205      	movs	r2, #5
 8001ba6:	801a      	strh	r2, [r3, #0]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8001ba8:	4b07      	ldr	r3, [pc, #28]	; (8001bc8 <chVTDoResetI.4388+0xe8>)
 8001baa:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001bac:	ab03      	add	r3, sp, #12
 8001bae:	881b      	ldrh	r3, [r3, #0]
 8001bb0:	18d3      	adds	r3, r2, r3
 8001bb2:	b29a      	uxth	r2, r3
 8001bb4:	466b      	mov	r3, sp
 8001bb6:	330e      	adds	r3, #14
 8001bb8:	881b      	ldrh	r3, [r3, #0]
 8001bba:	18d3      	adds	r3, r2, r3
 8001bbc:	b29b      	uxth	r3, r3
 8001bbe:	1c18      	adds	r0, r3, #0
 8001bc0:	f7ff feb6 	bl	8001930 <port_timer_set_alarm.4390.4404>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001bc4:	b005      	add	sp, #20
 8001bc6:	bd00      	pop	{pc}
 8001bc8:	20000300 	.word	0x20000300
 8001bcc:	2000031c 	.word	0x2000031c

08001bd0 <port_lock.4537.4386>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001bd0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001bd2:	4770      	bx	lr
 8001bd4:	46c0      	nop			; (mov r8, r8)
 8001bd6:	46c0      	nop			; (mov r8, r8)
 8001bd8:	46c0      	nop			; (mov r8, r8)
 8001bda:	46c0      	nop			; (mov r8, r8)
 8001bdc:	46c0      	nop			; (mov r8, r8)
 8001bde:	46c0      	nop			; (mov r8, r8)

08001be0 <port_unlock.4540.4384>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001be0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001be2:	4770      	bx	lr
 8001be4:	46c0      	nop			; (mov r8, r8)
 8001be6:	46c0      	nop			; (mov r8, r8)
 8001be8:	46c0      	nop			; (mov r8, r8)
 8001bea:	46c0      	nop			; (mov r8, r8)
 8001bec:	46c0      	nop			; (mov r8, r8)
 8001bee:	46c0      	nop			; (mov r8, r8)

08001bf0 <port_lock_from_isr.4542.4382>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001bf0:	b508      	push	{r3, lr}

  port_lock();
 8001bf2:	f7ff ffed 	bl	8001bd0 <port_lock.4537.4386>
}
 8001bf6:	bd08      	pop	{r3, pc}
 8001bf8:	46c0      	nop			; (mov r8, r8)
 8001bfa:	46c0      	nop			; (mov r8, r8)
 8001bfc:	46c0      	nop			; (mov r8, r8)
 8001bfe:	46c0      	nop			; (mov r8, r8)

08001c00 <port_unlock_from_isr.4544.4380>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001c00:	b508      	push	{r3, lr}

  port_unlock();
 8001c02:	f7ff ffed 	bl	8001be0 <port_unlock.4540.4384>
}
 8001c06:	bd08      	pop	{r3, pc}
 8001c08:	46c0      	nop			; (mov r8, r8)
 8001c0a:	46c0      	nop			; (mov r8, r8)
 8001c0c:	46c0      	nop			; (mov r8, r8)
 8001c0e:	46c0      	nop			; (mov r8, r8)

08001c10 <queue_init.4546.4377>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001c10:	b082      	sub	sp, #8
 8001c12:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001c14:	9b01      	ldr	r3, [sp, #4]
 8001c16:	9a01      	ldr	r2, [sp, #4]
 8001c18:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001c1a:	9b01      	ldr	r3, [sp, #4]
 8001c1c:	9a01      	ldr	r2, [sp, #4]
 8001c1e:	605a      	str	r2, [r3, #4]
}
 8001c20:	b002      	add	sp, #8
 8001c22:	4770      	bx	lr
 8001c24:	46c0      	nop			; (mov r8, r8)
 8001c26:	46c0      	nop			; (mov r8, r8)
 8001c28:	46c0      	nop			; (mov r8, r8)
 8001c2a:	46c0      	nop			; (mov r8, r8)
 8001c2c:	46c0      	nop			; (mov r8, r8)
 8001c2e:	46c0      	nop			; (mov r8, r8)

08001c30 <chSysLockFromISR.4615.4373>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001c30:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001c32:	f7ff ffdd 	bl	8001bf0 <port_lock_from_isr.4542.4382>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001c36:	bd08      	pop	{r3, pc}
 8001c38:	46c0      	nop			; (mov r8, r8)
 8001c3a:	46c0      	nop			; (mov r8, r8)
 8001c3c:	46c0      	nop			; (mov r8, r8)
 8001c3e:	46c0      	nop			; (mov r8, r8)

08001c40 <chSysUnlockFromISR.4617.4371>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001c40:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001c42:	f7ff ffdd 	bl	8001c00 <port_unlock_from_isr.4544.4380>
}
 8001c46:	bd08      	pop	{r3, pc}
 8001c48:	46c0      	nop			; (mov r8, r8)
 8001c4a:	46c0      	nop			; (mov r8, r8)
 8001c4c:	46c0      	nop			; (mov r8, r8)
 8001c4e:	46c0      	nop			; (mov r8, r8)

08001c50 <chVTIsArmedI.4619.4360>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8001c50:	b082      	sub	sp, #8
 8001c52:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8001c54:	9b01      	ldr	r3, [sp, #4]
 8001c56:	68db      	ldr	r3, [r3, #12]
 8001c58:	1e5a      	subs	r2, r3, #1
 8001c5a:	4193      	sbcs	r3, r2
 8001c5c:	b2db      	uxtb	r3, r3
}
 8001c5e:	1c18      	adds	r0, r3, #0
 8001c60:	b002      	add	sp, #8
 8001c62:	4770      	bx	lr
 8001c64:	46c0      	nop			; (mov r8, r8)
 8001c66:	46c0      	nop			; (mov r8, r8)
 8001c68:	46c0      	nop			; (mov r8, r8)
 8001c6a:	46c0      	nop			; (mov r8, r8)
 8001c6c:	46c0      	nop			; (mov r8, r8)
 8001c6e:	46c0      	nop			; (mov r8, r8)

08001c70 <chSemFastSignalI.4633.4357>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8001c70:	b082      	sub	sp, #8
 8001c72:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8001c74:	9b01      	ldr	r3, [sp, #4]
 8001c76:	689b      	ldr	r3, [r3, #8]
 8001c78:	1c5a      	adds	r2, r3, #1
 8001c7a:	9b01      	ldr	r3, [sp, #4]
 8001c7c:	609a      	str	r2, [r3, #8]
}
 8001c7e:	b002      	add	sp, #8
 8001c80:	4770      	bx	lr
 8001c82:	46c0      	nop			; (mov r8, r8)
 8001c84:	46c0      	nop			; (mov r8, r8)
 8001c86:	46c0      	nop			; (mov r8, r8)
 8001c88:	46c0      	nop			; (mov r8, r8)
 8001c8a:	46c0      	nop			; (mov r8, r8)
 8001c8c:	46c0      	nop			; (mov r8, r8)
 8001c8e:	46c0      	nop			; (mov r8, r8)

08001c90 <_scheduler_init.4355>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8001c90:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8001c92:	4b07      	ldr	r3, [pc, #28]	; (8001cb0 <_scheduler_init.4355+0x20>)
 8001c94:	1c18      	adds	r0, r3, #0
 8001c96:	f7ff ffbb 	bl	8001c10 <queue_init.4546.4377>
  ch.rlist.r_prio = NOPRIO;
 8001c9a:	4b05      	ldr	r3, [pc, #20]	; (8001cb0 <_scheduler_init.4355+0x20>)
 8001c9c:	2200      	movs	r2, #0
 8001c9e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8001ca0:	4b03      	ldr	r3, [pc, #12]	; (8001cb0 <_scheduler_init.4355+0x20>)
 8001ca2:	4a03      	ldr	r2, [pc, #12]	; (8001cb0 <_scheduler_init.4355+0x20>)
 8001ca4:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8001ca6:	4b02      	ldr	r3, [pc, #8]	; (8001cb0 <_scheduler_init.4355+0x20>)
 8001ca8:	4a01      	ldr	r2, [pc, #4]	; (8001cb0 <_scheduler_init.4355+0x20>)
 8001caa:	615a      	str	r2, [r3, #20]
#endif
}
 8001cac:	bd08      	pop	{r3, pc}
 8001cae:	46c0      	nop			; (mov r8, r8)
 8001cb0:	20000300 	.word	0x20000300
 8001cb4:	46c0      	nop			; (mov r8, r8)
 8001cb6:	46c0      	nop			; (mov r8, r8)
 8001cb8:	46c0      	nop			; (mov r8, r8)
 8001cba:	46c0      	nop			; (mov r8, r8)
 8001cbc:	46c0      	nop			; (mov r8, r8)
 8001cbe:	46c0      	nop			; (mov r8, r8)

08001cc0 <queue_insert.4347>:
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8001cc0:	b082      	sub	sp, #8
 8001cc2:	9001      	str	r0, [sp, #4]
 8001cc4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8001cc6:	9b01      	ldr	r3, [sp, #4]
 8001cc8:	9a00      	ldr	r2, [sp, #0]
 8001cca:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8001ccc:	9b00      	ldr	r3, [sp, #0]
 8001cce:	685a      	ldr	r2, [r3, #4]
 8001cd0:	9b01      	ldr	r3, [sp, #4]
 8001cd2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001cd4:	9b01      	ldr	r3, [sp, #4]
 8001cd6:	685b      	ldr	r3, [r3, #4]
 8001cd8:	9a01      	ldr	r2, [sp, #4]
 8001cda:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8001cdc:	9b00      	ldr	r3, [sp, #0]
 8001cde:	9a01      	ldr	r2, [sp, #4]
 8001ce0:	605a      	str	r2, [r3, #4]
}
 8001ce2:	b002      	add	sp, #8
 8001ce4:	4770      	bx	lr
 8001ce6:	46c0      	nop			; (mov r8, r8)
 8001ce8:	46c0      	nop			; (mov r8, r8)
 8001cea:	46c0      	nop			; (mov r8, r8)
 8001cec:	46c0      	nop			; (mov r8, r8)
 8001cee:	46c0      	nop			; (mov r8, r8)

08001cf0 <queue_fifo_remove>:
 * @param[in] tqp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001cf0:	b084      	sub	sp, #16
 8001cf2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001cf4:	9b01      	ldr	r3, [sp, #4]
 8001cf6:	681b      	ldr	r3, [r3, #0]
 8001cf8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001cfa:	9b03      	ldr	r3, [sp, #12]
 8001cfc:	681a      	ldr	r2, [r3, #0]
 8001cfe:	9b01      	ldr	r3, [sp, #4]
 8001d00:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001d02:	9b01      	ldr	r3, [sp, #4]
 8001d04:	681b      	ldr	r3, [r3, #0]
 8001d06:	9a01      	ldr	r2, [sp, #4]
 8001d08:	605a      	str	r2, [r3, #4]

  return tp;
 8001d0a:	9b03      	ldr	r3, [sp, #12]
}
 8001d0c:	1c18      	adds	r0, r3, #0
 8001d0e:	b004      	add	sp, #16
 8001d10:	4770      	bx	lr
 8001d12:	46c0      	nop			; (mov r8, r8)
 8001d14:	46c0      	nop			; (mov r8, r8)
 8001d16:	46c0      	nop			; (mov r8, r8)
 8001d18:	46c0      	nop			; (mov r8, r8)
 8001d1a:	46c0      	nop			; (mov r8, r8)
 8001d1c:	46c0      	nop			; (mov r8, r8)
 8001d1e:	46c0      	nop			; (mov r8, r8)

08001d20 <queue_dequeue>:
 * @param[in] tp        the pointer to the thread to be removed from the queue
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_dequeue(thread_t *tp) {
 8001d20:	b082      	sub	sp, #8
 8001d22:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8001d24:	9b01      	ldr	r3, [sp, #4]
 8001d26:	685b      	ldr	r3, [r3, #4]
 8001d28:	9a01      	ldr	r2, [sp, #4]
 8001d2a:	6812      	ldr	r2, [r2, #0]
 8001d2c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001d2e:	9b01      	ldr	r3, [sp, #4]
 8001d30:	681b      	ldr	r3, [r3, #0]
 8001d32:	9a01      	ldr	r2, [sp, #4]
 8001d34:	6852      	ldr	r2, [r2, #4]
 8001d36:	605a      	str	r2, [r3, #4]

  return tp;
 8001d38:	9b01      	ldr	r3, [sp, #4]
}
 8001d3a:	1c18      	adds	r0, r3, #0
 8001d3c:	b002      	add	sp, #8
 8001d3e:	4770      	bx	lr

08001d40 <list_remove.4331>:
 * @param[in] tlp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *list_remove(threads_list_t *tlp) {
 8001d40:	b084      	sub	sp, #16
 8001d42:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8001d44:	9b01      	ldr	r3, [sp, #4]
 8001d46:	681b      	ldr	r3, [r3, #0]
 8001d48:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8001d4a:	9b03      	ldr	r3, [sp, #12]
 8001d4c:	681a      	ldr	r2, [r3, #0]
 8001d4e:	9b01      	ldr	r3, [sp, #4]
 8001d50:	601a      	str	r2, [r3, #0]

  return tp;
 8001d52:	9b03      	ldr	r3, [sp, #12]
}
 8001d54:	1c18      	adds	r0, r3, #0
 8001d56:	b004      	add	sp, #16
 8001d58:	4770      	bx	lr
 8001d5a:	46c0      	nop			; (mov r8, r8)
 8001d5c:	46c0      	nop			; (mov r8, r8)
 8001d5e:	46c0      	nop			; (mov r8, r8)

08001d60 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001d60:	b084      	sub	sp, #16
 8001d62:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001d64:	9b01      	ldr	r3, [sp, #4]
 8001d66:	2200      	movs	r2, #0
 8001d68:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001d6a:	4b0e      	ldr	r3, [pc, #56]	; (8001da4 <chSchReadyI+0x44>)
 8001d6c:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8001d6e:	9b03      	ldr	r3, [sp, #12]
 8001d70:	681b      	ldr	r3, [r3, #0]
 8001d72:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8001d74:	9b03      	ldr	r3, [sp, #12]
 8001d76:	689a      	ldr	r2, [r3, #8]
 8001d78:	9b01      	ldr	r3, [sp, #4]
 8001d7a:	689b      	ldr	r3, [r3, #8]
 8001d7c:	429a      	cmp	r2, r3
 8001d7e:	d2f6      	bcs.n	8001d6e <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001d80:	9b01      	ldr	r3, [sp, #4]
 8001d82:	9a03      	ldr	r2, [sp, #12]
 8001d84:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8001d86:	9b03      	ldr	r3, [sp, #12]
 8001d88:	685a      	ldr	r2, [r3, #4]
 8001d8a:	9b01      	ldr	r3, [sp, #4]
 8001d8c:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001d8e:	9b01      	ldr	r3, [sp, #4]
 8001d90:	685b      	ldr	r3, [r3, #4]
 8001d92:	9a01      	ldr	r2, [sp, #4]
 8001d94:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8001d96:	9b03      	ldr	r3, [sp, #12]
 8001d98:	9a01      	ldr	r2, [sp, #4]
 8001d9a:	605a      	str	r2, [r3, #4]

  return tp;
 8001d9c:	9b01      	ldr	r3, [sp, #4]
}
 8001d9e:	1c18      	adds	r0, r3, #0
 8001da0:	b004      	add	sp, #16
 8001da2:	4770      	bx	lr
 8001da4:	20000300 	.word	0x20000300
 8001da8:	46c0      	nop			; (mov r8, r8)
 8001daa:	46c0      	nop			; (mov r8, r8)
 8001dac:	46c0      	nop			; (mov r8, r8)
 8001dae:	46c0      	nop			; (mov r8, r8)

08001db0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8001db0:	b500      	push	{lr}
 8001db2:	b085      	sub	sp, #20
 8001db4:	1c02      	adds	r2, r0, #0
 8001db6:	466b      	mov	r3, sp
 8001db8:	3307      	adds	r3, #7
 8001dba:	701a      	strb	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8001dbc:	4b0d      	ldr	r3, [pc, #52]	; (8001df4 <chSchGoSleepS+0x44>)
 8001dbe:	699b      	ldr	r3, [r3, #24]
 8001dc0:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8001dc2:	9b03      	ldr	r3, [sp, #12]
 8001dc4:	466a      	mov	r2, sp
 8001dc6:	3207      	adds	r2, #7
 8001dc8:	7812      	ldrb	r2, [r2, #0]
 8001dca:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001dcc:	4b09      	ldr	r3, [pc, #36]	; (8001df4 <chSchGoSleepS+0x44>)
 8001dce:	1c18      	adds	r0, r3, #0
 8001dd0:	f7ff ff8e 	bl	8001cf0 <queue_fifo_remove>
 8001dd4:	1c02      	adds	r2, r0, #0
 8001dd6:	4b07      	ldr	r3, [pc, #28]	; (8001df4 <chSchGoSleepS+0x44>)
 8001dd8:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001dda:	4b06      	ldr	r3, [pc, #24]	; (8001df4 <chSchGoSleepS+0x44>)
 8001ddc:	699b      	ldr	r3, [r3, #24]
 8001dde:	2201      	movs	r2, #1
 8001de0:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 8001de2:	4b04      	ldr	r3, [pc, #16]	; (8001df4 <chSchGoSleepS+0x44>)
 8001de4:	699a      	ldr	r2, [r3, #24]
 8001de6:	9b03      	ldr	r3, [sp, #12]
 8001de8:	1c10      	adds	r0, r2, #0
 8001dea:	1c19      	adds	r1, r3, #0
 8001dec:	f7fe f9d0 	bl	8000190 <_port_switch>
}
 8001df0:	b005      	add	sp, #20
 8001df2:	bd00      	pop	{pc}
 8001df4:	20000300 	.word	0x20000300
 8001df8:	46c0      	nop			; (mov r8, r8)
 8001dfa:	46c0      	nop			; (mov r8, r8)
 8001dfc:	46c0      	nop			; (mov r8, r8)
 8001dfe:	46c0      	nop			; (mov r8, r8)

08001e00 <wakeup.4666.4322>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8001e00:	b500      	push	{lr}
 8001e02:	b085      	sub	sp, #20
 8001e04:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8001e06:	9b01      	ldr	r3, [sp, #4]
 8001e08:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8001e0a:	f7ff ff11 	bl	8001c30 <chSysLockFromISR.4615.4373>
  switch (tp->p_state) {
 8001e0e:	9b03      	ldr	r3, [sp, #12]
 8001e10:	7f1b      	ldrb	r3, [r3, #28]
 8001e12:	2b07      	cmp	r3, #7
 8001e14:	d815      	bhi.n	8001e42 <wakeup.4666.4322+0x42>
 8001e16:	009a      	lsls	r2, r3, #2
 8001e18:	4b10      	ldr	r3, [pc, #64]	; (8001e5c <wakeup.4666.4322+0x5c>)
 8001e1a:	18d3      	adds	r3, r2, r3
 8001e1c:	681b      	ldr	r3, [r3, #0]
 8001e1e:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8001e20:	f7ff ff0e 	bl	8001c40 <chSysUnlockFromISR.4617.4371>
 8001e24:	e017      	b.n	8001e56 <wakeup.4666.4322+0x56>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8001e26:	9b03      	ldr	r3, [sp, #12]
 8001e28:	6a1b      	ldr	r3, [r3, #32]
 8001e2a:	2200      	movs	r2, #0
 8001e2c:	601a      	str	r2, [r3, #0]
 8001e2e:	e008      	b.n	8001e42 <wakeup.4666.4322+0x42>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8001e30:	9b03      	ldr	r3, [sp, #12]
 8001e32:	6a1b      	ldr	r3, [r3, #32]
 8001e34:	1c18      	adds	r0, r3, #0
 8001e36:	f7ff ff1b 	bl	8001c70 <chSemFastSignalI.4633.4357>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8001e3a:	9b03      	ldr	r3, [sp, #12]
 8001e3c:	1c18      	adds	r0, r3, #0
 8001e3e:	f7ff ff6f 	bl	8001d20 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001e42:	9b03      	ldr	r3, [sp, #12]
 8001e44:	2201      	movs	r2, #1
 8001e46:	4252      	negs	r2, r2
 8001e48:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8001e4a:	9b03      	ldr	r3, [sp, #12]
 8001e4c:	1c18      	adds	r0, r3, #0
 8001e4e:	f7ff ff87 	bl	8001d60 <chSchReadyI>
  chSysUnlockFromISR();
 8001e52:	f7ff fef5 	bl	8001c40 <chSysUnlockFromISR.4617.4371>
}
 8001e56:	b005      	add	sp, #20
 8001e58:	bd00      	pop	{pc}
 8001e5a:	46c0      	nop			; (mov r8, r8)
 8001e5c:	080023b0 	.word	0x080023b0

08001e60 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001e60:	b500      	push	{lr}
 8001e62:	b089      	sub	sp, #36	; 0x24
 8001e64:	1c0a      	adds	r2, r1, #0
 8001e66:	466b      	mov	r3, sp
 8001e68:	3307      	adds	r3, #7
 8001e6a:	1c01      	adds	r1, r0, #0
 8001e6c:	7019      	strb	r1, [r3, #0]
 8001e6e:	ab01      	add	r3, sp, #4
 8001e70:	801a      	strh	r2, [r3, #0]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001e72:	ab01      	add	r3, sp, #4
 8001e74:	881a      	ldrh	r2, [r3, #0]
 8001e76:	4b14      	ldr	r3, [pc, #80]	; (8001ec8 <chSchGoSleepTimeoutS+0x68>)
 8001e78:	429a      	cmp	r2, r3
 8001e7a:	d019      	beq.n	8001eb0 <chSchGoSleepTimeoutS+0x50>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8001e7c:	4b13      	ldr	r3, [pc, #76]	; (8001ecc <chSchGoSleepTimeoutS+0x6c>)
 8001e7e:	699b      	ldr	r3, [r3, #24]
 8001e80:	a803      	add	r0, sp, #12
 8001e82:	aa01      	add	r2, sp, #4
 8001e84:	8811      	ldrh	r1, [r2, #0]
 8001e86:	4a12      	ldr	r2, [pc, #72]	; (8001ed0 <chSchGoSleepTimeoutS+0x70>)
 8001e88:	f7ff fd8a 	bl	80019a0 <chVTDoSetI.4392>
    chSchGoSleepS(newstate);
 8001e8c:	466b      	mov	r3, sp
 8001e8e:	3307      	adds	r3, #7
 8001e90:	781b      	ldrb	r3, [r3, #0]
 8001e92:	1c18      	adds	r0, r3, #0
 8001e94:	f7ff ff8c 	bl	8001db0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8001e98:	ab03      	add	r3, sp, #12
 8001e9a:	1c18      	adds	r0, r3, #0
 8001e9c:	f7ff fed8 	bl	8001c50 <chVTIsArmedI.4619.4360>
 8001ea0:	1c03      	adds	r3, r0, #0
 8001ea2:	2b00      	cmp	r3, #0
 8001ea4:	d00a      	beq.n	8001ebc <chSchGoSleepTimeoutS+0x5c>
      chVTDoResetI(&vt);
 8001ea6:	ab03      	add	r3, sp, #12
 8001ea8:	1c18      	adds	r0, r3, #0
 8001eaa:	f7ff fe19 	bl	8001ae0 <chVTDoResetI.4388>
 8001eae:	e005      	b.n	8001ebc <chSchGoSleepTimeoutS+0x5c>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001eb0:	466b      	mov	r3, sp
 8001eb2:	3307      	adds	r3, #7
 8001eb4:	781b      	ldrb	r3, [r3, #0]
 8001eb6:	1c18      	adds	r0, r3, #0
 8001eb8:	f7ff ff7a 	bl	8001db0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8001ebc:	4b03      	ldr	r3, [pc, #12]	; (8001ecc <chSchGoSleepTimeoutS+0x6c>)
 8001ebe:	699b      	ldr	r3, [r3, #24]
 8001ec0:	6a1b      	ldr	r3, [r3, #32]
}
 8001ec2:	1c18      	adds	r0, r3, #0
 8001ec4:	b009      	add	sp, #36	; 0x24
 8001ec6:	bd00      	pop	{pc}
 8001ec8:	0000ffff 	.word	0x0000ffff
 8001ecc:	20000300 	.word	0x20000300
 8001ed0:	08001e01 	.word	0x08001e01
 8001ed4:	46c0      	nop			; (mov r8, r8)
 8001ed6:	46c0      	nop			; (mov r8, r8)
 8001ed8:	46c0      	nop			; (mov r8, r8)
 8001eda:	46c0      	nop			; (mov r8, r8)
 8001edc:	46c0      	nop			; (mov r8, r8)
 8001ede:	46c0      	nop			; (mov r8, r8)

08001ee0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001ee0:	b500      	push	{lr}
 8001ee2:	b085      	sub	sp, #20
 8001ee4:	9001      	str	r0, [sp, #4]
 8001ee6:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8001ee8:	9b01      	ldr	r3, [sp, #4]
 8001eea:	9a00      	ldr	r2, [sp, #0]
 8001eec:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001eee:	9b01      	ldr	r3, [sp, #4]
 8001ef0:	689a      	ldr	r2, [r3, #8]
 8001ef2:	4b0f      	ldr	r3, [pc, #60]	; (8001f30 <chSchWakeupS+0x50>)
 8001ef4:	699b      	ldr	r3, [r3, #24]
 8001ef6:	689b      	ldr	r3, [r3, #8]
 8001ef8:	429a      	cmp	r2, r3
 8001efa:	d804      	bhi.n	8001f06 <chSchWakeupS+0x26>
    (void) chSchReadyI(ntp);
 8001efc:	9b01      	ldr	r3, [sp, #4]
 8001efe:	1c18      	adds	r0, r3, #0
 8001f00:	f7ff ff2e 	bl	8001d60 <chSchReadyI>
 8001f04:	e012      	b.n	8001f2c <chSchWakeupS+0x4c>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8001f06:	4b0a      	ldr	r3, [pc, #40]	; (8001f30 <chSchWakeupS+0x50>)
 8001f08:	699b      	ldr	r3, [r3, #24]
 8001f0a:	1c18      	adds	r0, r3, #0
 8001f0c:	f7ff ff28 	bl	8001d60 <chSchReadyI>
 8001f10:	1c03      	adds	r3, r0, #0
 8001f12:	9303      	str	r3, [sp, #12]
    setcurrp(ntp);
 8001f14:	4b06      	ldr	r3, [pc, #24]	; (8001f30 <chSchWakeupS+0x50>)
 8001f16:	9a01      	ldr	r2, [sp, #4]
 8001f18:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001f1a:	9b01      	ldr	r3, [sp, #4]
 8001f1c:	2201      	movs	r2, #1
 8001f1e:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8001f20:	9a01      	ldr	r2, [sp, #4]
 8001f22:	9b03      	ldr	r3, [sp, #12]
 8001f24:	1c10      	adds	r0, r2, #0
 8001f26:	1c19      	adds	r1, r3, #0
 8001f28:	f7fe f932 	bl	8000190 <_port_switch>
  }
}
 8001f2c:	b005      	add	sp, #20
 8001f2e:	bd00      	pop	{pc}
 8001f30:	20000300 	.word	0x20000300
 8001f34:	46c0      	nop			; (mov r8, r8)
 8001f36:	46c0      	nop			; (mov r8, r8)
 8001f38:	46c0      	nop			; (mov r8, r8)
 8001f3a:	46c0      	nop			; (mov r8, r8)
 8001f3c:	46c0      	nop			; (mov r8, r8)
 8001f3e:	46c0      	nop			; (mov r8, r8)

08001f40 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8001f40:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001f42:	4b08      	ldr	r3, [pc, #32]	; (8001f64 <chSchIsPreemptionRequired+0x24>)
 8001f44:	681b      	ldr	r3, [r3, #0]
 8001f46:	689b      	ldr	r3, [r3, #8]
 8001f48:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8001f4a:	4b06      	ldr	r3, [pc, #24]	; (8001f64 <chSchIsPreemptionRequired+0x24>)
 8001f4c:	699b      	ldr	r3, [r3, #24]
 8001f4e:	689b      	ldr	r3, [r3, #8]
 8001f50:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001f52:	9b01      	ldr	r3, [sp, #4]
 8001f54:	9a00      	ldr	r2, [sp, #0]
 8001f56:	429a      	cmp	r2, r3
 8001f58:	419b      	sbcs	r3, r3
 8001f5a:	425b      	negs	r3, r3
 8001f5c:	b2db      	uxtb	r3, r3
#endif
}
 8001f5e:	1c18      	adds	r0, r3, #0
 8001f60:	b002      	add	sp, #8
 8001f62:	4770      	bx	lr
 8001f64:	20000300 	.word	0x20000300
 8001f68:	46c0      	nop			; (mov r8, r8)
 8001f6a:	46c0      	nop			; (mov r8, r8)
 8001f6c:	46c0      	nop			; (mov r8, r8)
 8001f6e:	46c0      	nop			; (mov r8, r8)

08001f70 <chSchDoRescheduleAhead.4306>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8001f70:	b500      	push	{lr}
 8001f72:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8001f74:	4b19      	ldr	r3, [pc, #100]	; (8001fdc <chSchDoRescheduleAhead.4306+0x6c>)
 8001f76:	699b      	ldr	r3, [r3, #24]
 8001f78:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001f7a:	4b18      	ldr	r3, [pc, #96]	; (8001fdc <chSchDoRescheduleAhead.4306+0x6c>)
 8001f7c:	1c18      	adds	r0, r3, #0
 8001f7e:	f7ff feb7 	bl	8001cf0 <queue_fifo_remove>
 8001f82:	1c02      	adds	r2, r0, #0
 8001f84:	4b15      	ldr	r3, [pc, #84]	; (8001fdc <chSchDoRescheduleAhead.4306+0x6c>)
 8001f86:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001f88:	4b14      	ldr	r3, [pc, #80]	; (8001fdc <chSchDoRescheduleAhead.4306+0x6c>)
 8001f8a:	699b      	ldr	r3, [r3, #24]
 8001f8c:	2201      	movs	r2, #1
 8001f8e:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8001f90:	9b00      	ldr	r3, [sp, #0]
 8001f92:	2200      	movs	r2, #0
 8001f94:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001f96:	4b11      	ldr	r3, [pc, #68]	; (8001fdc <chSchDoRescheduleAhead.4306+0x6c>)
 8001f98:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8001f9a:	9b01      	ldr	r3, [sp, #4]
 8001f9c:	681b      	ldr	r3, [r3, #0]
 8001f9e:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8001fa0:	9b01      	ldr	r3, [sp, #4]
 8001fa2:	689a      	ldr	r2, [r3, #8]
 8001fa4:	9b00      	ldr	r3, [sp, #0]
 8001fa6:	689b      	ldr	r3, [r3, #8]
 8001fa8:	429a      	cmp	r2, r3
 8001faa:	d8f6      	bhi.n	8001f9a <chSchDoRescheduleAhead.4306+0x2a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001fac:	9b00      	ldr	r3, [sp, #0]
 8001fae:	9a01      	ldr	r2, [sp, #4]
 8001fb0:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8001fb2:	9b01      	ldr	r3, [sp, #4]
 8001fb4:	685a      	ldr	r2, [r3, #4]
 8001fb6:	9b00      	ldr	r3, [sp, #0]
 8001fb8:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8001fba:	9b00      	ldr	r3, [sp, #0]
 8001fbc:	685b      	ldr	r3, [r3, #4]
 8001fbe:	9a00      	ldr	r2, [sp, #0]
 8001fc0:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8001fc2:	9b01      	ldr	r3, [sp, #4]
 8001fc4:	9a00      	ldr	r2, [sp, #0]
 8001fc6:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8001fc8:	4b04      	ldr	r3, [pc, #16]	; (8001fdc <chSchDoRescheduleAhead.4306+0x6c>)
 8001fca:	699a      	ldr	r2, [r3, #24]
 8001fcc:	9b00      	ldr	r3, [sp, #0]
 8001fce:	1c10      	adds	r0, r2, #0
 8001fd0:	1c19      	adds	r1, r3, #0
 8001fd2:	f7fe f8dd 	bl	8000190 <_port_switch>
}
 8001fd6:	b003      	add	sp, #12
 8001fd8:	bd00      	pop	{pc}
 8001fda:	46c0      	nop			; (mov r8, r8)
 8001fdc:	20000300 	.word	0x20000300

08001fe0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001fe0:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8001fe2:	f7ff ffc5 	bl	8001f70 <chSchDoRescheduleAhead.4306>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8001fe6:	bd08      	pop	{r3, pc}
 8001fe8:	46c0      	nop			; (mov r8, r8)
 8001fea:	46c0      	nop			; (mov r8, r8)
 8001fec:	46c0      	nop			; (mov r8, r8)
 8001fee:	46c0      	nop			; (mov r8, r8)

08001ff0 <port_lock.4742.4302>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001ff0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001ff2:	4770      	bx	lr
 8001ff4:	46c0      	nop			; (mov r8, r8)
 8001ff6:	46c0      	nop			; (mov r8, r8)
 8001ff8:	46c0      	nop			; (mov r8, r8)
 8001ffa:	46c0      	nop			; (mov r8, r8)
 8001ffc:	46c0      	nop			; (mov r8, r8)
 8001ffe:	46c0      	nop			; (mov r8, r8)

08002000 <port_unlock.4745.4300>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002000:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8002002:	4770      	bx	lr
 8002004:	46c0      	nop			; (mov r8, r8)
 8002006:	46c0      	nop			; (mov r8, r8)
 8002008:	46c0      	nop			; (mov r8, r8)
 800200a:	46c0      	nop			; (mov r8, r8)
 800200c:	46c0      	nop			; (mov r8, r8)
 800200e:	46c0      	nop			; (mov r8, r8)

08002010 <list_init.4754.4293>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8002010:	b082      	sub	sp, #8
 8002012:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8002014:	9b01      	ldr	r3, [sp, #4]
 8002016:	9a01      	ldr	r2, [sp, #4]
 8002018:	601a      	str	r2, [r3, #0]
}
 800201a:	b002      	add	sp, #8
 800201c:	4770      	bx	lr
 800201e:	46c0      	nop			; (mov r8, r8)

08002020 <list_notempty.4820.4290>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8002020:	b082      	sub	sp, #8
 8002022:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8002024:	9b01      	ldr	r3, [sp, #4]
 8002026:	681a      	ldr	r2, [r3, #0]
 8002028:	9b01      	ldr	r3, [sp, #4]
 800202a:	1ad3      	subs	r3, r2, r3
 800202c:	1e5a      	subs	r2, r3, #1
 800202e:	4193      	sbcs	r3, r2
 8002030:	b2db      	uxtb	r3, r3
}
 8002032:	1c18      	adds	r0, r3, #0
 8002034:	b002      	add	sp, #8
 8002036:	4770      	bx	lr
 8002038:	46c0      	nop			; (mov r8, r8)
 800203a:	46c0      	nop			; (mov r8, r8)
 800203c:	46c0      	nop			; (mov r8, r8)
 800203e:	46c0      	nop			; (mov r8, r8)

08002040 <queue_notempty.4824.4287>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002040:	b082      	sub	sp, #8
 8002042:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002044:	9b01      	ldr	r3, [sp, #4]
 8002046:	681a      	ldr	r2, [r3, #0]
 8002048:	9b01      	ldr	r3, [sp, #4]
 800204a:	1ad3      	subs	r3, r2, r3
 800204c:	1e5a      	subs	r2, r3, #1
 800204e:	4193      	sbcs	r3, r2
 8002050:	b2db      	uxtb	r3, r3
}
 8002052:	1c18      	adds	r0, r3, #0
 8002054:	b002      	add	sp, #8
 8002056:	4770      	bx	lr
 8002058:	46c0      	nop			; (mov r8, r8)
 800205a:	46c0      	nop			; (mov r8, r8)
 800205c:	46c0      	nop			; (mov r8, r8)
 800205e:	46c0      	nop			; (mov r8, r8)

08002060 <chSysLock.4829.4281>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8002060:	b508      	push	{r3, lr}

  port_lock();
 8002062:	f7ff ffc5 	bl	8001ff0 <port_lock.4742.4302>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002066:	bd08      	pop	{r3, pc}
 8002068:	46c0      	nop			; (mov r8, r8)
 800206a:	46c0      	nop			; (mov r8, r8)
 800206c:	46c0      	nop			; (mov r8, r8)
 800206e:	46c0      	nop			; (mov r8, r8)

08002070 <chSysUnlock.4831.4279>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002070:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002072:	f7ff ffc5 	bl	8002000 <port_unlock.4745.4300>
}
 8002076:	bd08      	pop	{r3, pc}
 8002078:	46c0      	nop			; (mov r8, r8)
 800207a:	46c0      	nop			; (mov r8, r8)
 800207c:	46c0      	nop			; (mov r8, r8)
 800207e:	46c0      	nop			; (mov r8, r8)

08002080 <chThdDoDequeueNextI.4850.4260>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002080:	b500      	push	{lr}
 8002082:	b085      	sub	sp, #20
 8002084:	9001      	str	r0, [sp, #4]
 8002086:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 8002088:	9b01      	ldr	r3, [sp, #4]
 800208a:	1c18      	adds	r0, r3, #0
 800208c:	f7ff fe30 	bl	8001cf0 <queue_fifo_remove>
 8002090:	1c03      	adds	r3, r0, #0
 8002092:	9303      	str	r3, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8002094:	9b03      	ldr	r3, [sp, #12]
 8002096:	9a00      	ldr	r2, [sp, #0]
 8002098:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 800209a:	9b03      	ldr	r3, [sp, #12]
 800209c:	1c18      	adds	r0, r3, #0
 800209e:	f7ff fe5f 	bl	8001d60 <chSchReadyI>
}
 80020a2:	b005      	add	sp, #20
 80020a4:	bd00      	pop	{pc}
 80020a6:	46c0      	nop			; (mov r8, r8)
 80020a8:	46c0      	nop			; (mov r8, r8)
 80020aa:	46c0      	nop			; (mov r8, r8)
 80020ac:	46c0      	nop			; (mov r8, r8)
 80020ae:	46c0      	nop			; (mov r8, r8)

080020b0 <_thread_init.4256>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 80020b0:	b500      	push	{lr}
 80020b2:	b083      	sub	sp, #12
 80020b4:	9001      	str	r0, [sp, #4]
 80020b6:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 80020b8:	9b01      	ldr	r3, [sp, #4]
 80020ba:	9a00      	ldr	r2, [sp, #0]
 80020bc:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 80020be:	9b01      	ldr	r3, [sp, #4]
 80020c0:	2202      	movs	r2, #2
 80020c2:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80020c4:	9b01      	ldr	r3, [sp, #4]
 80020c6:	2200      	movs	r2, #0
 80020c8:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80020ca:	9b01      	ldr	r3, [sp, #4]
 80020cc:	9a00      	ldr	r2, [sp, #0]
 80020ce:	62da      	str	r2, [r3, #44]	; 0x2c
  tp->p_mtxlist = NULL;
 80020d0:	9b01      	ldr	r3, [sp, #4]
 80020d2:	2200      	movs	r2, #0
 80020d4:	629a      	str	r2, [r3, #40]	; 0x28
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80020d6:	9b01      	ldr	r3, [sp, #4]
 80020d8:	2200      	movs	r2, #0
 80020da:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 80020dc:	9b01      	ldr	r3, [sp, #4]
 80020de:	4a0b      	ldr	r2, [pc, #44]	; (800210c <_thread_init.4256+0x5c>)
 80020e0:	611a      	str	r2, [r3, #16]
 80020e2:	4b0a      	ldr	r3, [pc, #40]	; (800210c <_thread_init.4256+0x5c>)
 80020e4:	695a      	ldr	r2, [r3, #20]
 80020e6:	9b01      	ldr	r3, [sp, #4]
 80020e8:	615a      	str	r2, [r3, #20]
 80020ea:	9b01      	ldr	r3, [sp, #4]
 80020ec:	695b      	ldr	r3, [r3, #20]
 80020ee:	9a01      	ldr	r2, [sp, #4]
 80020f0:	611a      	str	r2, [r3, #16]
 80020f2:	4b06      	ldr	r3, [pc, #24]	; (800210c <_thread_init.4256+0x5c>)
 80020f4:	9a01      	ldr	r2, [sp, #4]
 80020f6:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80020f8:	9b01      	ldr	r3, [sp, #4]
 80020fa:	3324      	adds	r3, #36	; 0x24
 80020fc:	1c18      	adds	r0, r3, #0
 80020fe:	f7ff ff87 	bl	8002010 <list_init.4754.4293>
  chTMStartMeasurementX(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 8002102:	9b01      	ldr	r3, [sp, #4]
}
 8002104:	1c18      	adds	r0, r3, #0
 8002106:	b003      	add	sp, #12
 8002108:	bd00      	pop	{pc}
 800210a:	46c0      	nop			; (mov r8, r8)
 800210c:	20000300 	.word	0x20000300

08002110 <chThdCreateI.4248>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8002110:	b500      	push	{lr}
 8002112:	b087      	sub	sp, #28
 8002114:	9003      	str	r0, [sp, #12]
 8002116:	9102      	str	r1, [sp, #8]
 8002118:	9201      	str	r2, [sp, #4]
 800211a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800211c:	9b03      	ldr	r3, [sp, #12]
 800211e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002120:	9b02      	ldr	r3, [sp, #8]
 8002122:	3b24      	subs	r3, #36	; 0x24
 8002124:	9a03      	ldr	r2, [sp, #12]
 8002126:	18d2      	adds	r2, r2, r3
 8002128:	9b05      	ldr	r3, [sp, #20]
 800212a:	60da      	str	r2, [r3, #12]
 800212c:	9b05      	ldr	r3, [sp, #20]
 800212e:	68db      	ldr	r3, [r3, #12]
 8002130:	9a00      	ldr	r2, [sp, #0]
 8002132:	611a      	str	r2, [r3, #16]
 8002134:	9b05      	ldr	r3, [sp, #20]
 8002136:	68db      	ldr	r3, [r3, #12]
 8002138:	9a08      	ldr	r2, [sp, #32]
 800213a:	615a      	str	r2, [r3, #20]
 800213c:	9b05      	ldr	r3, [sp, #20]
 800213e:	68db      	ldr	r3, [r3, #12]
 8002140:	4a05      	ldr	r2, [pc, #20]	; (8002158 <chThdCreateI.4248+0x48>)
 8002142:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 8002144:	9a05      	ldr	r2, [sp, #20]
 8002146:	9b01      	ldr	r3, [sp, #4]
 8002148:	1c10      	adds	r0, r2, #0
 800214a:	1c19      	adds	r1, r3, #0
 800214c:	f7ff ffb0 	bl	80020b0 <_thread_init.4256>
 8002150:	1c03      	adds	r3, r0, #0
}
 8002152:	1c18      	adds	r0, r3, #0
 8002154:	b007      	add	sp, #28
 8002156:	bd00      	pop	{pc}
 8002158:	080001b1 	.word	0x080001b1
 800215c:	46c0      	nop			; (mov r8, r8)
 800215e:	46c0      	nop			; (mov r8, r8)

08002160 <chThdCreateStatic.4239>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8002160:	b510      	push	{r4, lr}
 8002162:	b088      	sub	sp, #32
 8002164:	9005      	str	r0, [sp, #20]
 8002166:	9104      	str	r1, [sp, #16]
 8002168:	9203      	str	r2, [sp, #12]
 800216a:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800216c:	f7ff ff78 	bl	8002060 <chSysLock.4829.4281>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8002170:	9805      	ldr	r0, [sp, #20]
 8002172:	9904      	ldr	r1, [sp, #16]
 8002174:	9a03      	ldr	r2, [sp, #12]
 8002176:	9b02      	ldr	r3, [sp, #8]
 8002178:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800217a:	9400      	str	r4, [sp, #0]
 800217c:	f7ff ffc8 	bl	8002110 <chThdCreateI.4248>
 8002180:	1c03      	adds	r3, r0, #0
 8002182:	9307      	str	r3, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8002184:	9b07      	ldr	r3, [sp, #28]
 8002186:	1c18      	adds	r0, r3, #0
 8002188:	2100      	movs	r1, #0
 800218a:	f7ff fea9 	bl	8001ee0 <chSchWakeupS>
  chSysUnlock();
 800218e:	f7ff ff6f 	bl	8002070 <chSysUnlock.4831.4279>

  return tp;
 8002192:	9b07      	ldr	r3, [sp, #28]
}
 8002194:	1c18      	adds	r0, r3, #0
 8002196:	b008      	add	sp, #32
 8002198:	bd10      	pop	{r4, pc}
 800219a:	46c0      	nop			; (mov r8, r8)
 800219c:	46c0      	nop			; (mov r8, r8)
 800219e:	46c0      	nop			; (mov r8, r8)

080021a0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80021a0:	b500      	push	{lr}
 80021a2:	b083      	sub	sp, #12
 80021a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80021a6:	f7ff ff5b 	bl	8002060 <chSysLock.4829.4281>
  chThdExitS(msg);
 80021aa:	9b01      	ldr	r3, [sp, #4]
 80021ac:	1c18      	adds	r0, r3, #0
 80021ae:	f000 f807 	bl	80021c0 <chThdExitS.4212>
  /* The thread never returns here.*/
}
 80021b2:	b003      	add	sp, #12
 80021b4:	bd00      	pop	{pc}
 80021b6:	46c0      	nop			; (mov r8, r8)
 80021b8:	46c0      	nop			; (mov r8, r8)
 80021ba:	46c0      	nop			; (mov r8, r8)
 80021bc:	46c0      	nop			; (mov r8, r8)
 80021be:	46c0      	nop			; (mov r8, r8)

080021c0 <chThdExitS.4212>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80021c0:	b500      	push	{lr}
 80021c2:	b085      	sub	sp, #20
 80021c4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 80021c6:	4b16      	ldr	r3, [pc, #88]	; (8002220 <chThdExitS.4212+0x60>)
 80021c8:	699b      	ldr	r3, [r3, #24]
 80021ca:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 80021cc:	9b03      	ldr	r3, [sp, #12]
 80021ce:	9a01      	ldr	r2, [sp, #4]
 80021d0:	621a      	str	r2, [r3, #32]
 80021d2:	e008      	b.n	80021e6 <chThdExitS.4212+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80021d4:	9b03      	ldr	r3, [sp, #12]
 80021d6:	3324      	adds	r3, #36	; 0x24
 80021d8:	1c18      	adds	r0, r3, #0
 80021da:	f7ff fdb1 	bl	8001d40 <list_remove.4331>
 80021de:	1c03      	adds	r3, r0, #0
 80021e0:	1c18      	adds	r0, r3, #0
 80021e2:	f7ff fdbd 	bl	8001d60 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80021e6:	9b03      	ldr	r3, [sp, #12]
 80021e8:	3324      	adds	r3, #36	; 0x24
 80021ea:	1c18      	adds	r0, r3, #0
 80021ec:	f7ff ff18 	bl	8002020 <list_notempty.4820.4290>
 80021f0:	1c03      	adds	r3, r0, #0
 80021f2:	2b00      	cmp	r3, #0
 80021f4:	d1ee      	bne.n	80021d4 <chThdExitS.4212+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80021f6:	9b03      	ldr	r3, [sp, #12]
 80021f8:	7f5b      	ldrb	r3, [r3, #29]
 80021fa:	1c1a      	adds	r2, r3, #0
 80021fc:	2303      	movs	r3, #3
 80021fe:	4013      	ands	r3, r2
 8002200:	d109      	bne.n	8002216 <chThdExitS.4212+0x56>
    REG_REMOVE(tp);
 8002202:	9b03      	ldr	r3, [sp, #12]
 8002204:	695b      	ldr	r3, [r3, #20]
 8002206:	9a03      	ldr	r2, [sp, #12]
 8002208:	6912      	ldr	r2, [r2, #16]
 800220a:	611a      	str	r2, [r3, #16]
 800220c:	9b03      	ldr	r3, [sp, #12]
 800220e:	691b      	ldr	r3, [r3, #16]
 8002210:	9a03      	ldr	r2, [sp, #12]
 8002212:	6952      	ldr	r2, [r2, #20]
 8002214:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8002216:	200f      	movs	r0, #15
 8002218:	f7ff fdca 	bl	8001db0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 800221c:	b005      	add	sp, #20
 800221e:	bd00      	pop	{pc}
 8002220:	20000300 	.word	0x20000300
 8002224:	46c0      	nop			; (mov r8, r8)
 8002226:	46c0      	nop			; (mov r8, r8)
 8002228:	46c0      	nop			; (mov r8, r8)
 800222a:	46c0      	nop			; (mov r8, r8)
 800222c:	46c0      	nop			; (mov r8, r8)
 800222e:	46c0      	nop			; (mov r8, r8)

08002230 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8002230:	b500      	push	{lr}
 8002232:	b083      	sub	sp, #12
 8002234:	9001      	str	r0, [sp, #4]
 8002236:	1c0a      	adds	r2, r1, #0
 8002238:	466b      	mov	r3, sp
 800223a:	3302      	adds	r3, #2
 800223c:	801a      	strh	r2, [r3, #0]

  if (TIME_IMMEDIATE == timeout) {
 800223e:	466b      	mov	r3, sp
 8002240:	3302      	adds	r3, #2
 8002242:	881b      	ldrh	r3, [r3, #0]
 8002244:	2b00      	cmp	r3, #0
 8002246:	d102      	bne.n	800224e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
 8002248:	2301      	movs	r3, #1
 800224a:	425b      	negs	r3, r3
 800224c:	e00e      	b.n	800226c <chThdEnqueueTimeoutS+0x3c>
  }

  queue_insert(currp, tqp);
 800224e:	4b09      	ldr	r3, [pc, #36]	; (8002274 <chThdEnqueueTimeoutS+0x44>)
 8002250:	699a      	ldr	r2, [r3, #24]
 8002252:	9b01      	ldr	r3, [sp, #4]
 8002254:	1c10      	adds	r0, r2, #0
 8002256:	1c19      	adds	r1, r3, #0
 8002258:	f7ff fd32 	bl	8001cc0 <queue_insert.4347>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800225c:	466b      	mov	r3, sp
 800225e:	3302      	adds	r3, #2
 8002260:	881b      	ldrh	r3, [r3, #0]
 8002262:	2004      	movs	r0, #4
 8002264:	1c19      	adds	r1, r3, #0
 8002266:	f7ff fdfb 	bl	8001e60 <chSchGoSleepTimeoutS>
 800226a:	1c03      	adds	r3, r0, #0
}
 800226c:	1c18      	adds	r0, r3, #0
 800226e:	b003      	add	sp, #12
 8002270:	bd00      	pop	{pc}
 8002272:	46c0      	nop			; (mov r8, r8)
 8002274:	20000300 	.word	0x20000300
 8002278:	46c0      	nop			; (mov r8, r8)
 800227a:	46c0      	nop			; (mov r8, r8)
 800227c:	46c0      	nop			; (mov r8, r8)
 800227e:	46c0      	nop			; (mov r8, r8)

08002280 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002280:	b500      	push	{lr}
 8002282:	b083      	sub	sp, #12
 8002284:	9001      	str	r0, [sp, #4]
 8002286:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8002288:	9b01      	ldr	r3, [sp, #4]
 800228a:	1c18      	adds	r0, r3, #0
 800228c:	f7ff fed8 	bl	8002040 <queue_notempty.4824.4287>
 8002290:	1c03      	adds	r3, r0, #0
 8002292:	2b00      	cmp	r3, #0
 8002294:	d005      	beq.n	80022a2 <chThdDequeueNextI+0x22>
    chThdDoDequeueNextI(tqp, msg);
 8002296:	9a01      	ldr	r2, [sp, #4]
 8002298:	9b00      	ldr	r3, [sp, #0]
 800229a:	1c10      	adds	r0, r2, #0
 800229c:	1c19      	adds	r1, r3, #0
 800229e:	f7ff feef 	bl	8002080 <chThdDoDequeueNextI.4850.4260>
  }
}
 80022a2:	b003      	add	sp, #12
 80022a4:	bd00      	pop	{pc}
 80022a6:	46c0      	nop			; (mov r8, r8)
 80022a8:	46c0      	nop			; (mov r8, r8)
 80022aa:	46c0      	nop			; (mov r8, r8)
 80022ac:	46c0      	nop			; (mov r8, r8)
 80022ae:	46c0      	nop			; (mov r8, r8)

080022b0 <queue_init.5370.4099>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80022b0:	b082      	sub	sp, #8
 80022b2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80022b4:	9b01      	ldr	r3, [sp, #4]
 80022b6:	9a01      	ldr	r2, [sp, #4]
 80022b8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80022ba:	9b01      	ldr	r3, [sp, #4]
 80022bc:	9a01      	ldr	r2, [sp, #4]
 80022be:	605a      	str	r2, [r3, #4]
}
 80022c0:	b002      	add	sp, #8
 80022c2:	4770      	bx	lr
 80022c4:	46c0      	nop			; (mov r8, r8)
 80022c6:	46c0      	nop			; (mov r8, r8)
 80022c8:	46c0      	nop			; (mov r8, r8)
 80022ca:	46c0      	nop			; (mov r8, r8)
 80022cc:	46c0      	nop			; (mov r8, r8)
 80022ce:	46c0      	nop			; (mov r8, r8)

080022d0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 80022d0:	b500      	push	{lr}
 80022d2:	b083      	sub	sp, #12
 80022d4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 80022d6:	9b01      	ldr	r3, [sp, #4]
 80022d8:	1c18      	adds	r0, r3, #0
 80022da:	f7ff ffe9 	bl	80022b0 <queue_init.5370.4099>
  mp->m_owner = NULL;
 80022de:	9b01      	ldr	r3, [sp, #4]
 80022e0:	2200      	movs	r2, #0
 80022e2:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 80022e4:	b003      	add	sp, #12
 80022e6:	bd00      	pop	{pc}
 80022e8:	46c0      	nop			; (mov r8, r8)
 80022ea:	46c0      	nop			; (mov r8, r8)
 80022ec:	46c0      	nop			; (mov r8, r8)
 80022ee:	46c0      	nop			; (mov r8, r8)
 80022f0:	656c6469 	.word	0x656c6469
	...

08002300 <ch_debug>:
 8002300:	6e69616d 18401600 08300204 1814100c     main..@...0.....
 8002310:	001d1c00 00000000 00000000 00000000     ................

08002320 <vmt.6507.4492>:
 8002320:	08000201 08000231 08000261 080002a1     ....1...a.......
 8002330:	080002d1 08000311 08000341 08000371     ........A...q...

08002340 <pal_default_config>:
 8002340:	280000a4 00000000 ffffff57 65555501     ...(....W....UUe
 8002350:	0000ffff 00001100 00000000 00000000     ................
 8002360:	00000000 ffffffff 55555555 0000ffff     ........UUUU....
	...
 8002380:	ffffffff 51555555 0000ffff 00000000     ....UUUQ........
	...
 80023a0:	55555550 0000ffff 00000000 00000000     PUUU............
 80023b0:	08001e20 08001e42 08001e42 08001e26      ...B...B...&...
 80023c0:	08001e3a 08001e30 08001e42 08001e3a     :...0...B...:...
