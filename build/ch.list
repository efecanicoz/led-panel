
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4821      	ldr	r0, [pc, #132]	; (8000148 <endfiniloop+0x4>)
 80000c4:	f380 8809 	msr	PSP, r0
 80000c8:	2002      	movs	r0, #2
 80000ca:	f380 8814 	msr	CONTROL, r0
 80000ce:	f3bf 8f6f 	isb	sy
 80000d2:	f001 fa3d 	bl	8001550 <__core_init>
 80000d6:	f000 fdab 	bl	8000c30 <__early_init>
 80000da:	481c      	ldr	r0, [pc, #112]	; (800014c <endfiniloop+0x8>)
 80000dc:	491c      	ldr	r1, [pc, #112]	; (8000150 <endfiniloop+0xc>)
 80000de:	4a1d      	ldr	r2, [pc, #116]	; (8000154 <endfiniloop+0x10>)

080000e0 <msloop>:
 80000e0:	4291      	cmp	r1, r2
 80000e2:	da02      	bge.n	80000ea <endmsloop>
 80000e4:	6008      	str	r0, [r1, #0]
 80000e6:	3104      	adds	r1, #4
 80000e8:	e7fa      	b.n	80000e0 <msloop>

080000ea <endmsloop>:
 80000ea:	491b      	ldr	r1, [pc, #108]	; (8000158 <endfiniloop+0x14>)
 80000ec:	4a16      	ldr	r2, [pc, #88]	; (8000148 <endfiniloop+0x4>)

080000ee <psloop>:
 80000ee:	4291      	cmp	r1, r2
 80000f0:	da02      	bge.n	80000f8 <endpsloop>
 80000f2:	6008      	str	r0, [r1, #0]
 80000f4:	3104      	adds	r1, #4
 80000f6:	e7fa      	b.n	80000ee <psloop>

080000f8 <endpsloop>:
 80000f8:	4918      	ldr	r1, [pc, #96]	; (800015c <endfiniloop+0x18>)
 80000fa:	4a19      	ldr	r2, [pc, #100]	; (8000160 <endfiniloop+0x1c>)
 80000fc:	4b19      	ldr	r3, [pc, #100]	; (8000164 <endfiniloop+0x20>)

080000fe <dloop>:
 80000fe:	429a      	cmp	r2, r3
 8000100:	da04      	bge.n	800010c <enddloop>
 8000102:	6808      	ldr	r0, [r1, #0]
 8000104:	6010      	str	r0, [r2, #0]
 8000106:	3104      	adds	r1, #4
 8000108:	3204      	adds	r2, #4
 800010a:	e7f8      	b.n	80000fe <dloop>

0800010c <enddloop>:
 800010c:	2000      	movs	r0, #0
 800010e:	4916      	ldr	r1, [pc, #88]	; (8000168 <endfiniloop+0x24>)
 8000110:	4a16      	ldr	r2, [pc, #88]	; (800016c <endfiniloop+0x28>)

08000112 <bloop>:
 8000112:	4291      	cmp	r1, r2
 8000114:	da02      	bge.n	800011c <endbloop>
 8000116:	6008      	str	r0, [r1, #0]
 8000118:	3104      	adds	r1, #4
 800011a:	e7fa      	b.n	8000112 <bloop>

0800011c <endbloop>:
 800011c:	f001 fa20 	bl	8001560 <__late_init>
 8000120:	4c13      	ldr	r4, [pc, #76]	; (8000170 <endfiniloop+0x2c>)
 8000122:	4d14      	ldr	r5, [pc, #80]	; (8000174 <endfiniloop+0x30>)

08000124 <initloop>:
 8000124:	42ac      	cmp	r4, r5
 8000126:	da03      	bge.n	8000130 <endinitloop>
 8000128:	6821      	ldr	r1, [r4, #0]
 800012a:	4788      	blx	r1
 800012c:	3404      	adds	r4, #4
 800012e:	e7f9      	b.n	8000124 <initloop>

08000130 <endinitloop>:
 8000130:	f000 fd8e 	bl	8000c50 <main>
 8000134:	4c10      	ldr	r4, [pc, #64]	; (8000178 <endfiniloop+0x34>)
 8000136:	4d11      	ldr	r5, [pc, #68]	; (800017c <endfiniloop+0x38>)

08000138 <finiloop>:
 8000138:	42ac      	cmp	r4, r5
 800013a:	da03      	bge.n	8000144 <endfiniloop>
 800013c:	6821      	ldr	r1, [r4, #0]
 800013e:	4788      	blx	r1
 8000140:	3404      	adds	r4, #4
 8000142:	e7f9      	b.n	8000138 <finiloop>

08000144 <endfiniloop>:
 8000144:	490e      	ldr	r1, [pc, #56]	; (8000180 <endfiniloop+0x3c>)
 8000146:	4708      	bx	r1
 8000148:	20000300 	.word	0x20000300
 800014c:	55555555 	.word	0x55555555
 8000150:	20000000 	.word	0x20000000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000200 	.word	0x20000200
 800015c:	08002410 	.word	0x08002410
 8000160:	20000300 	.word	0x20000300
 8000164:	20000300 	.word	0x20000300
 8000168:	20000300 	.word	0x20000300
 800016c:	200004cc 	.word	0x200004cc
 8000170:	080000c0 	.word	0x080000c0
 8000174:	080000c0 	.word	0x080000c0
 8000178:	080000c0 	.word	0x080000c0
 800017c:	080000c0 	.word	0x080000c0
 8000180:	08001571 	.word	0x08001571
	...

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	b662      	cpsie	i
 80001b2:	1c28      	adds	r0, r5, #0
 80001b4:	47a0      	blx	r4
 80001b6:	2000      	movs	r0, #0
 80001b8:	f002 f812 	bl	80021e0 <chThdExit>

080001bc <_port_switch_from_isr>:
 80001bc:	f001 ff30 	bl	8002020 <chSchDoReschedule>

080001c0 <_port_exit_from_isr>:
 80001c0:	4a01      	ldr	r2, [pc, #4]	; (80001c8 <_port_exit_from_isr+0x8>)
 80001c2:	4b02      	ldr	r3, [pc, #8]	; (80001cc <_port_exit_from_isr+0xc>)
 80001c4:	6013      	str	r3, [r2, #0]
 80001c6:	e7fe      	b.n	80001c6 <_port_exit_from_isr+0x6>
 80001c8:	e000ed04 	.word	0xe000ed04
 80001cc:	80000000 	.word	0x80000000

080001d0 <write.6304.4365>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 80001d0:	b500      	push	{lr}
 80001d2:	b085      	sub	sp, #20
 80001d4:	9003      	str	r0, [sp, #12]
 80001d6:	9102      	str	r1, [sp, #8]
 80001d8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80001da:	9b03      	ldr	r3, [sp, #12]
 80001dc:	1c18      	adds	r0, r3, #0
 80001de:	3030      	adds	r0, #48	; 0x30
 80001e0:	9902      	ldr	r1, [sp, #8]
 80001e2:	9a01      	ldr	r2, [sp, #4]
 80001e4:	4b03      	ldr	r3, [pc, #12]	; (80001f4 <write.6304.4365+0x24>)
 80001e6:	f001 f943 	bl	8001470 <oqWriteTimeout>
 80001ea:	1c03      	adds	r3, r0, #0
                        n, TIME_INFINITE);
}
 80001ec:	1c18      	adds	r0, r3, #0
 80001ee:	b005      	add	sp, #20
 80001f0:	bd00      	pop	{pc}
 80001f2:	46c0      	nop			; (mov r8, r8)
 80001f4:	0000ffff 	.word	0x0000ffff
 80001f8:	46c0      	nop			; (mov r8, r8)
 80001fa:	46c0      	nop			; (mov r8, r8)
 80001fc:	46c0      	nop			; (mov r8, r8)
 80001fe:	46c0      	nop			; (mov r8, r8)

08000200 <read.6321.4360>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8000200:	b500      	push	{lr}
 8000202:	b085      	sub	sp, #20
 8000204:	9003      	str	r0, [sp, #12]
 8000206:	9102      	str	r1, [sp, #8]
 8000208:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800020a:	9b03      	ldr	r3, [sp, #12]
 800020c:	1c18      	adds	r0, r3, #0
 800020e:	300c      	adds	r0, #12
 8000210:	9902      	ldr	r1, [sp, #8]
 8000212:	9a01      	ldr	r2, [sp, #4]
 8000214:	4b03      	ldr	r3, [pc, #12]	; (8000224 <read.6321.4360+0x24>)
 8000216:	f001 f823 	bl	8001260 <iqReadTimeout>
 800021a:	1c03      	adds	r3, r0, #0
                       n, TIME_INFINITE);
}
 800021c:	1c18      	adds	r0, r3, #0
 800021e:	b005      	add	sp, #20
 8000220:	bd00      	pop	{pc}
 8000222:	46c0      	nop			; (mov r8, r8)
 8000224:	0000ffff 	.word	0x0000ffff
 8000228:	46c0      	nop			; (mov r8, r8)
 800022a:	46c0      	nop			; (mov r8, r8)
 800022c:	46c0      	nop			; (mov r8, r8)
 800022e:	46c0      	nop			; (mov r8, r8)

08000230 <put.6332.4356>:

static msg_t put(void *ip, uint8_t b) {
 8000230:	b500      	push	{lr}
 8000232:	b083      	sub	sp, #12
 8000234:	9001      	str	r0, [sp, #4]
 8000236:	1c0a      	adds	r2, r1, #0
 8000238:	466b      	mov	r3, sp
 800023a:	3303      	adds	r3, #3
 800023c:	701a      	strb	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 800023e:	9b01      	ldr	r3, [sp, #4]
 8000240:	1c19      	adds	r1, r3, #0
 8000242:	3130      	adds	r1, #48	; 0x30
 8000244:	466b      	mov	r3, sp
 8000246:	3303      	adds	r3, #3
 8000248:	781a      	ldrb	r2, [r3, #0]
 800024a:	4b05      	ldr	r3, [pc, #20]	; (8000260 <put.6332.4356+0x30>)
 800024c:	1c08      	adds	r0, r1, #0
 800024e:	1c11      	adds	r1, r2, #0
 8000250:	1c1a      	adds	r2, r3, #0
 8000252:	f001 f885 	bl	8001360 <oqPutTimeout>
 8000256:	1c03      	adds	r3, r0, #0
}
 8000258:	1c18      	adds	r0, r3, #0
 800025a:	b003      	add	sp, #12
 800025c:	bd00      	pop	{pc}
 800025e:	46c0      	nop			; (mov r8, r8)
 8000260:	0000ffff 	.word	0x0000ffff
 8000264:	46c0      	nop			; (mov r8, r8)
 8000266:	46c0      	nop			; (mov r8, r8)
 8000268:	46c0      	nop			; (mov r8, r8)
 800026a:	46c0      	nop			; (mov r8, r8)
 800026c:	46c0      	nop			; (mov r8, r8)
 800026e:	46c0      	nop			; (mov r8, r8)

08000270 <get.6344.4353>:

static msg_t get(void *ip) {
 8000270:	b500      	push	{lr}
 8000272:	b083      	sub	sp, #12
 8000274:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000276:	9b01      	ldr	r3, [sp, #4]
 8000278:	1c1a      	adds	r2, r3, #0
 800027a:	320c      	adds	r2, #12
 800027c:	4b04      	ldr	r3, [pc, #16]	; (8000290 <get.6344.4353+0x20>)
 800027e:	1c10      	adds	r0, r2, #0
 8000280:	1c19      	adds	r1, r3, #0
 8000282:	f000 ffa5 	bl	80011d0 <iqGetTimeout>
 8000286:	1c03      	adds	r3, r0, #0
}
 8000288:	1c18      	adds	r0, r3, #0
 800028a:	b003      	add	sp, #12
 800028c:	bd00      	pop	{pc}
 800028e:	46c0      	nop			; (mov r8, r8)
 8000290:	0000ffff 	.word	0x0000ffff
 8000294:	46c0      	nop			; (mov r8, r8)
 8000296:	46c0      	nop			; (mov r8, r8)
 8000298:	46c0      	nop			; (mov r8, r8)
 800029a:	46c0      	nop			; (mov r8, r8)
 800029c:	46c0      	nop			; (mov r8, r8)
 800029e:	46c0      	nop			; (mov r8, r8)

080002a0 <putt.6339.4348>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80002a0:	b500      	push	{lr}
 80002a2:	b083      	sub	sp, #12
 80002a4:	9001      	str	r0, [sp, #4]
 80002a6:	466b      	mov	r3, sp
 80002a8:	3303      	adds	r3, #3
 80002aa:	7019      	strb	r1, [r3, #0]
 80002ac:	466b      	mov	r3, sp
 80002ae:	801a      	strh	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80002b0:	9b01      	ldr	r3, [sp, #4]
 80002b2:	1c19      	adds	r1, r3, #0
 80002b4:	3130      	adds	r1, #48	; 0x30
 80002b6:	466b      	mov	r3, sp
 80002b8:	3303      	adds	r3, #3
 80002ba:	781a      	ldrb	r2, [r3, #0]
 80002bc:	466b      	mov	r3, sp
 80002be:	881b      	ldrh	r3, [r3, #0]
 80002c0:	1c08      	adds	r0, r1, #0
 80002c2:	1c11      	adds	r1, r2, #0
 80002c4:	1c1a      	adds	r2, r3, #0
 80002c6:	f001 f84b 	bl	8001360 <oqPutTimeout>
 80002ca:	1c03      	adds	r3, r0, #0
}
 80002cc:	1c18      	adds	r0, r3, #0
 80002ce:	b003      	add	sp, #12
 80002d0:	bd00      	pop	{pc}
 80002d2:	46c0      	nop			; (mov r8, r8)
 80002d4:	46c0      	nop			; (mov r8, r8)
 80002d6:	46c0      	nop			; (mov r8, r8)
 80002d8:	46c0      	nop			; (mov r8, r8)
 80002da:	46c0      	nop			; (mov r8, r8)
 80002dc:	46c0      	nop			; (mov r8, r8)
 80002de:	46c0      	nop			; (mov r8, r8)

080002e0 <gett.6347.4344>:

static msg_t gett(void *ip, systime_t timeout) {
 80002e0:	b500      	push	{lr}
 80002e2:	b083      	sub	sp, #12
 80002e4:	9001      	str	r0, [sp, #4]
 80002e6:	1c0a      	adds	r2, r1, #0
 80002e8:	466b      	mov	r3, sp
 80002ea:	3302      	adds	r3, #2
 80002ec:	801a      	strh	r2, [r3, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80002ee:	9b01      	ldr	r3, [sp, #4]
 80002f0:	1c1a      	adds	r2, r3, #0
 80002f2:	320c      	adds	r2, #12
 80002f4:	466b      	mov	r3, sp
 80002f6:	3302      	adds	r3, #2
 80002f8:	881b      	ldrh	r3, [r3, #0]
 80002fa:	1c10      	adds	r0, r2, #0
 80002fc:	1c19      	adds	r1, r3, #0
 80002fe:	f000 ff67 	bl	80011d0 <iqGetTimeout>
 8000302:	1c03      	adds	r3, r0, #0
}
 8000304:	1c18      	adds	r0, r3, #0
 8000306:	b003      	add	sp, #12
 8000308:	bd00      	pop	{pc}
 800030a:	46c0      	nop			; (mov r8, r8)
 800030c:	46c0      	nop			; (mov r8, r8)
 800030e:	46c0      	nop			; (mov r8, r8)

08000310 <writet.6312.4338>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8000310:	b500      	push	{lr}
 8000312:	b085      	sub	sp, #20
 8000314:	9003      	str	r0, [sp, #12]
 8000316:	9102      	str	r1, [sp, #8]
 8000318:	9201      	str	r2, [sp, #4]
 800031a:	1c1a      	adds	r2, r3, #0
 800031c:	466b      	mov	r3, sp
 800031e:	3302      	adds	r3, #2
 8000320:	801a      	strh	r2, [r3, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000322:	9b03      	ldr	r3, [sp, #12]
 8000324:	1c18      	adds	r0, r3, #0
 8000326:	3030      	adds	r0, #48	; 0x30
 8000328:	9902      	ldr	r1, [sp, #8]
 800032a:	9a01      	ldr	r2, [sp, #4]
 800032c:	466b      	mov	r3, sp
 800032e:	3302      	adds	r3, #2
 8000330:	881b      	ldrh	r3, [r3, #0]
 8000332:	f001 f89d 	bl	8001470 <oqWriteTimeout>
 8000336:	1c03      	adds	r3, r0, #0
}
 8000338:	1c18      	adds	r0, r3, #0
 800033a:	b005      	add	sp, #20
 800033c:	bd00      	pop	{pc}
 800033e:	46c0      	nop			; (mov r8, r8)

08000340 <readt.6326.4332>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8000340:	b500      	push	{lr}
 8000342:	b085      	sub	sp, #20
 8000344:	9003      	str	r0, [sp, #12]
 8000346:	9102      	str	r1, [sp, #8]
 8000348:	9201      	str	r2, [sp, #4]
 800034a:	1c1a      	adds	r2, r3, #0
 800034c:	466b      	mov	r3, sp
 800034e:	3302      	adds	r3, #2
 8000350:	801a      	strh	r2, [r3, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000352:	9b03      	ldr	r3, [sp, #12]
 8000354:	1c18      	adds	r0, r3, #0
 8000356:	300c      	adds	r0, #12
 8000358:	9902      	ldr	r1, [sp, #8]
 800035a:	9a01      	ldr	r2, [sp, #4]
 800035c:	466b      	mov	r3, sp
 800035e:	3302      	adds	r3, #2
 8000360:	881b      	ldrh	r3, [r3, #0]
 8000362:	f000 ff7d 	bl	8001260 <iqReadTimeout>
 8000366:	1c03      	adds	r3, r0, #0
}
 8000368:	1c18      	adds	r0, r3, #0
 800036a:	b005      	add	sp, #20
 800036c:	bd00      	pop	{pc}
 800036e:	46c0      	nop			; (mov r8, r8)

08000370 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8000370:	b508      	push	{r3, lr}

  sd_lld_init();
 8000372:	f000 fc3d 	bl	8000bf0 <sd_lld_init.4165>
}
 8000376:	bd08      	pop	{r3, pc}
 8000378:	46c0      	nop			; (mov r8, r8)
 800037a:	46c0      	nop			; (mov r8, r8)
 800037c:	46c0      	nop			; (mov r8, r8)
 800037e:	46c0      	nop			; (mov r8, r8)

08000380 <sdObjectInit.4325>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000380:	b500      	push	{lr}
 8000382:	b087      	sub	sp, #28
 8000384:	9005      	str	r0, [sp, #20]
 8000386:	9104      	str	r1, [sp, #16]
 8000388:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 800038a:	9b05      	ldr	r3, [sp, #20]
 800038c:	4a13      	ldr	r2, [pc, #76]	; (80003dc <sdObjectInit.4325+0x5c>)
 800038e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8000390:	9b05      	ldr	r3, [sp, #20]
 8000392:	3304      	adds	r3, #4
 8000394:	1c18      	adds	r0, r3, #0
 8000396:	f001 f8c3 	bl	8001520 <osalEventObjectInit.6291>
  sdp->state = SD_STOP;
 800039a:	9b05      	ldr	r3, [sp, #20]
 800039c:	2201      	movs	r2, #1
 800039e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80003a0:	9b05      	ldr	r3, [sp, #20]
 80003a2:	1c19      	adds	r1, r3, #0
 80003a4:	310c      	adds	r1, #12
 80003a6:	9b05      	ldr	r3, [sp, #20]
 80003a8:	1c1a      	adds	r2, r3, #0
 80003aa:	3254      	adds	r2, #84	; 0x54
 80003ac:	9b04      	ldr	r3, [sp, #16]
 80003ae:	9805      	ldr	r0, [sp, #20]
 80003b0:	9000      	str	r0, [sp, #0]
 80003b2:	1c08      	adds	r0, r1, #0
 80003b4:	1c11      	adds	r1, r2, #0
 80003b6:	2210      	movs	r2, #16
 80003b8:	f000 fea2 	bl	8001100 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80003bc:	9b05      	ldr	r3, [sp, #20]
 80003be:	1c19      	adds	r1, r3, #0
 80003c0:	3130      	adds	r1, #48	; 0x30
 80003c2:	9b05      	ldr	r3, [sp, #20]
 80003c4:	1c1a      	adds	r2, r3, #0
 80003c6:	3264      	adds	r2, #100	; 0x64
 80003c8:	9b03      	ldr	r3, [sp, #12]
 80003ca:	9805      	ldr	r0, [sp, #20]
 80003cc:	9000      	str	r0, [sp, #0]
 80003ce:	1c08      	adds	r0, r1, #0
 80003d0:	1c11      	adds	r1, r2, #0
 80003d2:	2210      	movs	r2, #16
 80003d4:	f000 ff9c 	bl	8001310 <oqObjectInit>
}
 80003d8:	b007      	add	sp, #28
 80003da:	bd00      	pop	{pc}
 80003dc:	08002360 	.word	0x08002360

080003e0 <sdIncomingDataI.4314>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 80003e0:	b500      	push	{lr}
 80003e2:	b083      	sub	sp, #12
 80003e4:	9001      	str	r0, [sp, #4]
 80003e6:	1c0a      	adds	r2, r1, #0
 80003e8:	466b      	mov	r3, sp
 80003ea:	3303      	adds	r3, #3
 80003ec:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80003ee:	9b01      	ldr	r3, [sp, #4]
 80003f0:	695b      	ldr	r3, [r3, #20]
 80003f2:	2b00      	cmp	r3, #0
 80003f4:	d105      	bne.n	8000402 <sdIncomingDataI.4314+0x22>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 80003f6:	9b01      	ldr	r3, [sp, #4]
 80003f8:	3304      	adds	r3, #4
 80003fa:	1c18      	adds	r0, r3, #0
 80003fc:	2104      	movs	r1, #4
 80003fe:	f001 f897 	bl	8001530 <osalEventBroadcastFlagsI.6300>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8000402:	9b01      	ldr	r3, [sp, #4]
 8000404:	1c1a      	adds	r2, r3, #0
 8000406:	320c      	adds	r2, #12
 8000408:	466b      	mov	r3, sp
 800040a:	3303      	adds	r3, #3
 800040c:	781b      	ldrb	r3, [r3, #0]
 800040e:	1c10      	adds	r0, r2, #0
 8000410:	1c19      	adds	r1, r3, #0
 8000412:	f000 fe9d 	bl	8001150 <iqPutI>
 8000416:	1c03      	adds	r3, r0, #0
 8000418:	2b00      	cmp	r3, #0
 800041a:	da05      	bge.n	8000428 <sdIncomingDataI.4314+0x48>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 800041c:	9b01      	ldr	r3, [sp, #4]
 800041e:	3304      	adds	r3, #4
 8000420:	1c18      	adds	r0, r3, #0
 8000422:	2180      	movs	r1, #128	; 0x80
 8000424:	f001 f884 	bl	8001530 <osalEventBroadcastFlagsI.6300>
}
 8000428:	b003      	add	sp, #12
 800042a:	bd00      	pop	{pc}
 800042c:	46c0      	nop			; (mov r8, r8)
 800042e:	46c0      	nop			; (mov r8, r8)

08000430 <nvicEnableVector.4300>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000430:	b530      	push	{r4, r5, lr}
 8000432:	b083      	sub	sp, #12
 8000434:	9001      	str	r0, [sp, #4]
 8000436:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000438:	4b1d      	ldr	r3, [pc, #116]	; (80004b0 <nvicEnableVector.4300+0x80>)
 800043a:	9a01      	ldr	r2, [sp, #4]
 800043c:	0892      	lsrs	r2, r2, #2
 800043e:	491c      	ldr	r1, [pc, #112]	; (80004b0 <nvicEnableVector.4300+0x80>)
 8000440:	9801      	ldr	r0, [sp, #4]
 8000442:	0880      	lsrs	r0, r0, #2
 8000444:	30c0      	adds	r0, #192	; 0xc0
 8000446:	0080      	lsls	r0, r0, #2
 8000448:	5841      	ldr	r1, [r0, r1]
 800044a:	9c01      	ldr	r4, [sp, #4]
 800044c:	2003      	movs	r0, #3
 800044e:	4020      	ands	r0, r4
 8000450:	00c0      	lsls	r0, r0, #3
 8000452:	24ff      	movs	r4, #255	; 0xff
 8000454:	1c25      	adds	r5, r4, #0
 8000456:	4085      	lsls	r5, r0
 8000458:	1c28      	adds	r0, r5, #0
 800045a:	43c0      	mvns	r0, r0
 800045c:	4008      	ands	r0, r1
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 800045e:	9900      	ldr	r1, [sp, #0]
 8000460:	018c      	lsls	r4, r1, #6
 8000462:	9d01      	ldr	r5, [sp, #4]
 8000464:	2103      	movs	r1, #3
 8000466:	4029      	ands	r1, r5
 8000468:	00c9      	lsls	r1, r1, #3
 800046a:	1c25      	adds	r5, r4, #0
 800046c:	408d      	lsls	r5, r1
 800046e:	1c29      	adds	r1, r5, #0
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8000470:	4301      	orrs	r1, r0
 8000472:	32c0      	adds	r2, #192	; 0xc0
 8000474:	0092      	lsls	r2, r2, #2
 8000476:	50d1      	str	r1, [r2, r3]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000478:	4b0d      	ldr	r3, [pc, #52]	; (80004b0 <nvicEnableVector.4300+0x80>)
 800047a:	9a01      	ldr	r2, [sp, #4]
 800047c:	0952      	lsrs	r2, r2, #5
 800047e:	9801      	ldr	r0, [sp, #4]
 8000480:	211f      	movs	r1, #31
 8000482:	4001      	ands	r1, r0
 8000484:	2001      	movs	r0, #1
 8000486:	1c04      	adds	r4, r0, #0
 8000488:	408c      	lsls	r4, r1
 800048a:	1c21      	adds	r1, r4, #0
 800048c:	3260      	adds	r2, #96	; 0x60
 800048e:	0092      	lsls	r2, r2, #2
 8000490:	50d1      	str	r1, [r2, r3]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000492:	4b07      	ldr	r3, [pc, #28]	; (80004b0 <nvicEnableVector.4300+0x80>)
 8000494:	9a01      	ldr	r2, [sp, #4]
 8000496:	0952      	lsrs	r2, r2, #5
 8000498:	9801      	ldr	r0, [sp, #4]
 800049a:	211f      	movs	r1, #31
 800049c:	4001      	ands	r1, r0
 800049e:	2001      	movs	r0, #1
 80004a0:	1c05      	adds	r5, r0, #0
 80004a2:	408d      	lsls	r5, r1
 80004a4:	1c29      	adds	r1, r5, #0
 80004a6:	0092      	lsls	r2, r2, #2
 80004a8:	50d1      	str	r1, [r2, r3]
}
 80004aa:	b003      	add	sp, #12
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	46c0      	nop			; (mov r8, r8)
 80004b0:	e000e100 	.word	0xe000e100
 80004b4:	46c0      	nop			; (mov r8, r8)
 80004b6:	46c0      	nop			; (mov r8, r8)
 80004b8:	46c0      	nop			; (mov r8, r8)
 80004ba:	46c0      	nop			; (mov r8, r8)
 80004bc:	46c0      	nop			; (mov r8, r8)
 80004be:	46c0      	nop			; (mov r8, r8)

080004c0 <hal_lld_backup_domain_init.6570.4287>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80004c0:	4b15      	ldr	r3, [pc, #84]	; (8000518 <hal_lld_backup_domain_init.6570.4287+0x58>)
 80004c2:	4a15      	ldr	r2, [pc, #84]	; (8000518 <hal_lld_backup_domain_init.6570.4287+0x58>)
 80004c4:	6812      	ldr	r2, [r2, #0]
 80004c6:	2180      	movs	r1, #128	; 0x80
 80004c8:	0049      	lsls	r1, r1, #1
 80004ca:	430a      	orrs	r2, r1
 80004cc:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80004ce:	4b13      	ldr	r3, [pc, #76]	; (800051c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 80004d0:	6a1a      	ldr	r2, [r3, #32]
 80004d2:	23c0      	movs	r3, #192	; 0xc0
 80004d4:	009b      	lsls	r3, r3, #2
 80004d6:	401a      	ands	r2, r3
 80004d8:	2380      	movs	r3, #128	; 0x80
 80004da:	009b      	lsls	r3, r3, #2
 80004dc:	429a      	cmp	r2, r3
 80004de:	d006      	beq.n	80004ee <hal_lld_backup_domain_init.6570.4287+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80004e0:	4b0e      	ldr	r3, [pc, #56]	; (800051c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 80004e2:	2280      	movs	r2, #128	; 0x80
 80004e4:	0252      	lsls	r2, r2, #9
 80004e6:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 80004e8:	4b0c      	ldr	r3, [pc, #48]	; (800051c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 80004ea:	2200      	movs	r2, #0
 80004ec:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80004ee:	4b0b      	ldr	r3, [pc, #44]	; (800051c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 80004f0:	6a1a      	ldr	r2, [r3, #32]
 80004f2:	2380      	movs	r3, #128	; 0x80
 80004f4:	021b      	lsls	r3, r3, #8
 80004f6:	4013      	ands	r3, r2
 80004f8:	d10d      	bne.n	8000516 <hal_lld_backup_domain_init.6570.4287+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80004fa:	4b08      	ldr	r3, [pc, #32]	; (800051c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 80004fc:	4a07      	ldr	r2, [pc, #28]	; (800051c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 80004fe:	6a12      	ldr	r2, [r2, #32]
 8000500:	2180      	movs	r1, #128	; 0x80
 8000502:	0089      	lsls	r1, r1, #2
 8000504:	430a      	orrs	r2, r1
 8000506:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000508:	4b04      	ldr	r3, [pc, #16]	; (800051c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 800050a:	4a04      	ldr	r2, [pc, #16]	; (800051c <hal_lld_backup_domain_init.6570.4287+0x5c>)
 800050c:	6a12      	ldr	r2, [r2, #32]
 800050e:	2180      	movs	r1, #128	; 0x80
 8000510:	0209      	lsls	r1, r1, #8
 8000512:	430a      	orrs	r2, r1
 8000514:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 8000516:	4770      	bx	lr
 8000518:	40007000 	.word	0x40007000
 800051c:	40021000 	.word	0x40021000

08000520 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8000520:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000522:	4b12      	ldr	r3, [pc, #72]	; (800056c <hal_lld_init+0x4c>)
 8000524:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000526:	4b11      	ldr	r3, [pc, #68]	; (800056c <hal_lld_init+0x4c>)
 8000528:	2201      	movs	r2, #1
 800052a:	4252      	negs	r2, r2
 800052c:	629a      	str	r2, [r3, #40]	; 0x28
 800052e:	4b0f      	ldr	r3, [pc, #60]	; (800056c <hal_lld_init+0x4c>)
 8000530:	2200      	movs	r2, #0
 8000532:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000534:	4b0d      	ldr	r3, [pc, #52]	; (800056c <hal_lld_init+0x4c>)
 8000536:	691b      	ldr	r3, [r3, #16]
 8000538:	4b0c      	ldr	r3, [pc, #48]	; (800056c <hal_lld_init+0x4c>)
 800053a:	2201      	movs	r2, #1
 800053c:	4252      	negs	r2, r2
 800053e:	611a      	str	r2, [r3, #16]
 8000540:	4b0a      	ldr	r3, [pc, #40]	; (800056c <hal_lld_init+0x4c>)
 8000542:	2200      	movs	r2, #0
 8000544:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000546:	4b09      	ldr	r3, [pc, #36]	; (800056c <hal_lld_init+0x4c>)
 8000548:	4a08      	ldr	r2, [pc, #32]	; (800056c <hal_lld_init+0x4c>)
 800054a:	68d2      	ldr	r2, [r2, #12]
 800054c:	4908      	ldr	r1, [pc, #32]	; (8000570 <hal_lld_init+0x50>)
 800054e:	430a      	orrs	r2, r1
 8000550:	60da      	str	r2, [r3, #12]
 8000552:	4b06      	ldr	r3, [pc, #24]	; (800056c <hal_lld_init+0x4c>)
 8000554:	2200      	movs	r2, #0
 8000556:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000558:	4b04      	ldr	r3, [pc, #16]	; (800056c <hal_lld_init+0x4c>)
 800055a:	4a04      	ldr	r2, [pc, #16]	; (800056c <hal_lld_init+0x4c>)
 800055c:	69d2      	ldr	r2, [r2, #28]
 800055e:	2180      	movs	r1, #128	; 0x80
 8000560:	0549      	lsls	r1, r1, #21
 8000562:	430a      	orrs	r2, r1
 8000564:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8000566:	f7ff ffab 	bl	80004c0 <hal_lld_backup_domain_init.6570.4287>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800056a:	bd08      	pop	{r3, pc}
 800056c:	40021000 	.word	0x40021000
 8000570:	ffbfffff 	.word	0xffbfffff
 8000574:	46c0      	nop			; (mov r8, r8)
 8000576:	46c0      	nop			; (mov r8, r8)
 8000578:	46c0      	nop			; (mov r8, r8)
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	46c0      	nop			; (mov r8, r8)
 800057e:	46c0      	nop			; (mov r8, r8)

08000580 <stm32_clock_init.4282>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000580:	4b32      	ldr	r3, [pc, #200]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000582:	4a32      	ldr	r2, [pc, #200]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000584:	6812      	ldr	r2, [r2, #0]
 8000586:	2101      	movs	r1, #1
 8000588:	430a      	orrs	r2, r1
 800058a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800058c:	4b2f      	ldr	r3, [pc, #188]	; (800064c <stm32_clock_init.4282+0xcc>)
 800058e:	681a      	ldr	r2, [r3, #0]
 8000590:	2302      	movs	r3, #2
 8000592:	4013      	ands	r3, r2
 8000594:	d0fa      	beq.n	800058c <stm32_clock_init.4282+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000596:	4b2d      	ldr	r3, [pc, #180]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000598:	4a2c      	ldr	r2, [pc, #176]	; (800064c <stm32_clock_init.4282+0xcc>)
 800059a:	6852      	ldr	r2, [r2, #4]
 800059c:	2103      	movs	r1, #3
 800059e:	438a      	bics	r2, r1
 80005a0:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80005a2:	4b2a      	ldr	r3, [pc, #168]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005a4:	4a29      	ldr	r2, [pc, #164]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005a6:	6852      	ldr	r2, [r2, #4]
 80005a8:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80005aa:	4b28      	ldr	r3, [pc, #160]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005ac:	685a      	ldr	r2, [r3, #4]
 80005ae:	230c      	movs	r3, #12
 80005b0:	4013      	ands	r3, r2
 80005b2:	d1fa      	bne.n	80005aa <stm32_clock_init.4282+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80005b4:	4b25      	ldr	r3, [pc, #148]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005b6:	4a25      	ldr	r2, [pc, #148]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005b8:	6811      	ldr	r1, [r2, #0]
 80005ba:	22f9      	movs	r2, #249	; 0xf9
 80005bc:	400a      	ands	r2, r1
 80005be:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80005c0:	4b22      	ldr	r3, [pc, #136]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005c2:	2200      	movs	r2, #0
 80005c4:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 80005c6:	4b21      	ldr	r3, [pc, #132]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005c8:	4a20      	ldr	r2, [pc, #128]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005ca:	6b52      	ldr	r2, [r2, #52]	; 0x34
 80005cc:	2101      	movs	r1, #1
 80005ce:	430a      	orrs	r2, r1
 80005d0:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 80005d2:	4b1e      	ldr	r3, [pc, #120]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005d4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80005d6:	2302      	movs	r3, #2
 80005d8:	4013      	ands	r3, r2
 80005da:	d0fa      	beq.n	80005d2 <stm32_clock_init.4282+0x52>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80005dc:	4b1b      	ldr	r3, [pc, #108]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005de:	4a1b      	ldr	r2, [pc, #108]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005e0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80005e2:	2101      	movs	r1, #1
 80005e4:	430a      	orrs	r2, r1
 80005e6:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80005e8:	4b18      	ldr	r3, [pc, #96]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005ea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80005ec:	2302      	movs	r3, #2
 80005ee:	4013      	ands	r3, r2
 80005f0:	d0fa      	beq.n	80005e8 <stm32_clock_init.4282+0x68>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 80005f2:	4b16      	ldr	r3, [pc, #88]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005f4:	22a0      	movs	r2, #160	; 0xa0
 80005f6:	0392      	lsls	r2, r2, #14
 80005f8:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80005fa:	4b14      	ldr	r3, [pc, #80]	; (800064c <stm32_clock_init.4282+0xcc>)
 80005fc:	2200      	movs	r2, #0
 80005fe:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8000600:	4b12      	ldr	r3, [pc, #72]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000602:	2200      	movs	r2, #0
 8000604:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000606:	4b11      	ldr	r3, [pc, #68]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000608:	4a10      	ldr	r2, [pc, #64]	; (800064c <stm32_clock_init.4282+0xcc>)
 800060a:	6812      	ldr	r2, [r2, #0]
 800060c:	2180      	movs	r1, #128	; 0x80
 800060e:	0449      	lsls	r1, r1, #17
 8000610:	430a      	orrs	r2, r1
 8000612:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000614:	4b0d      	ldr	r3, [pc, #52]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000616:	681a      	ldr	r2, [r3, #0]
 8000618:	2380      	movs	r3, #128	; 0x80
 800061a:	049b      	lsls	r3, r3, #18
 800061c:	4013      	ands	r3, r2
 800061e:	d0f9      	beq.n	8000614 <stm32_clock_init.4282+0x94>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000620:	4b0b      	ldr	r3, [pc, #44]	; (8000650 <stm32_clock_init.4282+0xd0>)
 8000622:	2211      	movs	r2, #17
 8000624:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8000626:	4b09      	ldr	r3, [pc, #36]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000628:	4a08      	ldr	r2, [pc, #32]	; (800064c <stm32_clock_init.4282+0xcc>)
 800062a:	6852      	ldr	r2, [r2, #4]
 800062c:	2102      	movs	r1, #2
 800062e:	430a      	orrs	r2, r1
 8000630:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000632:	4b06      	ldr	r3, [pc, #24]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000634:	685a      	ldr	r2, [r3, #4]
 8000636:	230c      	movs	r3, #12
 8000638:	4013      	ands	r3, r2
 800063a:	2b08      	cmp	r3, #8
 800063c:	d1f9      	bne.n	8000632 <stm32_clock_init.4282+0xb2>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800063e:	4b03      	ldr	r3, [pc, #12]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000640:	4a02      	ldr	r2, [pc, #8]	; (800064c <stm32_clock_init.4282+0xcc>)
 8000642:	6992      	ldr	r2, [r2, #24]
 8000644:	2101      	movs	r1, #1
 8000646:	430a      	orrs	r2, r1
 8000648:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 800064a:	4770      	bx	lr
 800064c:	40021000 	.word	0x40021000
 8000650:	40022000 	.word	0x40022000
 8000654:	46c0      	nop			; (mov r8, r8)
 8000656:	46c0      	nop			; (mov r8, r8)
 8000658:	46c0      	nop			; (mov r8, r8)
 800065a:	46c0      	nop			; (mov r8, r8)
 800065c:	46c0      	nop			; (mov r8, r8)
 800065e:	46c0      	nop			; (mov r8, r8)

08000660 <port_lock.6611.4280>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000660:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000662:	4770      	bx	lr
 8000664:	46c0      	nop			; (mov r8, r8)
 8000666:	46c0      	nop			; (mov r8, r8)
 8000668:	46c0      	nop			; (mov r8, r8)
 800066a:	46c0      	nop			; (mov r8, r8)
 800066c:	46c0      	nop			; (mov r8, r8)
 800066e:	46c0      	nop			; (mov r8, r8)

08000670 <port_unlock.6614.4278>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000670:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000672:	4770      	bx	lr
 8000674:	46c0      	nop			; (mov r8, r8)
 8000676:	46c0      	nop			; (mov r8, r8)
 8000678:	46c0      	nop			; (mov r8, r8)
 800067a:	46c0      	nop			; (mov r8, r8)
 800067c:	46c0      	nop			; (mov r8, r8)
 800067e:	46c0      	nop			; (mov r8, r8)

08000680 <port_lock_from_isr.6616.4276>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000680:	b508      	push	{r3, lr}

  port_lock();
 8000682:	f7ff ffed 	bl	8000660 <port_lock.6611.4280>
}
 8000686:	bd08      	pop	{r3, pc}
 8000688:	46c0      	nop			; (mov r8, r8)
 800068a:	46c0      	nop			; (mov r8, r8)
 800068c:	46c0      	nop			; (mov r8, r8)
 800068e:	46c0      	nop			; (mov r8, r8)

08000690 <port_unlock_from_isr.6618.4274>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000690:	b508      	push	{r3, lr}

  port_unlock();
 8000692:	f7ff ffed 	bl	8000670 <port_unlock.6614.4278>
}
 8000696:	bd08      	pop	{r3, pc}
 8000698:	46c0      	nop			; (mov r8, r8)
 800069a:	46c0      	nop			; (mov r8, r8)
 800069c:	46c0      	nop			; (mov r8, r8)
 800069e:	46c0      	nop			; (mov r8, r8)

080006a0 <chSysLockFromISR.6620.4272>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80006a0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80006a2:	f7ff ffed 	bl	8000680 <port_lock_from_isr.6616.4276>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80006a6:	bd08      	pop	{r3, pc}
 80006a8:	46c0      	nop			; (mov r8, r8)
 80006aa:	46c0      	nop			; (mov r8, r8)
 80006ac:	46c0      	nop			; (mov r8, r8)
 80006ae:	46c0      	nop			; (mov r8, r8)

080006b0 <chSysUnlockFromISR.6622.4270>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80006b0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80006b2:	f7ff ffed 	bl	8000690 <port_unlock_from_isr.6618.4274>
}
 80006b6:	bd08      	pop	{r3, pc}
 80006b8:	46c0      	nop			; (mov r8, r8)
 80006ba:	46c0      	nop			; (mov r8, r8)
 80006bc:	46c0      	nop			; (mov r8, r8)
 80006be:	46c0      	nop			; (mov r8, r8)

080006c0 <osalSysLockFromISR.6624.4268>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80006c0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80006c2:	f7ff ffed 	bl	80006a0 <chSysLockFromISR.6620.4272>
}
 80006c6:	bd08      	pop	{r3, pc}
 80006c8:	46c0      	nop			; (mov r8, r8)
 80006ca:	46c0      	nop			; (mov r8, r8)
 80006cc:	46c0      	nop			; (mov r8, r8)
 80006ce:	46c0      	nop			; (mov r8, r8)

080006d0 <osalSysUnlockFromISR.6626.4266>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80006d0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80006d2:	f7ff ffed 	bl	80006b0 <chSysUnlockFromISR.6622.4270>
}
 80006d6:	bd08      	pop	{r3, pc}
 80006d8:	46c0      	nop			; (mov r8, r8)
 80006da:	46c0      	nop			; (mov r8, r8)
 80006dc:	46c0      	nop			; (mov r8, r8)
 80006de:	46c0      	nop			; (mov r8, r8)

080006e0 <osalOsTimerHandlerI.6628.4264>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 80006e0:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 80006e2:	f001 f91d 	bl	8001920 <chSysTimerHandlerI>
}
 80006e6:	bd08      	pop	{r3, pc}
 80006e8:	46c0      	nop			; (mov r8, r8)
 80006ea:	46c0      	nop			; (mov r8, r8)
 80006ec:	46c0      	nop			; (mov r8, r8)
 80006ee:	46c0      	nop			; (mov r8, r8)

080006f0 <Vector80.4262>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80006f0:	b500      	push	{lr}
 80006f2:	b083      	sub	sp, #12
 80006f4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80006f6:	9301      	str	r3, [sp, #4]

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80006f8:	4b09      	ldr	r3, [pc, #36]	; (8000720 <Vector80.4262+0x30>)
 80006fa:	691a      	ldr	r2, [r3, #16]
 80006fc:	2302      	movs	r3, #2
 80006fe:	4013      	ands	r3, r2
 8000700:	d008      	beq.n	8000714 <Vector80.4262+0x24>
    STM32_ST_TIM->SR = 0U;
 8000702:	4b07      	ldr	r3, [pc, #28]	; (8000720 <Vector80.4262+0x30>)
 8000704:	2200      	movs	r2, #0
 8000706:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 8000708:	f7ff ffda 	bl	80006c0 <osalSysLockFromISR.6624.4268>
    osalOsTimerHandlerI();
 800070c:	f7ff ffe8 	bl	80006e0 <osalOsTimerHandlerI.6628.4264>
    osalSysUnlockFromISR();
 8000710:	f7ff ffde 	bl	80006d0 <osalSysUnlockFromISR.6626.4266>
  }

  OSAL_IRQ_EPILOGUE();
 8000714:	9b01      	ldr	r3, [sp, #4]
 8000716:	1c18      	adds	r0, r3, #0
 8000718:	f000 fbba 	bl	8000e90 <_port_irq_epilogue>
}
 800071c:	b003      	add	sp, #12
 800071e:	bd00      	pop	{pc}
 8000720:	40000400 	.word	0x40000400
 8000724:	46c0      	nop			; (mov r8, r8)
 8000726:	46c0      	nop			; (mov r8, r8)
 8000728:	46c0      	nop			; (mov r8, r8)
 800072a:	46c0      	nop			; (mov r8, r8)
 800072c:	46c0      	nop			; (mov r8, r8)
 800072e:	46c0      	nop			; (mov r8, r8)

08000730 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8000730:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000732:	4b14      	ldr	r3, [pc, #80]	; (8000784 <st_lld_init+0x54>)
 8000734:	4a13      	ldr	r2, [pc, #76]	; (8000784 <st_lld_init+0x54>)
 8000736:	69d2      	ldr	r2, [r2, #28]
 8000738:	2102      	movs	r1, #2
 800073a:	430a      	orrs	r2, r1
 800073c:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800073e:	4b12      	ldr	r3, [pc, #72]	; (8000788 <st_lld_init+0x58>)
 8000740:	4a11      	ldr	r2, [pc, #68]	; (8000788 <st_lld_init+0x58>)
 8000742:	6892      	ldr	r2, [r2, #8]
 8000744:	2102      	movs	r1, #2
 8000746:	430a      	orrs	r2, r1
 8000748:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800074a:	4b10      	ldr	r3, [pc, #64]	; (800078c <st_lld_init+0x5c>)
 800074c:	4a10      	ldr	r2, [pc, #64]	; (8000790 <st_lld_init+0x60>)
 800074e:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000750:	4b0e      	ldr	r3, [pc, #56]	; (800078c <st_lld_init+0x5c>)
 8000752:	4a10      	ldr	r2, [pc, #64]	; (8000794 <st_lld_init+0x64>)
 8000754:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8000756:	4b0d      	ldr	r3, [pc, #52]	; (800078c <st_lld_init+0x5c>)
 8000758:	2200      	movs	r2, #0
 800075a:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 800075c:	4b0b      	ldr	r3, [pc, #44]	; (800078c <st_lld_init+0x5c>)
 800075e:	2200      	movs	r2, #0
 8000760:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8000762:	4b0a      	ldr	r3, [pc, #40]	; (800078c <st_lld_init+0x5c>)
 8000764:	2200      	movs	r2, #0
 8000766:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000768:	4b08      	ldr	r3, [pc, #32]	; (800078c <st_lld_init+0x5c>)
 800076a:	2200      	movs	r2, #0
 800076c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800076e:	4b07      	ldr	r3, [pc, #28]	; (800078c <st_lld_init+0x5c>)
 8000770:	2201      	movs	r2, #1
 8000772:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000774:	4b05      	ldr	r3, [pc, #20]	; (800078c <st_lld_init+0x5c>)
 8000776:	2201      	movs	r2, #1
 8000778:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800077a:	2010      	movs	r0, #16
 800077c:	2102      	movs	r1, #2
 800077e:	f7ff fe57 	bl	8000430 <nvicEnableVector.4300>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8000782:	bd08      	pop	{r3, pc}
 8000784:	40021000 	.word	0x40021000
 8000788:	40015800 	.word	0x40015800
 800078c:	40000400 	.word	0x40000400
 8000790:	000012bf 	.word	0x000012bf
 8000794:	0000ffff 	.word	0x0000ffff
 8000798:	46c0      	nop			; (mov r8, r8)
 800079a:	46c0      	nop			; (mov r8, r8)
 800079c:	46c0      	nop			; (mov r8, r8)
 800079e:	46c0      	nop			; (mov r8, r8)

080007a0 <initgpio.6689.4254>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 80007a0:	b082      	sub	sp, #8
 80007a2:	9001      	str	r0, [sp, #4]
 80007a4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 80007a6:	9b00      	ldr	r3, [sp, #0]
 80007a8:	685a      	ldr	r2, [r3, #4]
 80007aa:	9b01      	ldr	r3, [sp, #4]
 80007ac:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80007ae:	9b00      	ldr	r3, [sp, #0]
 80007b0:	689a      	ldr	r2, [r3, #8]
 80007b2:	9b01      	ldr	r3, [sp, #4]
 80007b4:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80007b6:	9b00      	ldr	r3, [sp, #0]
 80007b8:	68da      	ldr	r2, [r3, #12]
 80007ba:	9b01      	ldr	r3, [sp, #4]
 80007bc:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80007be:	9b00      	ldr	r3, [sp, #0]
 80007c0:	691a      	ldr	r2, [r3, #16]
 80007c2:	9b01      	ldr	r3, [sp, #4]
 80007c4:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80007c6:	9b00      	ldr	r3, [sp, #0]
 80007c8:	695a      	ldr	r2, [r3, #20]
 80007ca:	9b01      	ldr	r3, [sp, #4]
 80007cc:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80007ce:	9b00      	ldr	r3, [sp, #0]
 80007d0:	699a      	ldr	r2, [r3, #24]
 80007d2:	9b01      	ldr	r3, [sp, #4]
 80007d4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80007d6:	9b00      	ldr	r3, [sp, #0]
 80007d8:	681a      	ldr	r2, [r3, #0]
 80007da:	9b01      	ldr	r3, [sp, #4]
 80007dc:	601a      	str	r2, [r3, #0]
}
 80007de:	b002      	add	sp, #8
 80007e0:	4770      	bx	lr
 80007e2:	46c0      	nop			; (mov r8, r8)
 80007e4:	46c0      	nop			; (mov r8, r8)
 80007e6:	46c0      	nop			; (mov r8, r8)
 80007e8:	46c0      	nop			; (mov r8, r8)
 80007ea:	46c0      	nop			; (mov r8, r8)
 80007ec:	46c0      	nop			; (mov r8, r8)
 80007ee:	46c0      	nop			; (mov r8, r8)

080007f0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 80007f0:	b500      	push	{lr}
 80007f2:	b083      	sub	sp, #12
 80007f4:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 80007f6:	4b12      	ldr	r3, [pc, #72]	; (8000840 <_pal_lld_init+0x50>)
 80007f8:	4a11      	ldr	r2, [pc, #68]	; (8000840 <_pal_lld_init+0x50>)
 80007fa:	6952      	ldr	r2, [r2, #20]
 80007fc:	219c      	movs	r1, #156	; 0x9c
 80007fe:	03c9      	lsls	r1, r1, #15
 8000800:	430a      	orrs	r2, r1
 8000802:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8000804:	9b01      	ldr	r3, [sp, #4]
 8000806:	2290      	movs	r2, #144	; 0x90
 8000808:	05d2      	lsls	r2, r2, #23
 800080a:	1c10      	adds	r0, r2, #0
 800080c:	1c19      	adds	r1, r3, #0
 800080e:	f7ff ffc7 	bl	80007a0 <initgpio.6689.4254>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 8000812:	9b01      	ldr	r3, [sp, #4]
 8000814:	331c      	adds	r3, #28
 8000816:	4a0b      	ldr	r2, [pc, #44]	; (8000844 <_pal_lld_init+0x54>)
 8000818:	1c10      	adds	r0, r2, #0
 800081a:	1c19      	adds	r1, r3, #0
 800081c:	f7ff ffc0 	bl	80007a0 <initgpio.6689.4254>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 8000820:	9b01      	ldr	r3, [sp, #4]
 8000822:	3338      	adds	r3, #56	; 0x38
 8000824:	4a08      	ldr	r2, [pc, #32]	; (8000848 <_pal_lld_init+0x58>)
 8000826:	1c10      	adds	r0, r2, #0
 8000828:	1c19      	adds	r1, r3, #0
 800082a:	f7ff ffb9 	bl	80007a0 <initgpio.6689.4254>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 800082e:	9b01      	ldr	r3, [sp, #4]
 8000830:	3354      	adds	r3, #84	; 0x54
 8000832:	4a06      	ldr	r2, [pc, #24]	; (800084c <_pal_lld_init+0x5c>)
 8000834:	1c10      	adds	r0, r2, #0
 8000836:	1c19      	adds	r1, r3, #0
 8000838:	f7ff ffb2 	bl	80007a0 <initgpio.6689.4254>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 800083c:	b003      	add	sp, #12
 800083e:	bd00      	pop	{pc}
 8000840:	40021000 	.word	0x40021000
 8000844:	48000400 	.word	0x48000400
 8000848:	48000800 	.word	0x48000800
 800084c:	48001400 	.word	0x48001400

08000850 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8000850:	b08e      	sub	sp, #56	; 0x38
 8000852:	9003      	str	r0, [sp, #12]
 8000854:	9102      	str	r1, [sp, #8]
 8000856:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000858:	9a01      	ldr	r2, [sp, #4]
 800085a:	2303      	movs	r3, #3
 800085c:	4013      	ands	r3, r2
 800085e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000860:	9a01      	ldr	r2, [sp, #4]
 8000862:	2304      	movs	r3, #4
 8000864:	4013      	ands	r3, r2
 8000866:	089b      	lsrs	r3, r3, #2
 8000868:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800086a:	9a01      	ldr	r2, [sp, #4]
 800086c:	2318      	movs	r3, #24
 800086e:	4013      	ands	r3, r2
 8000870:	08db      	lsrs	r3, r3, #3
 8000872:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8000874:	9a01      	ldr	r2, [sp, #4]
 8000876:	2360      	movs	r3, #96	; 0x60
 8000878:	4013      	ands	r3, r2
 800087a:	095b      	lsrs	r3, r3, #5
 800087c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800087e:	9a01      	ldr	r2, [sp, #4]
 8000880:	23f0      	movs	r3, #240	; 0xf0
 8000882:	00db      	lsls	r3, r3, #3
 8000884:	4013      	ands	r3, r2
 8000886:	09db      	lsrs	r3, r3, #7
 8000888:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 800088a:	2300      	movs	r3, #0
 800088c:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800088e:	9a02      	ldr	r2, [sp, #8]
 8000890:	2301      	movs	r3, #1
 8000892:	4013      	ands	r3, r2
 8000894:	d058      	beq.n	8000948 <_pal_lld_setgroupmode+0xf8>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000896:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8000898:	2307      	movs	r3, #7
 800089a:	4013      	ands	r3, r2
 800089c:	009b      	lsls	r3, r3, #2
 800089e:	9a08      	ldr	r2, [sp, #32]
 80008a0:	1c11      	adds	r1, r2, #0
 80008a2:	4099      	lsls	r1, r3
 80008a4:	1c0b      	adds	r3, r1, #0
 80008a6:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
 80008a8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80008aa:	2307      	movs	r3, #7
 80008ac:	4013      	ands	r3, r2
 80008ae:	009b      	lsls	r3, r3, #2
 80008b0:	220f      	movs	r2, #15
 80008b2:	1c11      	adds	r1, r2, #0
 80008b4:	4099      	lsls	r1, r3
 80008b6:	1c0b      	adds	r3, r1, #0
 80008b8:	9306      	str	r3, [sp, #24]
      if (bit < 8)
 80008ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008bc:	2b07      	cmp	r3, #7
 80008be:	d809      	bhi.n	80008d4 <_pal_lld_setgroupmode+0x84>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 80008c0:	9b03      	ldr	r3, [sp, #12]
 80008c2:	6a1b      	ldr	r3, [r3, #32]
 80008c4:	9a06      	ldr	r2, [sp, #24]
 80008c6:	43d2      	mvns	r2, r2
 80008c8:	401a      	ands	r2, r3
 80008ca:	9b07      	ldr	r3, [sp, #28]
 80008cc:	431a      	orrs	r2, r3
 80008ce:	9b03      	ldr	r3, [sp, #12]
 80008d0:	621a      	str	r2, [r3, #32]
 80008d2:	e008      	b.n	80008e6 <_pal_lld_setgroupmode+0x96>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 80008d4:	9b03      	ldr	r3, [sp, #12]
 80008d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80008d8:	9a06      	ldr	r2, [sp, #24]
 80008da:	43d2      	mvns	r2, r2
 80008dc:	401a      	ands	r2, r3
 80008de:	9b07      	ldr	r3, [sp, #28]
 80008e0:	431a      	orrs	r2, r3
 80008e2:	9b03      	ldr	r3, [sp, #12]
 80008e4:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
 80008e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008e8:	2201      	movs	r2, #1
 80008ea:	1c11      	adds	r1, r2, #0
 80008ec:	4099      	lsls	r1, r3
 80008ee:	1c0b      	adds	r3, r1, #0
 80008f0:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80008f2:	9b03      	ldr	r3, [sp, #12]
 80008f4:	685b      	ldr	r3, [r3, #4]
 80008f6:	9a05      	ldr	r2, [sp, #20]
 80008f8:	43d2      	mvns	r2, r2
 80008fa:	401a      	ands	r2, r3
 80008fc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80008fe:	431a      	orrs	r2, r3
 8000900:	9b03      	ldr	r3, [sp, #12]
 8000902:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
 8000904:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000906:	005b      	lsls	r3, r3, #1
 8000908:	2203      	movs	r2, #3
 800090a:	1c11      	adds	r1, r2, #0
 800090c:	4099      	lsls	r1, r3
 800090e:	1c0b      	adds	r3, r1, #0
 8000910:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000912:	9b03      	ldr	r3, [sp, #12]
 8000914:	689b      	ldr	r3, [r3, #8]
 8000916:	9a04      	ldr	r2, [sp, #16]
 8000918:	43d2      	mvns	r2, r2
 800091a:	401a      	ands	r2, r3
 800091c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800091e:	431a      	orrs	r2, r3
 8000920:	9b03      	ldr	r3, [sp, #12]
 8000922:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000924:	9b03      	ldr	r3, [sp, #12]
 8000926:	68db      	ldr	r3, [r3, #12]
 8000928:	9a04      	ldr	r2, [sp, #16]
 800092a:	43d2      	mvns	r2, r2
 800092c:	401a      	ands	r2, r3
 800092e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000930:	431a      	orrs	r2, r3
 8000932:	9b03      	ldr	r3, [sp, #12]
 8000934:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 8000936:	9b03      	ldr	r3, [sp, #12]
 8000938:	681b      	ldr	r3, [r3, #0]
 800093a:	9a04      	ldr	r2, [sp, #16]
 800093c:	43d2      	mvns	r2, r2
 800093e:	401a      	ands	r2, r3
 8000940:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8000942:	431a      	orrs	r2, r3
 8000944:	9b03      	ldr	r3, [sp, #12]
 8000946:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
 8000948:	9b02      	ldr	r3, [sp, #8]
 800094a:	085b      	lsrs	r3, r3, #1
 800094c:	9302      	str	r3, [sp, #8]
    if (!mask)
 800094e:	9b02      	ldr	r3, [sp, #8]
 8000950:	2b00      	cmp	r3, #0
 8000952:	d00f      	beq.n	8000974 <_pal_lld_setgroupmode+0x124>
      return;
    otyper <<= 1;
 8000954:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000956:	005b      	lsls	r3, r3, #1
 8000958:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 800095a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800095c:	009b      	lsls	r3, r3, #2
 800095e:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8000960:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000962:	009b      	lsls	r3, r3, #2
 8000964:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8000966:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8000968:	009b      	lsls	r3, r3, #2
 800096a:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800096c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800096e:	3301      	adds	r3, #1
 8000970:	9309      	str	r3, [sp, #36]	; 0x24
 8000972:	e78c      	b.n	800088e <_pal_lld_setgroupmode+0x3e>
  }
}
 8000974:	b00e      	add	sp, #56	; 0x38
 8000976:	4770      	bx	lr
 8000978:	46c0      	nop			; (mov r8, r8)
 800097a:	46c0      	nop			; (mov r8, r8)
 800097c:	46c0      	nop			; (mov r8, r8)
 800097e:	46c0      	nop			; (mov r8, r8)

08000980 <port_lock.6760.4204>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000980:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000982:	4770      	bx	lr
 8000984:	46c0      	nop			; (mov r8, r8)
 8000986:	46c0      	nop			; (mov r8, r8)
 8000988:	46c0      	nop			; (mov r8, r8)
 800098a:	46c0      	nop			; (mov r8, r8)
 800098c:	46c0      	nop			; (mov r8, r8)
 800098e:	46c0      	nop			; (mov r8, r8)

08000990 <port_unlock.6763.4202>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000990:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000992:	4770      	bx	lr
 8000994:	46c0      	nop			; (mov r8, r8)
 8000996:	46c0      	nop			; (mov r8, r8)
 8000998:	46c0      	nop			; (mov r8, r8)
 800099a:	46c0      	nop			; (mov r8, r8)
 800099c:	46c0      	nop			; (mov r8, r8)
 800099e:	46c0      	nop			; (mov r8, r8)

080009a0 <port_lock_from_isr.6765.4200>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80009a0:	b508      	push	{r3, lr}

  port_lock();
 80009a2:	f7ff ffed 	bl	8000980 <port_lock.6760.4204>
}
 80009a6:	bd08      	pop	{r3, pc}
 80009a8:	46c0      	nop			; (mov r8, r8)
 80009aa:	46c0      	nop			; (mov r8, r8)
 80009ac:	46c0      	nop			; (mov r8, r8)
 80009ae:	46c0      	nop			; (mov r8, r8)

080009b0 <port_unlock_from_isr.6767.4198>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80009b0:	b508      	push	{r3, lr}

  port_unlock();
 80009b2:	f7ff ffed 	bl	8000990 <port_unlock.6763.4202>
}
 80009b6:	bd08      	pop	{r3, pc}
 80009b8:	46c0      	nop			; (mov r8, r8)
 80009ba:	46c0      	nop			; (mov r8, r8)
 80009bc:	46c0      	nop			; (mov r8, r8)
 80009be:	46c0      	nop			; (mov r8, r8)

080009c0 <chSysLockFromISR.6769.4196>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80009c0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80009c2:	f7ff ffed 	bl	80009a0 <port_lock_from_isr.6765.4200>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80009c6:	bd08      	pop	{r3, pc}
 80009c8:	46c0      	nop			; (mov r8, r8)
 80009ca:	46c0      	nop			; (mov r8, r8)
 80009cc:	46c0      	nop			; (mov r8, r8)
 80009ce:	46c0      	nop			; (mov r8, r8)

080009d0 <chSysUnlockFromISR.6771.4194>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80009d0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80009d2:	f7ff ffed 	bl	80009b0 <port_unlock_from_isr.6767.4198>
}
 80009d6:	bd08      	pop	{r3, pc}
 80009d8:	46c0      	nop			; (mov r8, r8)
 80009da:	46c0      	nop			; (mov r8, r8)
 80009dc:	46c0      	nop			; (mov r8, r8)
 80009de:	46c0      	nop			; (mov r8, r8)

080009e0 <osalSysLockFromISR.6773.4192>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80009e0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80009e2:	f7ff ffed 	bl	80009c0 <chSysLockFromISR.6769.4196>
}
 80009e6:	bd08      	pop	{r3, pc}
 80009e8:	46c0      	nop			; (mov r8, r8)
 80009ea:	46c0      	nop			; (mov r8, r8)
 80009ec:	46c0      	nop			; (mov r8, r8)
 80009ee:	46c0      	nop			; (mov r8, r8)

080009f0 <osalSysUnlockFromISR.6775.4190>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80009f0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80009f2:	f7ff ffed 	bl	80009d0 <chSysUnlockFromISR.6771.4194>
}
 80009f6:	bd08      	pop	{r3, pc}
 80009f8:	46c0      	nop			; (mov r8, r8)
 80009fa:	46c0      	nop			; (mov r8, r8)
 80009fc:	46c0      	nop			; (mov r8, r8)
 80009fe:	46c0      	nop			; (mov r8, r8)

08000a00 <osalEventBroadcastFlagsI.6777.4186>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8000a00:	b082      	sub	sp, #8
 8000a02:	9001      	str	r0, [sp, #4]
 8000a04:	9100      	str	r1, [sp, #0]

  esp->flags |= flags;
 8000a06:	9b01      	ldr	r3, [sp, #4]
 8000a08:	681a      	ldr	r2, [r3, #0]
 8000a0a:	9b00      	ldr	r3, [sp, #0]
 8000a0c:	431a      	orrs	r2, r3
 8000a0e:	9b01      	ldr	r3, [sp, #4]
 8000a10:	601a      	str	r2, [r3, #0]
}
 8000a12:	b002      	add	sp, #8
 8000a14:	4770      	bx	lr
 8000a16:	46c0      	nop			; (mov r8, r8)
 8000a18:	46c0      	nop			; (mov r8, r8)
 8000a1a:	46c0      	nop			; (mov r8, r8)
 8000a1c:	46c0      	nop			; (mov r8, r8)
 8000a1e:	46c0      	nop			; (mov r8, r8)

08000a20 <set_error.6918.4175>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 8000a20:	b500      	push	{lr}
 8000a22:	b085      	sub	sp, #20
 8000a24:	9001      	str	r0, [sp, #4]
 8000a26:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 8000a28:	2300      	movs	r3, #0
 8000a2a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 8000a2c:	9a00      	ldr	r2, [sp, #0]
 8000a2e:	2308      	movs	r3, #8
 8000a30:	4013      	ands	r3, r2
 8000a32:	d003      	beq.n	8000a3c <set_error.6918.4175+0x1c>
    sts |= SD_OVERRUN_ERROR;
 8000a34:	9b03      	ldr	r3, [sp, #12]
 8000a36:	2280      	movs	r2, #128	; 0x80
 8000a38:	4313      	orrs	r3, r2
 8000a3a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 8000a3c:	9a00      	ldr	r2, [sp, #0]
 8000a3e:	2301      	movs	r3, #1
 8000a40:	4013      	ands	r3, r2
 8000a42:	d003      	beq.n	8000a4c <set_error.6918.4175+0x2c>
    sts |= SD_PARITY_ERROR;
 8000a44:	9b03      	ldr	r3, [sp, #12]
 8000a46:	2220      	movs	r2, #32
 8000a48:	4313      	orrs	r3, r2
 8000a4a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 8000a4c:	9a00      	ldr	r2, [sp, #0]
 8000a4e:	2302      	movs	r3, #2
 8000a50:	4013      	ands	r3, r2
 8000a52:	d003      	beq.n	8000a5c <set_error.6918.4175+0x3c>
    sts |= SD_FRAMING_ERROR;
 8000a54:	9b03      	ldr	r3, [sp, #12]
 8000a56:	2240      	movs	r2, #64	; 0x40
 8000a58:	4313      	orrs	r3, r2
 8000a5a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 8000a5c:	9a00      	ldr	r2, [sp, #0]
 8000a5e:	2304      	movs	r3, #4
 8000a60:	4013      	ands	r3, r2
 8000a62:	d004      	beq.n	8000a6e <set_error.6918.4175+0x4e>
    sts |= SD_NOISE_ERROR;
 8000a64:	9b03      	ldr	r3, [sp, #12]
 8000a66:	2280      	movs	r2, #128	; 0x80
 8000a68:	0052      	lsls	r2, r2, #1
 8000a6a:	4313      	orrs	r3, r2
 8000a6c:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 8000a6e:	f7ff ffb7 	bl	80009e0 <osalSysLockFromISR.6773.4192>
  chnAddFlagsI(sdp, sts);
 8000a72:	9b01      	ldr	r3, [sp, #4]
 8000a74:	1d1a      	adds	r2, r3, #4
 8000a76:	9b03      	ldr	r3, [sp, #12]
 8000a78:	1c10      	adds	r0, r2, #0
 8000a7a:	1c19      	adds	r1, r3, #0
 8000a7c:	f7ff ffc0 	bl	8000a00 <osalEventBroadcastFlagsI.6777.4186>
  osalSysUnlockFromISR();
 8000a80:	f7ff ffb6 	bl	80009f0 <osalSysUnlockFromISR.6775.4190>
}
 8000a84:	b005      	add	sp, #20
 8000a86:	bd00      	pop	{pc}
 8000a88:	46c0      	nop			; (mov r8, r8)
 8000a8a:	46c0      	nop			; (mov r8, r8)
 8000a8c:	46c0      	nop			; (mov r8, r8)
 8000a8e:	46c0      	nop			; (mov r8, r8)

08000a90 <serve_interrupt.6922.4172>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000a90:	b500      	push	{lr}
 8000a92:	b087      	sub	sp, #28
 8000a94:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8000a96:	9b01      	ldr	r3, [sp, #4]
 8000a98:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8000a9a:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 8000a9c:	9b05      	ldr	r3, [sp, #20]
 8000a9e:	681b      	ldr	r3, [r3, #0]
 8000aa0:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000aa2:	9b05      	ldr	r3, [sp, #20]
 8000aa4:	69db      	ldr	r3, [r3, #28]
 8000aa6:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 8000aa8:	9b05      	ldr	r3, [sp, #20]
 8000aaa:	9a03      	ldr	r2, [sp, #12]
 8000aac:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000aae:	9a03      	ldr	r2, [sp, #12]
 8000ab0:	230f      	movs	r3, #15
 8000ab2:	4013      	ands	r3, r2
 8000ab4:	d005      	beq.n	8000ac2 <serve_interrupt.6922.4172+0x32>
    set_error(sdp, isr);
 8000ab6:	9a01      	ldr	r2, [sp, #4]
 8000ab8:	9b03      	ldr	r3, [sp, #12]
 8000aba:	1c10      	adds	r0, r2, #0
 8000abc:	1c19      	adds	r1, r3, #0
 8000abe:	f7ff ffaf 	bl	8000a20 <set_error.6918.4175>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000ac2:	9a03      	ldr	r2, [sp, #12]
 8000ac4:	2380      	movs	r3, #128	; 0x80
 8000ac6:	005b      	lsls	r3, r3, #1
 8000ac8:	4013      	ands	r3, r2
 8000aca:	d00b      	beq.n	8000ae4 <serve_interrupt.6922.4172+0x54>
    osalSysLockFromISR();
 8000acc:	f7ff ff88 	bl	80009e0 <osalSysLockFromISR.6773.4192>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8000ad0:	9b01      	ldr	r3, [sp, #4]
 8000ad2:	1d1a      	adds	r2, r3, #4
 8000ad4:	2380      	movs	r3, #128	; 0x80
 8000ad6:	009b      	lsls	r3, r3, #2
 8000ad8:	1c10      	adds	r0, r2, #0
 8000ada:	1c19      	adds	r1, r3, #0
 8000adc:	f7ff ff90 	bl	8000a00 <osalEventBroadcastFlagsI.6777.4186>
    osalSysUnlockFromISR();
 8000ae0:	f7ff ff86 	bl	80009f0 <osalSysUnlockFromISR.6775.4190>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000ae4:	9a03      	ldr	r2, [sp, #12]
 8000ae6:	2320      	movs	r3, #32
 8000ae8:	4013      	ands	r3, r2
 8000aea:	d00c      	beq.n	8000b06 <serve_interrupt.6922.4172+0x76>
    osalSysLockFromISR();
 8000aec:	f7ff ff78 	bl	80009e0 <osalSysLockFromISR.6773.4192>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000af0:	9b05      	ldr	r3, [sp, #20]
 8000af2:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000af4:	b29b      	uxth	r3, r3
 8000af6:	b2db      	uxtb	r3, r3
 8000af8:	9a01      	ldr	r2, [sp, #4]
 8000afa:	1c10      	adds	r0, r2, #0
 8000afc:	1c19      	adds	r1, r3, #0
 8000afe:	f7ff fc6f 	bl	80003e0 <sdIncomingDataI.4314>
    osalSysUnlockFromISR();
 8000b02:	f7ff ff75 	bl	80009f0 <osalSysUnlockFromISR.6775.4190>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000b06:	9a04      	ldr	r2, [sp, #16]
 8000b08:	2380      	movs	r3, #128	; 0x80
 8000b0a:	4013      	ands	r3, r2
 8000b0c:	d023      	beq.n	8000b56 <serve_interrupt.6922.4172+0xc6>
 8000b0e:	9a03      	ldr	r2, [sp, #12]
 8000b10:	2380      	movs	r3, #128	; 0x80
 8000b12:	4013      	ands	r3, r2
 8000b14:	d01f      	beq.n	8000b56 <serve_interrupt.6922.4172+0xc6>
    msg_t b;
    osalSysLockFromISR();
 8000b16:	f7ff ff63 	bl	80009e0 <osalSysLockFromISR.6773.4192>
    b = oqGetI(&sdp->oqueue);
 8000b1a:	9b01      	ldr	r3, [sp, #4]
 8000b1c:	3330      	adds	r3, #48	; 0x30
 8000b1e:	1c18      	adds	r0, r3, #0
 8000b20:	f000 fc66 	bl	80013f0 <oqGetI>
 8000b24:	1c03      	adds	r3, r0, #0
 8000b26:	9302      	str	r3, [sp, #8]
    if (b < Q_OK) {
 8000b28:	9b02      	ldr	r3, [sp, #8]
 8000b2a:	2b00      	cmp	r3, #0
 8000b2c:	da0d      	bge.n	8000b4a <serve_interrupt.6922.4172+0xba>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000b2e:	9b01      	ldr	r3, [sp, #4]
 8000b30:	3304      	adds	r3, #4
 8000b32:	1c18      	adds	r0, r3, #0
 8000b34:	2108      	movs	r1, #8
 8000b36:	f7ff ff63 	bl	8000a00 <osalEventBroadcastFlagsI.6777.4186>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000b3a:	9b04      	ldr	r3, [sp, #16]
 8000b3c:	22c0      	movs	r2, #192	; 0xc0
 8000b3e:	4393      	bics	r3, r2
 8000b40:	2240      	movs	r2, #64	; 0x40
 8000b42:	431a      	orrs	r2, r3
 8000b44:	9b05      	ldr	r3, [sp, #20]
 8000b46:	601a      	str	r2, [r3, #0]
 8000b48:	e003      	b.n	8000b52 <serve_interrupt.6922.4172+0xc2>
    }
    else
      u->TDR = b;
 8000b4a:	9b02      	ldr	r3, [sp, #8]
 8000b4c:	b29a      	uxth	r2, r3
 8000b4e:	9b05      	ldr	r3, [sp, #20]
 8000b50:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 8000b52:	f7ff ff4d 	bl	80009f0 <osalSysUnlockFromISR.6775.4190>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000b56:	9a03      	ldr	r2, [sp, #12]
 8000b58:	2340      	movs	r3, #64	; 0x40
 8000b5a:	4013      	ands	r3, r2
 8000b5c:	d023      	beq.n	8000ba6 <serve_interrupt.6922.4172+0x116>
    osalSysLockFromISR();
 8000b5e:	f7ff ff3f 	bl	80009e0 <osalSysLockFromISR.6773.4192>
    if (oqIsEmptyI(&sdp->oqueue))
 8000b62:	9b01      	ldr	r3, [sp, #4]
 8000b64:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000b66:	9b01      	ldr	r3, [sp, #4]
 8000b68:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000b6a:	429a      	cmp	r2, r3
 8000b6c:	d105      	bne.n	8000b7a <serve_interrupt.6922.4172+0xea>
 8000b6e:	9b01      	ldr	r3, [sp, #4]
 8000b70:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000b72:	2b00      	cmp	r3, #0
 8000b74:	d001      	beq.n	8000b7a <serve_interrupt.6922.4172+0xea>
 8000b76:	2301      	movs	r3, #1
 8000b78:	e000      	b.n	8000b7c <serve_interrupt.6922.4172+0xec>
 8000b7a:	2300      	movs	r3, #0
 8000b7c:	1c1a      	adds	r2, r3, #0
 8000b7e:	2301      	movs	r3, #1
 8000b80:	4013      	ands	r3, r2
 8000b82:	b2db      	uxtb	r3, r3
 8000b84:	2b00      	cmp	r3, #0
 8000b86:	d005      	beq.n	8000b94 <serve_interrupt.6922.4172+0x104>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000b88:	9b01      	ldr	r3, [sp, #4]
 8000b8a:	3304      	adds	r3, #4
 8000b8c:	1c18      	adds	r0, r3, #0
 8000b8e:	2110      	movs	r1, #16
 8000b90:	f7ff ff36 	bl	8000a00 <osalEventBroadcastFlagsI.6777.4186>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000b94:	9b04      	ldr	r3, [sp, #16]
 8000b96:	2240      	movs	r2, #64	; 0x40
 8000b98:	1c19      	adds	r1, r3, #0
 8000b9a:	4391      	bics	r1, r2
 8000b9c:	1c0a      	adds	r2, r1, #0
 8000b9e:	9b05      	ldr	r3, [sp, #20]
 8000ba0:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 8000ba2:	f7ff ff25 	bl	80009f0 <osalSysUnlockFromISR.6775.4190>
  }
}
 8000ba6:	b007      	add	sp, #28
 8000ba8:	bd00      	pop	{pc}
 8000baa:	46c0      	nop			; (mov r8, r8)
 8000bac:	46c0      	nop			; (mov r8, r8)
 8000bae:	46c0      	nop			; (mov r8, r8)

08000bb0 <notify1.6787.4167>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 8000bb0:	b082      	sub	sp, #8
 8000bb2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000bb4:	4b03      	ldr	r3, [pc, #12]	; (8000bc4 <notify1.6787.4167+0x14>)
 8000bb6:	4a03      	ldr	r2, [pc, #12]	; (8000bc4 <notify1.6787.4167+0x14>)
 8000bb8:	6812      	ldr	r2, [r2, #0]
 8000bba:	2180      	movs	r1, #128	; 0x80
 8000bbc:	430a      	orrs	r2, r1
 8000bbe:	601a      	str	r2, [r3, #0]
}
 8000bc0:	b002      	add	sp, #8
 8000bc2:	4770      	bx	lr
 8000bc4:	40013800 	.word	0x40013800
 8000bc8:	46c0      	nop			; (mov r8, r8)
 8000bca:	46c0      	nop			; (mov r8, r8)
 8000bcc:	46c0      	nop			; (mov r8, r8)
 8000bce:	46c0      	nop			; (mov r8, r8)

08000bd0 <VectorAC.4170>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000bd0:	b500      	push	{lr}
 8000bd2:	b083      	sub	sp, #12
 8000bd4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 8000bd6:	9301      	str	r3, [sp, #4]

  serve_interrupt(&SD1);
 8000bd8:	4b04      	ldr	r3, [pc, #16]	; (8000bec <VectorAC.4170+0x1c>)
 8000bda:	1c18      	adds	r0, r3, #0
 8000bdc:	f7ff ff58 	bl	8000a90 <serve_interrupt.6922.4172>

  OSAL_IRQ_EPILOGUE();
 8000be0:	9b01      	ldr	r3, [sp, #4]
 8000be2:	1c18      	adds	r0, r3, #0
 8000be4:	f000 f954 	bl	8000e90 <_port_irq_epilogue>
}
 8000be8:	b003      	add	sp, #12
 8000bea:	bd00      	pop	{pc}
 8000bec:	20000450 	.word	0x20000450

08000bf0 <sd_lld_init.4165>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8000bf0:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8000bf2:	4a09      	ldr	r2, [pc, #36]	; (8000c18 <sd_lld_init.4165+0x28>)
 8000bf4:	4b09      	ldr	r3, [pc, #36]	; (8000c1c <sd_lld_init.4165+0x2c>)
 8000bf6:	1c10      	adds	r0, r2, #0
 8000bf8:	2100      	movs	r1, #0
 8000bfa:	1c1a      	adds	r2, r3, #0
 8000bfc:	f7ff fbc0 	bl	8000380 <sdObjectInit.4325>
  SD1.usart = USART1;
 8000c00:	4b05      	ldr	r3, [pc, #20]	; (8000c18 <sd_lld_init.4165+0x28>)
 8000c02:	4a07      	ldr	r2, [pc, #28]	; (8000c20 <sd_lld_init.4165+0x30>)
 8000c04:	675a      	str	r2, [r3, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 8000c06:	4b04      	ldr	r3, [pc, #16]	; (8000c18 <sd_lld_init.4165+0x28>)
 8000c08:	4a06      	ldr	r2, [pc, #24]	; (8000c24 <sd_lld_init.4165+0x34>)
 8000c0a:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_USART1_NUMBER)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8000c0c:	201b      	movs	r0, #27
 8000c0e:	2103      	movs	r1, #3
 8000c10:	f7ff fc0e 	bl	8000430 <nvicEnableVector.4300>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8000c14:	bd08      	pop	{r3, pc}
 8000c16:	46c0      	nop			; (mov r8, r8)
 8000c18:	20000450 	.word	0x20000450
 8000c1c:	08000bb1 	.word	0x08000bb1
 8000c20:	40013800 	.word	0x40013800
 8000c24:	02dc6c00 	.word	0x02dc6c00
 8000c28:	46c0      	nop			; (mov r8, r8)
 8000c2a:	46c0      	nop			; (mov r8, r8)
 8000c2c:	46c0      	nop			; (mov r8, r8)
 8000c2e:	46c0      	nop			; (mov r8, r8)

08000c30 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8000c30:	b508      	push	{r3, lr}

  stm32_clock_init();
 8000c32:	f7ff fca5 	bl	8000580 <stm32_clock_init.4282>
}
 8000c36:	bd08      	pop	{r3, pc}
 8000c38:	46c0      	nop			; (mov r8, r8)
 8000c3a:	46c0      	nop			; (mov r8, r8)
 8000c3c:	46c0      	nop			; (mov r8, r8)
 8000c3e:	46c0      	nop			; (mov r8, r8)

08000c40 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8000c40:	4770      	bx	lr
 8000c42:	46c0      	nop			; (mov r8, r8)
 8000c44:	46c0      	nop			; (mov r8, r8)
 8000c46:	46c0      	nop			; (mov r8, r8)
 8000c48:	46c0      	nop			; (mov r8, r8)
 8000c4a:	46c0      	nop			; (mov r8, r8)
 8000c4c:	46c0      	nop			; (mov r8, r8)
 8000c4e:	46c0      	nop			; (mov r8, r8)

08000c50 <main>:
#include "ch.h"

#define A1TO9 0b101111111U

int main(void)
{
 8000c50:	b500      	push	{lr}
 8000c52:	b085      	sub	sp, #20
	halInit();
 8000c54:	f000 f954 	bl	8000f00 <halInit>
	chSysInit();
 8000c58:	f000 fe22 	bl	80018a0 <chSysInit>
	uint16_t portSample = 0;
 8000c5c:	466b      	mov	r3, sp
 8000c5e:	330e      	adds	r3, #14
 8000c60:	2200      	movs	r2, #0
 8000c62:	801a      	strh	r2, [r3, #0]
    palSetPadMode(GPIOA, GPIOA_PIN0, PAL_MODE_OUTPUT_PUSHPULL);
 8000c64:	2390      	movs	r3, #144	; 0x90
 8000c66:	05db      	lsls	r3, r3, #23
 8000c68:	1c18      	adds	r0, r3, #0
 8000c6a:	2101      	movs	r1, #1
 8000c6c:	2201      	movs	r2, #1
 8000c6e:	f7ff fdef 	bl	8000850 <_pal_lld_setgroupmode>
    palSetGroupMode(GPIOA, A1TO9, 1, PAL_MODE_INPUT_PULLDOWN);
 8000c72:	2390      	movs	r3, #144	; 0x90
 8000c74:	05da      	lsls	r2, r3, #23
 8000c76:	4b1d      	ldr	r3, [pc, #116]	; (8000cec <main+0x9c>)
 8000c78:	1c10      	adds	r0, r2, #0
 8000c7a:	1c19      	adds	r1, r3, #0
 8000c7c:	2240      	movs	r2, #64	; 0x40
 8000c7e:	f7ff fde7 	bl	8000850 <_pal_lld_setgroupmode>
	

	volatile long i,j;
	while(!0)
	{
		portSample = palReadGroup(GPIOA, A1TO9, 1);
 8000c82:	2390      	movs	r3, #144	; 0x90
 8000c84:	05db      	lsls	r3, r3, #23
 8000c86:	691b      	ldr	r3, [r3, #16]
 8000c88:	085b      	lsrs	r3, r3, #1
 8000c8a:	b299      	uxth	r1, r3
 8000c8c:	466b      	mov	r3, sp
 8000c8e:	330e      	adds	r3, #14
 8000c90:	2280      	movs	r2, #128	; 0x80
 8000c92:	32ff      	adds	r2, #255	; 0xff
 8000c94:	400a      	ands	r2, r1
 8000c96:	801a      	strh	r2, [r3, #0]
		if(portSample )
 8000c98:	466b      	mov	r3, sp
 8000c9a:	330e      	adds	r3, #14
 8000c9c:	881b      	ldrh	r3, [r3, #0]
 8000c9e:	2b00      	cmp	r3, #0
 8000ca0:	d011      	beq.n	8000cc6 <main+0x76>
		{
			palClearPad(GPIOA, GPIOA_PIN0);
 8000ca2:	2390      	movs	r3, #144	; 0x90
 8000ca4:	05db      	lsls	r3, r3, #23
 8000ca6:	2201      	movs	r2, #1
 8000ca8:	835a      	strh	r2, [r3, #26]
			for(i = 0; i < 100000; i++)
 8000caa:	2300      	movs	r3, #0
 8000cac:	9302      	str	r3, [sp, #8]
 8000cae:	e005      	b.n	8000cbc <main+0x6c>
				j++;
 8000cb0:	9b01      	ldr	r3, [sp, #4]
 8000cb2:	3301      	adds	r3, #1
 8000cb4:	9301      	str	r3, [sp, #4]
	{
		portSample = palReadGroup(GPIOA, A1TO9, 1);
		if(portSample )
		{
			palClearPad(GPIOA, GPIOA_PIN0);
			for(i = 0; i < 100000; i++)
 8000cb6:	9b02      	ldr	r3, [sp, #8]
 8000cb8:	3301      	adds	r3, #1
 8000cba:	9302      	str	r3, [sp, #8]
 8000cbc:	9a02      	ldr	r2, [sp, #8]
 8000cbe:	4b0c      	ldr	r3, [pc, #48]	; (8000cf0 <main+0xa0>)
 8000cc0:	429a      	cmp	r2, r3
 8000cc2:	ddf5      	ble.n	8000cb0 <main+0x60>
 8000cc4:	e7dd      	b.n	8000c82 <main+0x32>
				j++;
		}
		else
		{
			palSetPad(GPIOA, GPIOA_PIN0);
 8000cc6:	2390      	movs	r3, #144	; 0x90
 8000cc8:	05db      	lsls	r3, r3, #23
 8000cca:	2201      	movs	r2, #1
 8000ccc:	831a      	strh	r2, [r3, #24]
				for(i = 0; i < 100000; i++)
 8000cce:	2300      	movs	r3, #0
 8000cd0:	9302      	str	r3, [sp, #8]
 8000cd2:	e005      	b.n	8000ce0 <main+0x90>
					j++;
 8000cd4:	9b01      	ldr	r3, [sp, #4]
 8000cd6:	3301      	adds	r3, #1
 8000cd8:	9301      	str	r3, [sp, #4]
				j++;
		}
		else
		{
			palSetPad(GPIOA, GPIOA_PIN0);
				for(i = 0; i < 100000; i++)
 8000cda:	9b02      	ldr	r3, [sp, #8]
 8000cdc:	3301      	adds	r3, #1
 8000cde:	9302      	str	r3, [sp, #8]
 8000ce0:	9a02      	ldr	r2, [sp, #8]
 8000ce2:	4b03      	ldr	r3, [pc, #12]	; (8000cf0 <main+0xa0>)
 8000ce4:	429a      	cmp	r2, r3
 8000ce6:	ddf5      	ble.n	8000cd4 <main+0x84>
 8000ce8:	e7cb      	b.n	8000c82 <main+0x32>
 8000cea:	46c0      	nop			; (mov r8, r8)
 8000cec:	000002fe 	.word	0x000002fe
 8000cf0:	0001869f 	.word	0x0001869f
 8000cf4:	46c0      	nop			; (mov r8, r8)
 8000cf6:	46c0      	nop			; (mov r8, r8)
 8000cf8:	46c0      	nop			; (mov r8, r8)
 8000cfa:	46c0      	nop			; (mov r8, r8)
 8000cfc:	46c0      	nop			; (mov r8, r8)
 8000cfe:	46c0      	nop			; (mov r8, r8)

08000d00 <port_lock.5714.4345>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d00:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000d02:	4770      	bx	lr
 8000d04:	46c0      	nop			; (mov r8, r8)
 8000d06:	46c0      	nop			; (mov r8, r8)
 8000d08:	46c0      	nop			; (mov r8, r8)
 8000d0a:	46c0      	nop			; (mov r8, r8)
 8000d0c:	46c0      	nop			; (mov r8, r8)
 8000d0e:	46c0      	nop			; (mov r8, r8)

08000d10 <port_unlock.5717.4343>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d10:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000d12:	4770      	bx	lr
 8000d14:	46c0      	nop			; (mov r8, r8)
 8000d16:	46c0      	nop			; (mov r8, r8)
 8000d18:	46c0      	nop			; (mov r8, r8)
 8000d1a:	46c0      	nop			; (mov r8, r8)
 8000d1c:	46c0      	nop			; (mov r8, r8)
 8000d1e:	46c0      	nop			; (mov r8, r8)

08000d20 <chSysLock.5719.4341>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8000d20:	b508      	push	{r3, lr}

  port_lock();
 8000d22:	f7ff ffed 	bl	8000d00 <port_lock.5714.4345>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8000d26:	bd08      	pop	{r3, pc}
 8000d28:	46c0      	nop			; (mov r8, r8)
 8000d2a:	46c0      	nop			; (mov r8, r8)
 8000d2c:	46c0      	nop			; (mov r8, r8)
 8000d2e:	46c0      	nop			; (mov r8, r8)

08000d30 <chSysUnlock.5721.4339>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000d30:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8000d32:	f7ff ffed 	bl	8000d10 <port_unlock.5717.4343>
}
 8000d36:	bd08      	pop	{r3, pc}
 8000d38:	46c0      	nop			; (mov r8, r8)
 8000d3a:	46c0      	nop			; (mov r8, r8)
 8000d3c:	46c0      	nop			; (mov r8, r8)
 8000d3e:	46c0      	nop			; (mov r8, r8)

08000d40 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d40:	4b06      	ldr	r3, [pc, #24]	; (8000d5c <_core_init+0x1c>)
 8000d42:	3307      	adds	r3, #7
 8000d44:	2207      	movs	r2, #7
 8000d46:	4393      	bics	r3, r2
 8000d48:	1c1a      	adds	r2, r3, #0
 8000d4a:	4b05      	ldr	r3, [pc, #20]	; (8000d60 <_core_init+0x20>)
 8000d4c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d4e:	4b05      	ldr	r3, [pc, #20]	; (8000d64 <_core_init+0x24>)
 8000d50:	2207      	movs	r2, #7
 8000d52:	4393      	bics	r3, r2
 8000d54:	1c1a      	adds	r2, r3, #0
 8000d56:	4b04      	ldr	r3, [pc, #16]	; (8000d68 <_core_init+0x28>)
 8000d58:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 8000d5a:	4770      	bx	lr
 8000d5c:	200004d0 	.word	0x200004d0
 8000d60:	20000428 	.word	0x20000428
 8000d64:	20001000 	.word	0x20001000
 8000d68:	2000042c 	.word	0x2000042c
 8000d6c:	46c0      	nop			; (mov r8, r8)
 8000d6e:	46c0      	nop			; (mov r8, r8)

08000d70 <chCoreAlloc.4329>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8000d70:	b500      	push	{lr}
 8000d72:	b085      	sub	sp, #20
 8000d74:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8000d76:	f7ff ffd3 	bl	8000d20 <chSysLock.5719.4341>
  p = chCoreAllocI(size);
 8000d7a:	9b01      	ldr	r3, [sp, #4]
 8000d7c:	1c18      	adds	r0, r3, #0
 8000d7e:	f000 f80f 	bl	8000da0 <chCoreAllocI.4334>
 8000d82:	1c03      	adds	r3, r0, #0
 8000d84:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8000d86:	f7ff ffd3 	bl	8000d30 <chSysUnlock.5721.4339>

  return p;
 8000d8a:	9b03      	ldr	r3, [sp, #12]
}
 8000d8c:	1c18      	adds	r0, r3, #0
 8000d8e:	b005      	add	sp, #20
 8000d90:	bd00      	pop	{pc}
 8000d92:	46c0      	nop			; (mov r8, r8)
 8000d94:	46c0      	nop			; (mov r8, r8)
 8000d96:	46c0      	nop			; (mov r8, r8)
 8000d98:	46c0      	nop			; (mov r8, r8)
 8000d9a:	46c0      	nop			; (mov r8, r8)
 8000d9c:	46c0      	nop			; (mov r8, r8)
 8000d9e:	46c0      	nop			; (mov r8, r8)

08000da0 <chCoreAllocI.4334>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8000da0:	b084      	sub	sp, #16
 8000da2:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000da4:	9b01      	ldr	r3, [sp, #4]
 8000da6:	3307      	adds	r3, #7
 8000da8:	2207      	movs	r2, #7
 8000daa:	4393      	bics	r3, r2
 8000dac:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000dae:	4b0c      	ldr	r3, [pc, #48]	; (8000de0 <chCoreAllocI.4334+0x40>)
 8000db0:	681b      	ldr	r3, [r3, #0]
 8000db2:	1c1a      	adds	r2, r3, #0
 8000db4:	4b0b      	ldr	r3, [pc, #44]	; (8000de4 <chCoreAllocI.4334+0x44>)
 8000db6:	681b      	ldr	r3, [r3, #0]
 8000db8:	1ad3      	subs	r3, r2, r3
 8000dba:	1c1a      	adds	r2, r3, #0
 8000dbc:	9b01      	ldr	r3, [sp, #4]
 8000dbe:	429a      	cmp	r2, r3
 8000dc0:	d201      	bcs.n	8000dc6 <chCoreAllocI.4334+0x26>
  /*lint -restore*/
    return NULL;
 8000dc2:	2300      	movs	r3, #0
 8000dc4:	e009      	b.n	8000dda <chCoreAllocI.4334+0x3a>
  }
  p = nextmem;
 8000dc6:	4b07      	ldr	r3, [pc, #28]	; (8000de4 <chCoreAllocI.4334+0x44>)
 8000dc8:	681b      	ldr	r3, [r3, #0]
 8000dca:	9303      	str	r3, [sp, #12]
  nextmem += size;
 8000dcc:	4b05      	ldr	r3, [pc, #20]	; (8000de4 <chCoreAllocI.4334+0x44>)
 8000dce:	681a      	ldr	r2, [r3, #0]
 8000dd0:	9b01      	ldr	r3, [sp, #4]
 8000dd2:	18d2      	adds	r2, r2, r3
 8000dd4:	4b03      	ldr	r3, [pc, #12]	; (8000de4 <chCoreAllocI.4334+0x44>)
 8000dd6:	601a      	str	r2, [r3, #0]

  return p;
 8000dd8:	9b03      	ldr	r3, [sp, #12]
}
 8000dda:	1c18      	adds	r0, r3, #0
 8000ddc:	b004      	add	sp, #16
 8000dde:	4770      	bx	lr
 8000de0:	2000042c 	.word	0x2000042c
 8000de4:	20000428 	.word	0x20000428
 8000de8:	46c0      	nop			; (mov r8, r8)
 8000dea:	46c0      	nop			; (mov r8, r8)
 8000dec:	46c0      	nop			; (mov r8, r8)
 8000dee:	46c0      	nop			; (mov r8, r8)

08000df0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8000df0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 8000df2:	4b07      	ldr	r3, [pc, #28]	; (8000e10 <_heap_init+0x20>)
 8000df4:	4a07      	ldr	r2, [pc, #28]	; (8000e14 <_heap_init+0x24>)
 8000df6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8000df8:	4b05      	ldr	r3, [pc, #20]	; (8000e10 <_heap_init+0x20>)
 8000dfa:	2200      	movs	r2, #0
 8000dfc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8000dfe:	4b04      	ldr	r3, [pc, #16]	; (8000e10 <_heap_init+0x20>)
 8000e00:	2200      	movs	r2, #0
 8000e02:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8000e04:	4b04      	ldr	r3, [pc, #16]	; (8000e18 <_heap_init+0x28>)
 8000e06:	1c18      	adds	r0, r3, #0
 8000e08:	f001 fa82 	bl	8002310 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 8000e0c:	bd08      	pop	{r3, pc}
 8000e0e:	46c0      	nop			; (mov r8, r8)
 8000e10:	20000430 	.word	0x20000430
 8000e14:	08000d71 	.word	0x08000d71
 8000e18:	20000440 	.word	0x20000440
 8000e1c:	46c0      	nop			; (mov r8, r8)
 8000e1e:	46c0      	nop			; (mov r8, r8)

08000e20 <port_lock.5920.4289>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e20:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000e22:	4770      	bx	lr
 8000e24:	46c0      	nop			; (mov r8, r8)
 8000e26:	46c0      	nop			; (mov r8, r8)
 8000e28:	46c0      	nop			; (mov r8, r8)
 8000e2a:	46c0      	nop			; (mov r8, r8)
 8000e2c:	46c0      	nop			; (mov r8, r8)
 8000e2e:	46c0      	nop			; (mov r8, r8)

08000e30 <port_unlock.5923.4287>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e30:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000e32:	4770      	bx	lr
 8000e34:	46c0      	nop			; (mov r8, r8)
 8000e36:	46c0      	nop			; (mov r8, r8)
 8000e38:	46c0      	nop			; (mov r8, r8)
 8000e3a:	46c0      	nop			; (mov r8, r8)
 8000e3c:	46c0      	nop			; (mov r8, r8)
 8000e3e:	46c0      	nop			; (mov r8, r8)

08000e40 <port_lock_from_isr.5925.4285>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000e40:	b508      	push	{r3, lr}

  port_lock();
 8000e42:	f7ff ffed 	bl	8000e20 <port_lock.5920.4289>
}
 8000e46:	bd08      	pop	{r3, pc}
 8000e48:	46c0      	nop			; (mov r8, r8)
 8000e4a:	46c0      	nop			; (mov r8, r8)
 8000e4c:	46c0      	nop			; (mov r8, r8)
 8000e4e:	46c0      	nop			; (mov r8, r8)

08000e50 <port_unlock_from_isr.5927.4283>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000e50:	b508      	push	{r3, lr}

  port_unlock();
 8000e52:	f7ff ffed 	bl	8000e30 <port_unlock.5923.4287>
}
 8000e56:	bd08      	pop	{r3, pc}
 8000e58:	46c0      	nop			; (mov r8, r8)
 8000e5a:	46c0      	nop			; (mov r8, r8)
 8000e5c:	46c0      	nop			; (mov r8, r8)
 8000e5e:	46c0      	nop			; (mov r8, r8)

08000e60 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8000e60:	b510      	push	{r4, lr}
 8000e62:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000e64:	f3ef 8309 	mrs	r3, PSP
 8000e68:	1c1c      	adds	r4, r3, #0
  return(result);
 8000e6a:	1c23      	adds	r3, r4, #0
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 8000e6c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000e6e:	9b01      	ldr	r3, [sp, #4]
 8000e70:	3320      	adds	r3, #32
 8000e72:	9301      	str	r3, [sp, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8000e74:	9b01      	ldr	r3, [sp, #4]
 8000e76:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000e78:	9b00      	ldr	r3, [sp, #0]
 8000e7a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8000e7e:	f7ff ffe7 	bl	8000e50 <port_unlock_from_isr.5927.4283>
}
 8000e82:	b002      	add	sp, #8
 8000e84:	bd10      	pop	{r4, pc}
 8000e86:	46c0      	nop			; (mov r8, r8)
 8000e88:	46c0      	nop			; (mov r8, r8)
 8000e8a:	46c0      	nop			; (mov r8, r8)
 8000e8c:	46c0      	nop			; (mov r8, r8)
 8000e8e:	46c0      	nop			; (mov r8, r8)

08000e90 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 8000e90:	b510      	push	{r4, lr}
 8000e92:	b084      	sub	sp, #16
 8000e94:	9001      	str	r0, [sp, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000e96:	9b01      	ldr	r3, [sp, #4]
 8000e98:	1c1a      	adds	r2, r3, #0
 8000e9a:	320f      	adds	r2, #15
 8000e9c:	d01e      	beq.n	8000edc <_port_irq_epilogue+0x4c>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 8000e9e:	f7ff ffcf 	bl	8000e40 <port_lock_from_isr.5925.4285>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000ea2:	f3ef 8309 	mrs	r3, PSP
 8000ea6:	1c1c      	adds	r4, r3, #0
  return(result);
 8000ea8:	1c23      	adds	r3, r4, #0

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8000eaa:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000eac:	9b03      	ldr	r3, [sp, #12]
 8000eae:	3b20      	subs	r3, #32
 8000eb0:	9303      	str	r3, [sp, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8000eb2:	9b03      	ldr	r3, [sp, #12]
 8000eb4:	9302      	str	r3, [sp, #8]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000eb6:	9b02      	ldr	r3, [sp, #8]
 8000eb8:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000ebc:	9b03      	ldr	r3, [sp, #12]
 8000ebe:	2280      	movs	r2, #128	; 0x80
 8000ec0:	0452      	lsls	r2, r2, #17
 8000ec2:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000ec4:	f001 f85c 	bl	8001f80 <chSchIsPreemptionRequired>
 8000ec8:	1c03      	adds	r3, r0, #0
 8000eca:	2b00      	cmp	r3, #0
 8000ecc:	d003      	beq.n	8000ed6 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000ece:	9b03      	ldr	r3, [sp, #12]
 8000ed0:	4a03      	ldr	r2, [pc, #12]	; (8000ee0 <_port_irq_epilogue+0x50>)
 8000ed2:	619a      	str	r2, [r3, #24]
 8000ed4:	e002      	b.n	8000edc <_port_irq_epilogue+0x4c>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000ed6:	9b03      	ldr	r3, [sp, #12]
 8000ed8:	4a02      	ldr	r2, [pc, #8]	; (8000ee4 <_port_irq_epilogue+0x54>)
 8000eda:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000edc:	b004      	add	sp, #16
 8000ede:	bd10      	pop	{r4, pc}
 8000ee0:	080001bd 	.word	0x080001bd
 8000ee4:	080001c0 	.word	0x080001c0
 8000ee8:	46c0      	nop			; (mov r8, r8)
 8000eea:	46c0      	nop			; (mov r8, r8)
 8000eec:	46c0      	nop			; (mov r8, r8)
 8000eee:	46c0      	nop			; (mov r8, r8)

08000ef0 <osalInit.5962.4273>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8000ef0:	4770      	bx	lr
 8000ef2:	46c0      	nop			; (mov r8, r8)
 8000ef4:	46c0      	nop			; (mov r8, r8)
 8000ef6:	46c0      	nop			; (mov r8, r8)
 8000ef8:	46c0      	nop			; (mov r8, r8)
 8000efa:	46c0      	nop			; (mov r8, r8)
 8000efc:	46c0      	nop			; (mov r8, r8)
 8000efe:	46c0      	nop			; (mov r8, r8)

08000f00 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000f00:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8000f02:	f7ff fff5 	bl	8000ef0 <osalInit.5962.4273>

  /* Platform low level initializations.*/
  hal_lld_init();
 8000f06:	f7ff fb0b 	bl	8000520 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8000f0a:	4b05      	ldr	r3, [pc, #20]	; (8000f20 <halInit+0x20>)
 8000f0c:	1c18      	adds	r0, r3, #0
 8000f0e:	f7ff fc6f 	bl	80007f0 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000f12:	f7ff fa2d 	bl	8000370 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000f16:	f7ff fe93 	bl	8000c40 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8000f1a:	f000 f839 	bl	8000f90 <stInit.4258>
#endif
}
 8000f1e:	bd08      	pop	{r3, pc}
 8000f20:	08002380 	.word	0x08002380
 8000f24:	46c0      	nop			; (mov r8, r8)
 8000f26:	46c0      	nop			; (mov r8, r8)
 8000f28:	46c0      	nop			; (mov r8, r8)
 8000f2a:	46c0      	nop			; (mov r8, r8)
 8000f2c:	46c0      	nop			; (mov r8, r8)
 8000f2e:	46c0      	nop			; (mov r8, r8)

08000f30 <st_lld_start_alarm.5990.4267>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8000f30:	b082      	sub	sp, #8
 8000f32:	1c02      	adds	r2, r0, #0
 8000f34:	466b      	mov	r3, sp
 8000f36:	3306      	adds	r3, #6
 8000f38:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000f3a:	4b06      	ldr	r3, [pc, #24]	; (8000f54 <st_lld_start_alarm.5990.4267+0x24>)
 8000f3c:	466a      	mov	r2, sp
 8000f3e:	3206      	adds	r2, #6
 8000f40:	8812      	ldrh	r2, [r2, #0]
 8000f42:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000f44:	4b03      	ldr	r3, [pc, #12]	; (8000f54 <st_lld_start_alarm.5990.4267+0x24>)
 8000f46:	2200      	movs	r2, #0
 8000f48:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000f4a:	4b02      	ldr	r3, [pc, #8]	; (8000f54 <st_lld_start_alarm.5990.4267+0x24>)
 8000f4c:	2202      	movs	r2, #2
 8000f4e:	60da      	str	r2, [r3, #12]
}
 8000f50:	b002      	add	sp, #8
 8000f52:	4770      	bx	lr
 8000f54:	40000400 	.word	0x40000400
 8000f58:	46c0      	nop			; (mov r8, r8)
 8000f5a:	46c0      	nop			; (mov r8, r8)
 8000f5c:	46c0      	nop			; (mov r8, r8)
 8000f5e:	46c0      	nop			; (mov r8, r8)

08000f60 <st_lld_stop_alarm.5997.4265>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000f60:	4b01      	ldr	r3, [pc, #4]	; (8000f68 <st_lld_stop_alarm.5997.4265+0x8>)
 8000f62:	2200      	movs	r2, #0
 8000f64:	60da      	str	r2, [r3, #12]
}
 8000f66:	4770      	bx	lr
 8000f68:	40000400 	.word	0x40000400
 8000f6c:	46c0      	nop			; (mov r8, r8)
 8000f6e:	46c0      	nop			; (mov r8, r8)

08000f70 <st_lld_set_alarm.5999.4262>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8000f70:	b082      	sub	sp, #8
 8000f72:	1c02      	adds	r2, r0, #0
 8000f74:	466b      	mov	r3, sp
 8000f76:	3306      	adds	r3, #6
 8000f78:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000f7a:	4b03      	ldr	r3, [pc, #12]	; (8000f88 <st_lld_set_alarm.5999.4262+0x18>)
 8000f7c:	466a      	mov	r2, sp
 8000f7e:	3206      	adds	r2, #6
 8000f80:	8812      	ldrh	r2, [r2, #0]
 8000f82:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000f84:	b002      	add	sp, #8
 8000f86:	4770      	bx	lr
 8000f88:	40000400 	.word	0x40000400
 8000f8c:	46c0      	nop			; (mov r8, r8)
 8000f8e:	46c0      	nop			; (mov r8, r8)

08000f90 <stInit.4258>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000f90:	b508      	push	{r3, lr}

  st_lld_init();
 8000f92:	f7ff fbcd 	bl	8000730 <st_lld_init>
}
 8000f96:	bd08      	pop	{r3, pc}
 8000f98:	46c0      	nop			; (mov r8, r8)
 8000f9a:	46c0      	nop			; (mov r8, r8)
 8000f9c:	46c0      	nop			; (mov r8, r8)
 8000f9e:	46c0      	nop			; (mov r8, r8)

08000fa0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000fa0:	b500      	push	{lr}
 8000fa2:	b083      	sub	sp, #12
 8000fa4:	1c02      	adds	r2, r0, #0
 8000fa6:	466b      	mov	r3, sp
 8000fa8:	3306      	adds	r3, #6
 8000faa:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8000fac:	466b      	mov	r3, sp
 8000fae:	3306      	adds	r3, #6
 8000fb0:	881b      	ldrh	r3, [r3, #0]
 8000fb2:	1c18      	adds	r0, r3, #0
 8000fb4:	f7ff ffbc 	bl	8000f30 <st_lld_start_alarm.5990.4267>
}
 8000fb8:	b003      	add	sp, #12
 8000fba:	bd00      	pop	{pc}
 8000fbc:	46c0      	nop			; (mov r8, r8)
 8000fbe:	46c0      	nop			; (mov r8, r8)

08000fc0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8000fc0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8000fc2:	f7ff ffcd 	bl	8000f60 <st_lld_stop_alarm.5997.4265>
}
 8000fc6:	bd08      	pop	{r3, pc}
 8000fc8:	46c0      	nop			; (mov r8, r8)
 8000fca:	46c0      	nop			; (mov r8, r8)
 8000fcc:	46c0      	nop			; (mov r8, r8)
 8000fce:	46c0      	nop			; (mov r8, r8)

08000fd0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8000fd0:	b500      	push	{lr}
 8000fd2:	b083      	sub	sp, #12
 8000fd4:	1c02      	adds	r2, r0, #0
 8000fd6:	466b      	mov	r3, sp
 8000fd8:	3306      	adds	r3, #6
 8000fda:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8000fdc:	466b      	mov	r3, sp
 8000fde:	3306      	adds	r3, #6
 8000fe0:	881b      	ldrh	r3, [r3, #0]
 8000fe2:	1c18      	adds	r0, r3, #0
 8000fe4:	f7ff ffc4 	bl	8000f70 <st_lld_set_alarm.5999.4262>
}
 8000fe8:	b003      	add	sp, #12
 8000fea:	bd00      	pop	{pc}
 8000fec:	46c0      	nop			; (mov r8, r8)
 8000fee:	46c0      	nop			; (mov r8, r8)

08000ff0 <port_lock.6048.4245>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ff0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000ff2:	4770      	bx	lr
 8000ff4:	46c0      	nop			; (mov r8, r8)
 8000ff6:	46c0      	nop			; (mov r8, r8)
 8000ff8:	46c0      	nop			; (mov r8, r8)
 8000ffa:	46c0      	nop			; (mov r8, r8)
 8000ffc:	46c0      	nop			; (mov r8, r8)
 8000ffe:	46c0      	nop			; (mov r8, r8)

08001000 <port_unlock.6051.4243>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001000:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001002:	4770      	bx	lr
 8001004:	46c0      	nop			; (mov r8, r8)
 8001006:	46c0      	nop			; (mov r8, r8)
 8001008:	46c0      	nop			; (mov r8, r8)
 800100a:	46c0      	nop			; (mov r8, r8)
 800100c:	46c0      	nop			; (mov r8, r8)
 800100e:	46c0      	nop			; (mov r8, r8)

08001010 <queue_init.6053.4240>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001010:	b082      	sub	sp, #8
 8001012:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001014:	9b01      	ldr	r3, [sp, #4]
 8001016:	9a01      	ldr	r2, [sp, #4]
 8001018:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800101a:	9b01      	ldr	r3, [sp, #4]
 800101c:	9a01      	ldr	r2, [sp, #4]
 800101e:	605a      	str	r2, [r3, #4]
}
 8001020:	b002      	add	sp, #8
 8001022:	4770      	bx	lr
 8001024:	46c0      	nop			; (mov r8, r8)
 8001026:	46c0      	nop			; (mov r8, r8)
 8001028:	46c0      	nop			; (mov r8, r8)
 800102a:	46c0      	nop			; (mov r8, r8)
 800102c:	46c0      	nop			; (mov r8, r8)
 800102e:	46c0      	nop			; (mov r8, r8)

08001030 <chSysLock.6119.4238>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8001030:	b508      	push	{r3, lr}

  port_lock();
 8001032:	f7ff ffdd 	bl	8000ff0 <port_lock.6048.4245>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001036:	bd08      	pop	{r3, pc}
 8001038:	46c0      	nop			; (mov r8, r8)
 800103a:	46c0      	nop			; (mov r8, r8)
 800103c:	46c0      	nop			; (mov r8, r8)
 800103e:	46c0      	nop			; (mov r8, r8)

08001040 <chSysUnlock.6121.4236>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001040:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001042:	f7ff ffdd 	bl	8001000 <port_unlock.6051.4243>
}
 8001046:	bd08      	pop	{r3, pc}
 8001048:	46c0      	nop			; (mov r8, r8)
 800104a:	46c0      	nop			; (mov r8, r8)
 800104c:	46c0      	nop			; (mov r8, r8)
 800104e:	46c0      	nop			; (mov r8, r8)

08001050 <chThdQueueObjectInit.6123.4233>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8001050:	b500      	push	{lr}
 8001052:	b083      	sub	sp, #12
 8001054:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8001056:	9b01      	ldr	r3, [sp, #4]
 8001058:	1c18      	adds	r0, r3, #0
 800105a:	f7ff ffd9 	bl	8001010 <queue_init.6053.4240>
}
 800105e:	b003      	add	sp, #12
 8001060:	bd00      	pop	{pc}
 8001062:	46c0      	nop			; (mov r8, r8)
 8001064:	46c0      	nop			; (mov r8, r8)
 8001066:	46c0      	nop			; (mov r8, r8)
 8001068:	46c0      	nop			; (mov r8, r8)
 800106a:	46c0      	nop			; (mov r8, r8)
 800106c:	46c0      	nop			; (mov r8, r8)
 800106e:	46c0      	nop			; (mov r8, r8)

08001070 <osalSysLock.6126.4231>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8001070:	b508      	push	{r3, lr}

  chSysLock();
 8001072:	f7ff ffdd 	bl	8001030 <chSysLock.6119.4238>
}
 8001076:	bd08      	pop	{r3, pc}
 8001078:	46c0      	nop			; (mov r8, r8)
 800107a:	46c0      	nop			; (mov r8, r8)
 800107c:	46c0      	nop			; (mov r8, r8)
 800107e:	46c0      	nop			; (mov r8, r8)

08001080 <osalSysUnlock.6128.4229>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8001080:	b508      	push	{r3, lr}

  chSysUnlock();
 8001082:	f7ff ffdd 	bl	8001040 <chSysUnlock.6121.4236>
}
 8001086:	bd08      	pop	{r3, pc}
 8001088:	46c0      	nop			; (mov r8, r8)
 800108a:	46c0      	nop			; (mov r8, r8)
 800108c:	46c0      	nop			; (mov r8, r8)
 800108e:	46c0      	nop			; (mov r8, r8)

08001090 <osalThreadQueueObjectInit.6130.4226>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8001090:	b500      	push	{lr}
 8001092:	b083      	sub	sp, #12
 8001094:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8001096:	9b01      	ldr	r3, [sp, #4]
 8001098:	1c18      	adds	r0, r3, #0
 800109a:	f7ff ffd9 	bl	8001050 <chThdQueueObjectInit.6123.4233>
}
 800109e:	b003      	add	sp, #12
 80010a0:	bd00      	pop	{pc}
 80010a2:	46c0      	nop			; (mov r8, r8)
 80010a4:	46c0      	nop			; (mov r8, r8)
 80010a6:	46c0      	nop			; (mov r8, r8)
 80010a8:	46c0      	nop			; (mov r8, r8)
 80010aa:	46c0      	nop			; (mov r8, r8)
 80010ac:	46c0      	nop			; (mov r8, r8)
 80010ae:	46c0      	nop			; (mov r8, r8)

080010b0 <osalThreadEnqueueTimeoutS.6141.4222>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 80010b0:	b500      	push	{lr}
 80010b2:	b083      	sub	sp, #12
 80010b4:	9001      	str	r0, [sp, #4]
 80010b6:	1c0a      	adds	r2, r1, #0
 80010b8:	466b      	mov	r3, sp
 80010ba:	3302      	adds	r3, #2
 80010bc:	801a      	strh	r2, [r3, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 80010be:	9a01      	ldr	r2, [sp, #4]
 80010c0:	466b      	mov	r3, sp
 80010c2:	3302      	adds	r3, #2
 80010c4:	881b      	ldrh	r3, [r3, #0]
 80010c6:	1c10      	adds	r0, r2, #0
 80010c8:	1c19      	adds	r1, r3, #0
 80010ca:	f001 f8d1 	bl	8002270 <chThdEnqueueTimeoutS>
 80010ce:	1c03      	adds	r3, r0, #0
}
 80010d0:	1c18      	adds	r0, r3, #0
 80010d2:	b003      	add	sp, #12
 80010d4:	bd00      	pop	{pc}
 80010d6:	46c0      	nop			; (mov r8, r8)
 80010d8:	46c0      	nop			; (mov r8, r8)
 80010da:	46c0      	nop			; (mov r8, r8)
 80010dc:	46c0      	nop			; (mov r8, r8)
 80010de:	46c0      	nop			; (mov r8, r8)

080010e0 <osalThreadDequeueNextI.6137.4218>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80010e0:	b500      	push	{lr}
 80010e2:	b083      	sub	sp, #12
 80010e4:	9001      	str	r0, [sp, #4]
 80010e6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 80010e8:	9a01      	ldr	r2, [sp, #4]
 80010ea:	9b00      	ldr	r3, [sp, #0]
 80010ec:	1c10      	adds	r0, r2, #0
 80010ee:	1c19      	adds	r1, r3, #0
 80010f0:	f001 f8e6 	bl	80022c0 <chThdDequeueNextI>
}
 80010f4:	b003      	add	sp, #12
 80010f6:	bd00      	pop	{pc}
 80010f8:	46c0      	nop			; (mov r8, r8)
 80010fa:	46c0      	nop			; (mov r8, r8)
 80010fc:	46c0      	nop			; (mov r8, r8)
 80010fe:	46c0      	nop			; (mov r8, r8)

08001100 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8001100:	b500      	push	{lr}
 8001102:	b085      	sub	sp, #20
 8001104:	9003      	str	r0, [sp, #12]
 8001106:	9102      	str	r1, [sp, #8]
 8001108:	9201      	str	r2, [sp, #4]
 800110a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 800110c:	9b03      	ldr	r3, [sp, #12]
 800110e:	1c18      	adds	r0, r3, #0
 8001110:	f7ff ffbe 	bl	8001090 <osalThreadQueueObjectInit.6130.4226>
  iqp->q_counter = 0;
 8001114:	9b03      	ldr	r3, [sp, #12]
 8001116:	2200      	movs	r2, #0
 8001118:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800111a:	9b03      	ldr	r3, [sp, #12]
 800111c:	9a02      	ldr	r2, [sp, #8]
 800111e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8001120:	9b03      	ldr	r3, [sp, #12]
 8001122:	9a02      	ldr	r2, [sp, #8]
 8001124:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8001126:	9b03      	ldr	r3, [sp, #12]
 8001128:	9a02      	ldr	r2, [sp, #8]
 800112a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800112c:	9a02      	ldr	r2, [sp, #8]
 800112e:	9b01      	ldr	r3, [sp, #4]
 8001130:	18d2      	adds	r2, r2, r3
 8001132:	9b03      	ldr	r3, [sp, #12]
 8001134:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8001136:	9b03      	ldr	r3, [sp, #12]
 8001138:	9a00      	ldr	r2, [sp, #0]
 800113a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800113c:	9b03      	ldr	r3, [sp, #12]
 800113e:	9a06      	ldr	r2, [sp, #24]
 8001140:	621a      	str	r2, [r3, #32]
}
 8001142:	b005      	add	sp, #20
 8001144:	bd00      	pop	{pc}
 8001146:	46c0      	nop			; (mov r8, r8)
 8001148:	46c0      	nop			; (mov r8, r8)
 800114a:	46c0      	nop			; (mov r8, r8)
 800114c:	46c0      	nop			; (mov r8, r8)
 800114e:	46c0      	nop			; (mov r8, r8)

08001150 <iqPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8001150:	b500      	push	{lr}
 8001152:	b083      	sub	sp, #12
 8001154:	9001      	str	r0, [sp, #4]
 8001156:	1c0a      	adds	r2, r1, #0
 8001158:	466b      	mov	r3, sp
 800115a:	3303      	adds	r3, #3
 800115c:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 800115e:	9b01      	ldr	r3, [sp, #4]
 8001160:	695a      	ldr	r2, [r3, #20]
 8001162:	9b01      	ldr	r3, [sp, #4]
 8001164:	699b      	ldr	r3, [r3, #24]
 8001166:	429a      	cmp	r2, r3
 8001168:	d105      	bne.n	8001176 <iqPutI+0x26>
 800116a:	9b01      	ldr	r3, [sp, #4]
 800116c:	689b      	ldr	r3, [r3, #8]
 800116e:	2b00      	cmp	r3, #0
 8001170:	d001      	beq.n	8001176 <iqPutI+0x26>
 8001172:	2301      	movs	r3, #1
 8001174:	e000      	b.n	8001178 <iqPutI+0x28>
 8001176:	2300      	movs	r3, #0
 8001178:	1c1a      	adds	r2, r3, #0
 800117a:	2301      	movs	r3, #1
 800117c:	4013      	ands	r3, r2
 800117e:	b2db      	uxtb	r3, r3
 8001180:	2b00      	cmp	r3, #0
 8001182:	d002      	beq.n	800118a <iqPutI+0x3a>
    return Q_FULL;
 8001184:	2304      	movs	r3, #4
 8001186:	425b      	negs	r3, r3
 8001188:	e01d      	b.n	80011c6 <iqPutI+0x76>
  }

  iqp->q_counter++;
 800118a:	9b01      	ldr	r3, [sp, #4]
 800118c:	689b      	ldr	r3, [r3, #8]
 800118e:	1c5a      	adds	r2, r3, #1
 8001190:	9b01      	ldr	r3, [sp, #4]
 8001192:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8001194:	9b01      	ldr	r3, [sp, #4]
 8001196:	695b      	ldr	r3, [r3, #20]
 8001198:	1c59      	adds	r1, r3, #1
 800119a:	9a01      	ldr	r2, [sp, #4]
 800119c:	6151      	str	r1, [r2, #20]
 800119e:	466a      	mov	r2, sp
 80011a0:	3203      	adds	r2, #3
 80011a2:	7812      	ldrb	r2, [r2, #0]
 80011a4:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80011a6:	9b01      	ldr	r3, [sp, #4]
 80011a8:	695a      	ldr	r2, [r3, #20]
 80011aa:	9b01      	ldr	r3, [sp, #4]
 80011ac:	691b      	ldr	r3, [r3, #16]
 80011ae:	429a      	cmp	r2, r3
 80011b0:	d303      	bcc.n	80011ba <iqPutI+0x6a>
    iqp->q_wrptr = iqp->q_buffer;
 80011b2:	9b01      	ldr	r3, [sp, #4]
 80011b4:	68da      	ldr	r2, [r3, #12]
 80011b6:	9b01      	ldr	r3, [sp, #4]
 80011b8:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, Q_OK);
 80011ba:	9b01      	ldr	r3, [sp, #4]
 80011bc:	1c18      	adds	r0, r3, #0
 80011be:	2100      	movs	r1, #0
 80011c0:	f7ff ff8e 	bl	80010e0 <osalThreadDequeueNextI.6137.4218>

  return Q_OK;
 80011c4:	2300      	movs	r3, #0
}
 80011c6:	1c18      	adds	r0, r3, #0
 80011c8:	b003      	add	sp, #12
 80011ca:	bd00      	pop	{pc}
 80011cc:	46c0      	nop			; (mov r8, r8)
 80011ce:	46c0      	nop			; (mov r8, r8)

080011d0 <iqGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 80011d0:	b500      	push	{lr}
 80011d2:	b085      	sub	sp, #20
 80011d4:	9001      	str	r0, [sp, #4]
 80011d6:	1c0a      	adds	r2, r1, #0
 80011d8:	466b      	mov	r3, sp
 80011da:	3302      	adds	r3, #2
 80011dc:	801a      	strh	r2, [r3, #0]
  uint8_t b;

  osalSysLock();
 80011de:	f7ff ff47 	bl	8001070 <osalSysLock.6126.4231>
  if (iqp->q_notify != NULL) {
 80011e2:	9b01      	ldr	r3, [sp, #4]
 80011e4:	69db      	ldr	r3, [r3, #28]
 80011e6:	2b00      	cmp	r3, #0
 80011e8:	d016      	beq.n	8001218 <iqGetTimeout+0x48>
    iqp->q_notify(iqp);
 80011ea:	9b01      	ldr	r3, [sp, #4]
 80011ec:	69db      	ldr	r3, [r3, #28]
 80011ee:	9a01      	ldr	r2, [sp, #4]
 80011f0:	1c10      	adds	r0, r2, #0
 80011f2:	4798      	blx	r3
 80011f4:	e010      	b.n	8001218 <iqGetTimeout+0x48>
  }

  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80011f6:	9a01      	ldr	r2, [sp, #4]
 80011f8:	466b      	mov	r3, sp
 80011fa:	3302      	adds	r3, #2
 80011fc:	881b      	ldrh	r3, [r3, #0]
 80011fe:	1c10      	adds	r0, r2, #0
 8001200:	1c19      	adds	r1, r3, #0
 8001202:	f7ff ff55 	bl	80010b0 <osalThreadEnqueueTimeoutS.6141.4222>
 8001206:	1c03      	adds	r3, r0, #0
 8001208:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 800120a:	9b03      	ldr	r3, [sp, #12]
 800120c:	2b00      	cmp	r3, #0
 800120e:	da03      	bge.n	8001218 <iqGetTimeout+0x48>
      osalSysUnlock();
 8001210:	f7ff ff36 	bl	8001080 <osalSysUnlock.6128.4229>
      return msg;
 8001214:	9b03      	ldr	r3, [sp, #12]
 8001216:	e020      	b.n	800125a <iqGetTimeout+0x8a>
  osalSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (iqIsEmptyI(iqp)) {
 8001218:	9b01      	ldr	r3, [sp, #4]
 800121a:	689b      	ldr	r3, [r3, #8]
 800121c:	2b00      	cmp	r3, #0
 800121e:	d0ea      	beq.n	80011f6 <iqGetTimeout+0x26>
      osalSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001220:	9b01      	ldr	r3, [sp, #4]
 8001222:	689b      	ldr	r3, [r3, #8]
 8001224:	1e5a      	subs	r2, r3, #1
 8001226:	9b01      	ldr	r3, [sp, #4]
 8001228:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800122a:	9b01      	ldr	r3, [sp, #4]
 800122c:	699b      	ldr	r3, [r3, #24]
 800122e:	1c59      	adds	r1, r3, #1
 8001230:	9a01      	ldr	r2, [sp, #4]
 8001232:	6191      	str	r1, [r2, #24]
 8001234:	466a      	mov	r2, sp
 8001236:	320b      	adds	r2, #11
 8001238:	781b      	ldrb	r3, [r3, #0]
 800123a:	7013      	strb	r3, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 800123c:	9b01      	ldr	r3, [sp, #4]
 800123e:	699a      	ldr	r2, [r3, #24]
 8001240:	9b01      	ldr	r3, [sp, #4]
 8001242:	691b      	ldr	r3, [r3, #16]
 8001244:	429a      	cmp	r2, r3
 8001246:	d303      	bcc.n	8001250 <iqGetTimeout+0x80>
    iqp->q_rdptr = iqp->q_buffer;
 8001248:	9b01      	ldr	r3, [sp, #4]
 800124a:	68da      	ldr	r2, [r3, #12]
 800124c:	9b01      	ldr	r3, [sp, #4]
 800124e:	619a      	str	r2, [r3, #24]
  }
  osalSysUnlock();
 8001250:	f7ff ff16 	bl	8001080 <osalSysUnlock.6128.4229>

  return (msg_t)b;
 8001254:	466b      	mov	r3, sp
 8001256:	330b      	adds	r3, #11
 8001258:	781b      	ldrb	r3, [r3, #0]
}
 800125a:	1c18      	adds	r0, r3, #0
 800125c:	b005      	add	sp, #20
 800125e:	bd00      	pop	{pc}

08001260 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8001260:	b500      	push	{lr}
 8001262:	b087      	sub	sp, #28
 8001264:	9003      	str	r0, [sp, #12]
 8001266:	9102      	str	r1, [sp, #8]
 8001268:	9201      	str	r2, [sp, #4]
 800126a:	1c1a      	adds	r2, r3, #0
 800126c:	466b      	mov	r3, sp
 800126e:	3302      	adds	r3, #2
 8001270:	801a      	strh	r2, [r3, #0]
  qnotify_t nfy = iqp->q_notify;
 8001272:	9b03      	ldr	r3, [sp, #12]
 8001274:	69db      	ldr	r3, [r3, #28]
 8001276:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8001278:	2300      	movs	r3, #0
 800127a:	9305      	str	r3, [sp, #20]

  osalDbgCheck(n > 0U);

  osalSysLock();
 800127c:	f7ff fef8 	bl	8001070 <osalSysLock.6126.4231>
  while (true) {
    if (nfy != NULL) {
 8001280:	9b04      	ldr	r3, [sp, #16]
 8001282:	2b00      	cmp	r3, #0
 8001284:	d013      	beq.n	80012ae <iqReadTimeout+0x4e>
      nfy(iqp);
 8001286:	9a03      	ldr	r2, [sp, #12]
 8001288:	9b04      	ldr	r3, [sp, #16]
 800128a:	1c10      	adds	r0, r2, #0
 800128c:	4798      	blx	r3
 800128e:	e00e      	b.n	80012ae <iqReadTimeout+0x4e>
    }

    while (iqIsEmptyI(iqp)) {
      if (osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8001290:	9a03      	ldr	r2, [sp, #12]
 8001292:	466b      	mov	r3, sp
 8001294:	3302      	adds	r3, #2
 8001296:	881b      	ldrh	r3, [r3, #0]
 8001298:	1c10      	adds	r0, r2, #0
 800129a:	1c19      	adds	r1, r3, #0
 800129c:	f7ff ff08 	bl	80010b0 <osalThreadEnqueueTimeoutS.6141.4222>
 80012a0:	1c03      	adds	r3, r0, #0
 80012a2:	2b00      	cmp	r3, #0
 80012a4:	d003      	beq.n	80012ae <iqReadTimeout+0x4e>
        osalSysUnlock();
 80012a6:	f7ff feeb 	bl	8001080 <osalSysUnlock.6128.4229>
        return r;
 80012aa:	9b05      	ldr	r3, [sp, #20]
 80012ac:	e02c      	b.n	8001308 <iqReadTimeout+0xa8>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (iqIsEmptyI(iqp)) {
 80012ae:	9b03      	ldr	r3, [sp, #12]
 80012b0:	689b      	ldr	r3, [r3, #8]
 80012b2:	2b00      	cmp	r3, #0
 80012b4:	d0ec      	beq.n	8001290 <iqReadTimeout+0x30>
        osalSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80012b6:	9b03      	ldr	r3, [sp, #12]
 80012b8:	689b      	ldr	r3, [r3, #8]
 80012ba:	1e5a      	subs	r2, r3, #1
 80012bc:	9b03      	ldr	r3, [sp, #12]
 80012be:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 80012c0:	9b02      	ldr	r3, [sp, #8]
 80012c2:	1c5a      	adds	r2, r3, #1
 80012c4:	9202      	str	r2, [sp, #8]
 80012c6:	9a03      	ldr	r2, [sp, #12]
 80012c8:	6992      	ldr	r2, [r2, #24]
 80012ca:	1c50      	adds	r0, r2, #1
 80012cc:	9903      	ldr	r1, [sp, #12]
 80012ce:	6188      	str	r0, [r1, #24]
 80012d0:	7812      	ldrb	r2, [r2, #0]
 80012d2:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 80012d4:	9b03      	ldr	r3, [sp, #12]
 80012d6:	699a      	ldr	r2, [r3, #24]
 80012d8:	9b03      	ldr	r3, [sp, #12]
 80012da:	691b      	ldr	r3, [r3, #16]
 80012dc:	429a      	cmp	r2, r3
 80012de:	d303      	bcc.n	80012e8 <iqReadTimeout+0x88>
      iqp->q_rdptr = iqp->q_buffer;
 80012e0:	9b03      	ldr	r3, [sp, #12]
 80012e2:	68da      	ldr	r2, [r3, #12]
 80012e4:	9b03      	ldr	r3, [sp, #12]
 80012e6:	619a      	str	r2, [r3, #24]
    }
    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80012e8:	f7ff feca 	bl	8001080 <osalSysUnlock.6128.4229>

    r++;
 80012ec:	9b05      	ldr	r3, [sp, #20]
 80012ee:	3301      	adds	r3, #1
 80012f0:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80012f2:	9b01      	ldr	r3, [sp, #4]
 80012f4:	3b01      	subs	r3, #1
 80012f6:	9301      	str	r3, [sp, #4]
 80012f8:	9b01      	ldr	r3, [sp, #4]
 80012fa:	2b00      	cmp	r3, #0
 80012fc:	d101      	bne.n	8001302 <iqReadTimeout+0xa2>
      return r;
 80012fe:	9b05      	ldr	r3, [sp, #20]
 8001300:	e002      	b.n	8001308 <iqReadTimeout+0xa8>
    }

    osalSysLock();
 8001302:	f7ff feb5 	bl	8001070 <osalSysLock.6126.4231>
 8001306:	e7bb      	b.n	8001280 <iqReadTimeout+0x20>
  }
}
 8001308:	1c18      	adds	r0, r3, #0
 800130a:	b007      	add	sp, #28
 800130c:	bd00      	pop	{pc}
 800130e:	46c0      	nop			; (mov r8, r8)

08001310 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8001310:	b500      	push	{lr}
 8001312:	b085      	sub	sp, #20
 8001314:	9003      	str	r0, [sp, #12]
 8001316:	9102      	str	r1, [sp, #8]
 8001318:	9201      	str	r2, [sp, #4]
 800131a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 800131c:	9b03      	ldr	r3, [sp, #12]
 800131e:	1c18      	adds	r0, r3, #0
 8001320:	f7ff feb6 	bl	8001090 <osalThreadQueueObjectInit.6130.4226>
  oqp->q_counter = size;
 8001324:	9b03      	ldr	r3, [sp, #12]
 8001326:	9a01      	ldr	r2, [sp, #4]
 8001328:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800132a:	9b03      	ldr	r3, [sp, #12]
 800132c:	9a02      	ldr	r2, [sp, #8]
 800132e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8001330:	9b03      	ldr	r3, [sp, #12]
 8001332:	9a02      	ldr	r2, [sp, #8]
 8001334:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8001336:	9b03      	ldr	r3, [sp, #12]
 8001338:	9a02      	ldr	r2, [sp, #8]
 800133a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800133c:	9a02      	ldr	r2, [sp, #8]
 800133e:	9b01      	ldr	r3, [sp, #4]
 8001340:	18d2      	adds	r2, r2, r3
 8001342:	9b03      	ldr	r3, [sp, #12]
 8001344:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8001346:	9b03      	ldr	r3, [sp, #12]
 8001348:	9a00      	ldr	r2, [sp, #0]
 800134a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800134c:	9b03      	ldr	r3, [sp, #12]
 800134e:	9a06      	ldr	r2, [sp, #24]
 8001350:	621a      	str	r2, [r3, #32]
}
 8001352:	b005      	add	sp, #20
 8001354:	bd00      	pop	{pc}
 8001356:	46c0      	nop			; (mov r8, r8)
 8001358:	46c0      	nop			; (mov r8, r8)
 800135a:	46c0      	nop			; (mov r8, r8)
 800135c:	46c0      	nop			; (mov r8, r8)
 800135e:	46c0      	nop			; (mov r8, r8)

08001360 <oqPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001360:	b500      	push	{lr}
 8001362:	b085      	sub	sp, #20
 8001364:	9001      	str	r0, [sp, #4]
 8001366:	466b      	mov	r3, sp
 8001368:	3303      	adds	r3, #3
 800136a:	7019      	strb	r1, [r3, #0]
 800136c:	466b      	mov	r3, sp
 800136e:	801a      	strh	r2, [r3, #0]

  osalSysLock();
 8001370:	f7ff fe7e 	bl	8001070 <osalSysLock.6126.4231>
 8001374:	e00f      	b.n	8001396 <oqPutTimeout+0x36>
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001376:	9a01      	ldr	r2, [sp, #4]
 8001378:	466b      	mov	r3, sp
 800137a:	881b      	ldrh	r3, [r3, #0]
 800137c:	1c10      	adds	r0, r2, #0
 800137e:	1c19      	adds	r1, r3, #0
 8001380:	f7ff fe96 	bl	80010b0 <osalThreadEnqueueTimeoutS.6141.4222>
 8001384:	1c03      	adds	r3, r0, #0
 8001386:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 8001388:	9b03      	ldr	r3, [sp, #12]
 800138a:	2b00      	cmp	r3, #0
 800138c:	da03      	bge.n	8001396 <oqPutTimeout+0x36>
      osalSysUnlock();
 800138e:	f7ff fe77 	bl	8001080 <osalSysUnlock.6128.4229>
      return msg;
 8001392:	9b03      	ldr	r3, [sp, #12]
 8001394:	e027      	b.n	80013e6 <oqPutTimeout+0x86>
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();
  while (oqIsFullI(oqp)) {
 8001396:	9b01      	ldr	r3, [sp, #4]
 8001398:	689b      	ldr	r3, [r3, #8]
 800139a:	2b00      	cmp	r3, #0
 800139c:	d0eb      	beq.n	8001376 <oqPutTimeout+0x16>
      osalSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800139e:	9b01      	ldr	r3, [sp, #4]
 80013a0:	689b      	ldr	r3, [r3, #8]
 80013a2:	1e5a      	subs	r2, r3, #1
 80013a4:	9b01      	ldr	r3, [sp, #4]
 80013a6:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 80013a8:	9b01      	ldr	r3, [sp, #4]
 80013aa:	695b      	ldr	r3, [r3, #20]
 80013ac:	1c59      	adds	r1, r3, #1
 80013ae:	9a01      	ldr	r2, [sp, #4]
 80013b0:	6151      	str	r1, [r2, #20]
 80013b2:	466a      	mov	r2, sp
 80013b4:	3203      	adds	r2, #3
 80013b6:	7812      	ldrb	r2, [r2, #0]
 80013b8:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80013ba:	9b01      	ldr	r3, [sp, #4]
 80013bc:	695a      	ldr	r2, [r3, #20]
 80013be:	9b01      	ldr	r3, [sp, #4]
 80013c0:	691b      	ldr	r3, [r3, #16]
 80013c2:	429a      	cmp	r2, r3
 80013c4:	d303      	bcc.n	80013ce <oqPutTimeout+0x6e>
    oqp->q_wrptr = oqp->q_buffer;
 80013c6:	9b01      	ldr	r3, [sp, #4]
 80013c8:	68da      	ldr	r2, [r3, #12]
 80013ca:	9b01      	ldr	r3, [sp, #4]
 80013cc:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80013ce:	9b01      	ldr	r3, [sp, #4]
 80013d0:	69db      	ldr	r3, [r3, #28]
 80013d2:	2b00      	cmp	r3, #0
 80013d4:	d004      	beq.n	80013e0 <oqPutTimeout+0x80>
    oqp->q_notify(oqp);
 80013d6:	9b01      	ldr	r3, [sp, #4]
 80013d8:	69db      	ldr	r3, [r3, #28]
 80013da:	9a01      	ldr	r2, [sp, #4]
 80013dc:	1c10      	adds	r0, r2, #0
 80013de:	4798      	blx	r3
  }
  osalSysUnlock();
 80013e0:	f7ff fe4e 	bl	8001080 <osalSysUnlock.6128.4229>

  return Q_OK;
 80013e4:	2300      	movs	r3, #0
}
 80013e6:	1c18      	adds	r0, r3, #0
 80013e8:	b005      	add	sp, #20
 80013ea:	bd00      	pop	{pc}
 80013ec:	46c0      	nop			; (mov r8, r8)
 80013ee:	46c0      	nop			; (mov r8, r8)

080013f0 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 80013f0:	b500      	push	{lr}
 80013f2:	b085      	sub	sp, #20
 80013f4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 80013f6:	9b01      	ldr	r3, [sp, #4]
 80013f8:	695a      	ldr	r2, [r3, #20]
 80013fa:	9b01      	ldr	r3, [sp, #4]
 80013fc:	699b      	ldr	r3, [r3, #24]
 80013fe:	429a      	cmp	r2, r3
 8001400:	d105      	bne.n	800140e <oqGetI+0x1e>
 8001402:	9b01      	ldr	r3, [sp, #4]
 8001404:	689b      	ldr	r3, [r3, #8]
 8001406:	2b00      	cmp	r3, #0
 8001408:	d001      	beq.n	800140e <oqGetI+0x1e>
 800140a:	2301      	movs	r3, #1
 800140c:	e000      	b.n	8001410 <oqGetI+0x20>
 800140e:	2300      	movs	r3, #0
 8001410:	1c1a      	adds	r2, r3, #0
 8001412:	2301      	movs	r3, #1
 8001414:	4013      	ands	r3, r2
 8001416:	b2db      	uxtb	r3, r3
 8001418:	2b00      	cmp	r3, #0
 800141a:	d002      	beq.n	8001422 <oqGetI+0x32>
    return Q_EMPTY;
 800141c:	2303      	movs	r3, #3
 800141e:	425b      	negs	r3, r3
 8001420:	e01f      	b.n	8001462 <oqGetI+0x72>
  }

  oqp->q_counter++;
 8001422:	9b01      	ldr	r3, [sp, #4]
 8001424:	689b      	ldr	r3, [r3, #8]
 8001426:	1c5a      	adds	r2, r3, #1
 8001428:	9b01      	ldr	r3, [sp, #4]
 800142a:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 800142c:	9b01      	ldr	r3, [sp, #4]
 800142e:	699b      	ldr	r3, [r3, #24]
 8001430:	1c59      	adds	r1, r3, #1
 8001432:	9a01      	ldr	r2, [sp, #4]
 8001434:	6191      	str	r1, [r2, #24]
 8001436:	466a      	mov	r2, sp
 8001438:	320f      	adds	r2, #15
 800143a:	781b      	ldrb	r3, [r3, #0]
 800143c:	7013      	strb	r3, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 800143e:	9b01      	ldr	r3, [sp, #4]
 8001440:	699a      	ldr	r2, [r3, #24]
 8001442:	9b01      	ldr	r3, [sp, #4]
 8001444:	691b      	ldr	r3, [r3, #16]
 8001446:	429a      	cmp	r2, r3
 8001448:	d303      	bcc.n	8001452 <oqGetI+0x62>
    oqp->q_rdptr = oqp->q_buffer;
 800144a:	9b01      	ldr	r3, [sp, #4]
 800144c:	68da      	ldr	r2, [r3, #12]
 800144e:	9b01      	ldr	r3, [sp, #4]
 8001450:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, Q_OK);
 8001452:	9b01      	ldr	r3, [sp, #4]
 8001454:	1c18      	adds	r0, r3, #0
 8001456:	2100      	movs	r1, #0
 8001458:	f7ff fe42 	bl	80010e0 <osalThreadDequeueNextI.6137.4218>

  return (msg_t)b;
 800145c:	466b      	mov	r3, sp
 800145e:	330f      	adds	r3, #15
 8001460:	781b      	ldrb	r3, [r3, #0]
}
 8001462:	1c18      	adds	r0, r3, #0
 8001464:	b005      	add	sp, #20
 8001466:	bd00      	pop	{pc}
 8001468:	46c0      	nop			; (mov r8, r8)
 800146a:	46c0      	nop			; (mov r8, r8)
 800146c:	46c0      	nop			; (mov r8, r8)
 800146e:	46c0      	nop			; (mov r8, r8)

08001470 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8001470:	b500      	push	{lr}
 8001472:	b087      	sub	sp, #28
 8001474:	9003      	str	r0, [sp, #12]
 8001476:	9102      	str	r1, [sp, #8]
 8001478:	9201      	str	r2, [sp, #4]
 800147a:	1c1a      	adds	r2, r3, #0
 800147c:	466b      	mov	r3, sp
 800147e:	3302      	adds	r3, #2
 8001480:	801a      	strh	r2, [r3, #0]
  qnotify_t nfy = oqp->q_notify;
 8001482:	9b03      	ldr	r3, [sp, #12]
 8001484:	69db      	ldr	r3, [r3, #28]
 8001486:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8001488:	2300      	movs	r3, #0
 800148a:	9305      	str	r3, [sp, #20]

  osalDbgCheck(n > 0U);

  osalSysLock();
 800148c:	f7ff fdf0 	bl	8001070 <osalSysLock.6126.4231>
 8001490:	e00e      	b.n	80014b0 <oqWriteTimeout+0x40>
  while (true) {
    while (oqIsFullI(oqp)) {
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8001492:	9a03      	ldr	r2, [sp, #12]
 8001494:	466b      	mov	r3, sp
 8001496:	3302      	adds	r3, #2
 8001498:	881b      	ldrh	r3, [r3, #0]
 800149a:	1c10      	adds	r0, r2, #0
 800149c:	1c19      	adds	r1, r3, #0
 800149e:	f7ff fe07 	bl	80010b0 <osalThreadEnqueueTimeoutS.6141.4222>
 80014a2:	1c03      	adds	r3, r0, #0
 80014a4:	2b00      	cmp	r3, #0
 80014a6:	d003      	beq.n	80014b0 <oqWriteTimeout+0x40>
        osalSysUnlock();
 80014a8:	f7ff fdea 	bl	8001080 <osalSysUnlock.6128.4229>
        return w;
 80014ac:	9b05      	ldr	r3, [sp, #20]
 80014ae:	e033      	b.n	8001518 <oqWriteTimeout+0xa8>

  osalDbgCheck(n > 0U);

  osalSysLock();
  while (true) {
    while (oqIsFullI(oqp)) {
 80014b0:	9b03      	ldr	r3, [sp, #12]
 80014b2:	689b      	ldr	r3, [r3, #8]
 80014b4:	2b00      	cmp	r3, #0
 80014b6:	d0ec      	beq.n	8001492 <oqWriteTimeout+0x22>
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
        osalSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 80014b8:	9b03      	ldr	r3, [sp, #12]
 80014ba:	689b      	ldr	r3, [r3, #8]
 80014bc:	1e5a      	subs	r2, r3, #1
 80014be:	9b03      	ldr	r3, [sp, #12]
 80014c0:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 80014c2:	9b03      	ldr	r3, [sp, #12]
 80014c4:	695b      	ldr	r3, [r3, #20]
 80014c6:	1c59      	adds	r1, r3, #1
 80014c8:	9a03      	ldr	r2, [sp, #12]
 80014ca:	6151      	str	r1, [r2, #20]
 80014cc:	9a02      	ldr	r2, [sp, #8]
 80014ce:	1c51      	adds	r1, r2, #1
 80014d0:	9102      	str	r1, [sp, #8]
 80014d2:	7812      	ldrb	r2, [r2, #0]
 80014d4:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80014d6:	9b03      	ldr	r3, [sp, #12]
 80014d8:	695a      	ldr	r2, [r3, #20]
 80014da:	9b03      	ldr	r3, [sp, #12]
 80014dc:	691b      	ldr	r3, [r3, #16]
 80014de:	429a      	cmp	r2, r3
 80014e0:	d303      	bcc.n	80014ea <oqWriteTimeout+0x7a>
      oqp->q_wrptr = oqp->q_buffer;
 80014e2:	9b03      	ldr	r3, [sp, #12]
 80014e4:	68da      	ldr	r2, [r3, #12]
 80014e6:	9b03      	ldr	r3, [sp, #12]
 80014e8:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80014ea:	9b04      	ldr	r3, [sp, #16]
 80014ec:	2b00      	cmp	r3, #0
 80014ee:	d003      	beq.n	80014f8 <oqWriteTimeout+0x88>
      nfy(oqp);
 80014f0:	9a03      	ldr	r2, [sp, #12]
 80014f2:	9b04      	ldr	r3, [sp, #16]
 80014f4:	1c10      	adds	r0, r2, #0
 80014f6:	4798      	blx	r3
    }
    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80014f8:	f7ff fdc2 	bl	8001080 <osalSysUnlock.6128.4229>

    w++;
 80014fc:	9b05      	ldr	r3, [sp, #20]
 80014fe:	3301      	adds	r3, #1
 8001500:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8001502:	9b01      	ldr	r3, [sp, #4]
 8001504:	3b01      	subs	r3, #1
 8001506:	9301      	str	r3, [sp, #4]
 8001508:	9b01      	ldr	r3, [sp, #4]
 800150a:	2b00      	cmp	r3, #0
 800150c:	d101      	bne.n	8001512 <oqWriteTimeout+0xa2>
      return w;
 800150e:	9b05      	ldr	r3, [sp, #20]
 8001510:	e002      	b.n	8001518 <oqWriteTimeout+0xa8>
    }

    osalSysLock();
 8001512:	f7ff fdad 	bl	8001070 <osalSysLock.6126.4231>
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);

  osalSysLock();
 8001516:	e7cb      	b.n	80014b0 <oqWriteTimeout+0x40>
      return w;
    }

    osalSysLock();
  }
}
 8001518:	1c18      	adds	r0, r3, #0
 800151a:	b007      	add	sp, #28
 800151c:	bd00      	pop	{pc}
 800151e:	46c0      	nop			; (mov r8, r8)

08001520 <osalEventObjectInit.6291>:
static inline void osalEventObjectInit(event_source_t *esp) {

  chEvtObjectInit(esp);
}
#else
static inline void osalEventObjectInit(event_source_t *esp) {
 8001520:	b082      	sub	sp, #8
 8001522:	9001      	str	r0, [sp, #4]

  esp->flags = 0;
 8001524:	9b01      	ldr	r3, [sp, #4]
 8001526:	2200      	movs	r2, #0
 8001528:	601a      	str	r2, [r3, #0]
}
 800152a:	b002      	add	sp, #8
 800152c:	4770      	bx	lr
 800152e:	46c0      	nop			; (mov r8, r8)

08001530 <osalEventBroadcastFlagsI.6300>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8001530:	b082      	sub	sp, #8
 8001532:	9001      	str	r0, [sp, #4]
 8001534:	9100      	str	r1, [sp, #0]

  esp->flags |= flags;
 8001536:	9b01      	ldr	r3, [sp, #4]
 8001538:	681a      	ldr	r2, [r3, #0]
 800153a:	9b00      	ldr	r3, [sp, #0]
 800153c:	431a      	orrs	r2, r3
 800153e:	9b01      	ldr	r3, [sp, #4]
 8001540:	601a      	str	r2, [r3, #0]
}
 8001542:	b002      	add	sp, #8
 8001544:	4770      	bx	lr
 8001546:	46c0      	nop			; (mov r8, r8)
 8001548:	46c0      	nop			; (mov r8, r8)
 800154a:	46c0      	nop			; (mov r8, r8)
 800154c:	46c0      	nop			; (mov r8, r8)
 800154e:	46c0      	nop			; (mov r8, r8)

08001550 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001550:	4770      	bx	lr
 8001552:	46c0      	nop			; (mov r8, r8)
 8001554:	46c0      	nop			; (mov r8, r8)
 8001556:	46c0      	nop			; (mov r8, r8)
 8001558:	46c0      	nop			; (mov r8, r8)
 800155a:	46c0      	nop			; (mov r8, r8)
 800155c:	46c0      	nop			; (mov r8, r8)
 800155e:	46c0      	nop			; (mov r8, r8)

08001560 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001560:	4770      	bx	lr
 8001562:	46c0      	nop			; (mov r8, r8)
 8001564:	46c0      	nop			; (mov r8, r8)
 8001566:	46c0      	nop			; (mov r8, r8)
 8001568:	46c0      	nop			; (mov r8, r8)
 800156a:	46c0      	nop			; (mov r8, r8)
 800156c:	46c0      	nop			; (mov r8, r8)
 800156e:	46c0      	nop			; (mov r8, r8)

08001570 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001570:	e7fe      	b.n	8001570 <__default_exit>
 8001572:	46c0      	nop			; (mov r8, r8)
 8001574:	46c0      	nop			; (mov r8, r8)
 8001576:	46c0      	nop			; (mov r8, r8)
 8001578:	46c0      	nop			; (mov r8, r8)
 800157a:	46c0      	nop			; (mov r8, r8)
 800157c:	46c0      	nop			; (mov r8, r8)
 800157e:	46c0      	nop			; (mov r8, r8)

08001580 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001580:	e7fe      	b.n	8001580 <BusFault_Handler>
 8001582:	46c0      	nop			; (mov r8, r8)
 8001584:	46c0      	nop			; (mov r8, r8)
 8001586:	46c0      	nop			; (mov r8, r8)
 8001588:	46c0      	nop			; (mov r8, r8)
 800158a:	46c0      	nop			; (mov r8, r8)
 800158c:	46c0      	nop			; (mov r8, r8)
 800158e:	46c0      	nop			; (mov r8, r8)

08001590 <NVIC_SetPriority.4097.4486>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001590:	b530      	push	{r4, r5, lr}
 8001592:	b083      	sub	sp, #12
 8001594:	1c02      	adds	r2, r0, #0
 8001596:	9100      	str	r1, [sp, #0]
 8001598:	466b      	mov	r3, sp
 800159a:	3307      	adds	r3, #7
 800159c:	701a      	strb	r2, [r3, #0]
  if((int32_t)(IRQn) < 0) {
 800159e:	466b      	mov	r3, sp
 80015a0:	3307      	adds	r3, #7
 80015a2:	781b      	ldrb	r3, [r3, #0]
 80015a4:	2b7f      	cmp	r3, #127	; 0x7f
 80015a6:	d936      	bls.n	8001616 <NVIC_SetPriority.4097.4486+0x86>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80015a8:	4933      	ldr	r1, [pc, #204]	; (8001678 <NVIC_SetPriority.4097.4486+0xe8>)
 80015aa:	466b      	mov	r3, sp
 80015ac:	3307      	adds	r3, #7
 80015ae:	781b      	ldrb	r3, [r3, #0]
 80015b0:	1c1a      	adds	r2, r3, #0
 80015b2:	230f      	movs	r3, #15
 80015b4:	4013      	ands	r3, r2
 80015b6:	3b08      	subs	r3, #8
 80015b8:	0898      	lsrs	r0, r3, #2
 80015ba:	4a2f      	ldr	r2, [pc, #188]	; (8001678 <NVIC_SetPriority.4097.4486+0xe8>)
 80015bc:	466b      	mov	r3, sp
 80015be:	3307      	adds	r3, #7
 80015c0:	781b      	ldrb	r3, [r3, #0]
 80015c2:	1c1c      	adds	r4, r3, #0
 80015c4:	230f      	movs	r3, #15
 80015c6:	4023      	ands	r3, r4
 80015c8:	3b08      	subs	r3, #8
 80015ca:	089b      	lsrs	r3, r3, #2
 80015cc:	3306      	adds	r3, #6
 80015ce:	009b      	lsls	r3, r3, #2
 80015d0:	18d3      	adds	r3, r2, r3
 80015d2:	685b      	ldr	r3, [r3, #4]
 80015d4:	466a      	mov	r2, sp
 80015d6:	3207      	adds	r2, #7
 80015d8:	7812      	ldrb	r2, [r2, #0]
 80015da:	1c14      	adds	r4, r2, #0
 80015dc:	2203      	movs	r2, #3
 80015de:	4022      	ands	r2, r4
 80015e0:	00d2      	lsls	r2, r2, #3
 80015e2:	24ff      	movs	r4, #255	; 0xff
 80015e4:	1c25      	adds	r5, r4, #0
 80015e6:	4095      	lsls	r5, r2
 80015e8:	1c2a      	adds	r2, r5, #0
 80015ea:	43d2      	mvns	r2, r2
 80015ec:	401a      	ands	r2, r3
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80015ee:	9b00      	ldr	r3, [sp, #0]
 80015f0:	019c      	lsls	r4, r3, #6
 80015f2:	23ff      	movs	r3, #255	; 0xff
 80015f4:	401c      	ands	r4, r3
 80015f6:	466b      	mov	r3, sp
 80015f8:	3307      	adds	r3, #7
 80015fa:	781b      	ldrb	r3, [r3, #0]
 80015fc:	1c1d      	adds	r5, r3, #0
 80015fe:	2303      	movs	r3, #3
 8001600:	402b      	ands	r3, r5
 8001602:	00db      	lsls	r3, r3, #3
 8001604:	1c25      	adds	r5, r4, #0
 8001606:	409d      	lsls	r5, r3
 8001608:	1c2b      	adds	r3, r5, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800160a:	431a      	orrs	r2, r3
 800160c:	1d83      	adds	r3, r0, #6
 800160e:	009b      	lsls	r3, r3, #2
 8001610:	18cb      	adds	r3, r1, r3
 8001612:	605a      	str	r2, [r3, #4]
 8001614:	e02d      	b.n	8001672 <NVIC_SetPriority.4097.4486+0xe2>
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001616:	4b19      	ldr	r3, [pc, #100]	; (800167c <NVIC_SetPriority.4097.4486+0xec>)
 8001618:	466a      	mov	r2, sp
 800161a:	3207      	adds	r2, #7
 800161c:	7812      	ldrb	r2, [r2, #0]
 800161e:	b252      	sxtb	r2, r2
 8001620:	0892      	lsrs	r2, r2, #2
 8001622:	4916      	ldr	r1, [pc, #88]	; (800167c <NVIC_SetPriority.4097.4486+0xec>)
 8001624:	4668      	mov	r0, sp
 8001626:	3007      	adds	r0, #7
 8001628:	7800      	ldrb	r0, [r0, #0]
 800162a:	b240      	sxtb	r0, r0
 800162c:	0880      	lsrs	r0, r0, #2
 800162e:	30c0      	adds	r0, #192	; 0xc0
 8001630:	0080      	lsls	r0, r0, #2
 8001632:	5841      	ldr	r1, [r0, r1]
 8001634:	4668      	mov	r0, sp
 8001636:	3007      	adds	r0, #7
 8001638:	7800      	ldrb	r0, [r0, #0]
 800163a:	1c04      	adds	r4, r0, #0
 800163c:	2003      	movs	r0, #3
 800163e:	4020      	ands	r0, r4
 8001640:	00c0      	lsls	r0, r0, #3
 8001642:	24ff      	movs	r4, #255	; 0xff
 8001644:	1c25      	adds	r5, r4, #0
 8001646:	4085      	lsls	r5, r0
 8001648:	1c28      	adds	r0, r5, #0
 800164a:	43c0      	mvns	r0, r0
 800164c:	4008      	ands	r0, r1
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800164e:	9900      	ldr	r1, [sp, #0]
 8001650:	018c      	lsls	r4, r1, #6
 8001652:	21ff      	movs	r1, #255	; 0xff
 8001654:	400c      	ands	r4, r1
 8001656:	4669      	mov	r1, sp
 8001658:	3107      	adds	r1, #7
 800165a:	7809      	ldrb	r1, [r1, #0]
 800165c:	1c0d      	adds	r5, r1, #0
 800165e:	2103      	movs	r1, #3
 8001660:	4029      	ands	r1, r5
 8001662:	00c9      	lsls	r1, r1, #3
 8001664:	1c25      	adds	r5, r4, #0
 8001666:	408d      	lsls	r5, r1
 8001668:	1c29      	adds	r1, r5, #0
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800166a:	4301      	orrs	r1, r0
 800166c:	32c0      	adds	r2, #192	; 0xc0
 800166e:	0092      	lsls	r2, r2, #2
 8001670:	50d1      	str	r1, [r2, r3]
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8001672:	b003      	add	sp, #12
 8001674:	bd30      	pop	{r4, r5, pc}
 8001676:	46c0      	nop			; (mov r8, r8)
 8001678:	e000ed00 	.word	0xe000ed00
 800167c:	e000e100 	.word	0xe000e100

08001680 <port_init.4106.4484>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8001680:	b508      	push	{r3, lr}

  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8001682:	2302      	movs	r3, #2
 8001684:	425b      	negs	r3, r3
 8001686:	1c18      	adds	r0, r3, #0
 8001688:	2100      	movs	r1, #0
 800168a:	f7ff ff81 	bl	8001590 <NVIC_SetPriority.4097.4486>
}
 800168e:	bd08      	pop	{r3, pc}

08001690 <port_lock.4117.4475>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001690:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001692:	4770      	bx	lr
 8001694:	46c0      	nop			; (mov r8, r8)
 8001696:	46c0      	nop			; (mov r8, r8)
 8001698:	46c0      	nop			; (mov r8, r8)
 800169a:	46c0      	nop			; (mov r8, r8)
 800169c:	46c0      	nop			; (mov r8, r8)
 800169e:	46c0      	nop			; (mov r8, r8)

080016a0 <port_unlock.4119.4473>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80016a0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80016a2:	4770      	bx	lr
 80016a4:	46c0      	nop			; (mov r8, r8)
 80016a6:	46c0      	nop			; (mov r8, r8)
 80016a8:	46c0      	nop			; (mov r8, r8)
 80016aa:	46c0      	nop			; (mov r8, r8)
 80016ac:	46c0      	nop			; (mov r8, r8)
 80016ae:	46c0      	nop			; (mov r8, r8)

080016b0 <port_lock_from_isr.4121.4471>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80016b0:	b508      	push	{r3, lr}

  port_lock();
 80016b2:	f7ff ffed 	bl	8001690 <port_lock.4117.4475>
}
 80016b6:	bd08      	pop	{r3, pc}
 80016b8:	46c0      	nop			; (mov r8, r8)
 80016ba:	46c0      	nop			; (mov r8, r8)
 80016bc:	46c0      	nop			; (mov r8, r8)
 80016be:	46c0      	nop			; (mov r8, r8)

080016c0 <port_unlock_from_isr.4123.4469>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80016c0:	b508      	push	{r3, lr}

  port_unlock();
 80016c2:	f7ff ffed 	bl	80016a0 <port_unlock.4119.4473>
}
 80016c6:	bd08      	pop	{r3, pc}
 80016c8:	46c0      	nop			; (mov r8, r8)
 80016ca:	46c0      	nop			; (mov r8, r8)
 80016cc:	46c0      	nop			; (mov r8, r8)
 80016ce:	46c0      	nop			; (mov r8, r8)

080016d0 <port_enable.4127.4465>:
 80016d0:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 80016d2:	4770      	bx	lr
 80016d4:	46c0      	nop			; (mov r8, r8)
 80016d6:	46c0      	nop			; (mov r8, r8)
 80016d8:	46c0      	nop			; (mov r8, r8)
 80016da:	46c0      	nop			; (mov r8, r8)
 80016dc:	46c0      	nop			; (mov r8, r8)
 80016de:	46c0      	nop			; (mov r8, r8)

080016e0 <port_wait_for_interrupt.4129.4463>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 80016e0:	4770      	bx	lr
 80016e2:	46c0      	nop			; (mov r8, r8)
 80016e4:	46c0      	nop			; (mov r8, r8)
 80016e6:	46c0      	nop			; (mov r8, r8)
 80016e8:	46c0      	nop			; (mov r8, r8)
 80016ea:	46c0      	nop			; (mov r8, r8)
 80016ec:	46c0      	nop			; (mov r8, r8)
 80016ee:	46c0      	nop			; (mov r8, r8)

080016f0 <st_lld_get_counter.4131.4461>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80016f0:	4b02      	ldr	r3, [pc, #8]	; (80016fc <st_lld_get_counter.4131.4461+0xc>)
 80016f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80016f4:	b29b      	uxth	r3, r3
}
 80016f6:	1c18      	adds	r0, r3, #0
 80016f8:	4770      	bx	lr
 80016fa:	46c0      	nop			; (mov r8, r8)
 80016fc:	40000400 	.word	0x40000400

08001700 <port_timer_stop_alarm.4221.4459>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8001700:	b508      	push	{r3, lr}

  stStopAlarm();
 8001702:	f7ff fc5d 	bl	8000fc0 <stStopAlarm>
}
 8001706:	bd08      	pop	{r3, pc}
 8001708:	46c0      	nop			; (mov r8, r8)
 800170a:	46c0      	nop			; (mov r8, r8)
 800170c:	46c0      	nop			; (mov r8, r8)
 800170e:	46c0      	nop			; (mov r8, r8)

08001710 <port_timer_set_alarm.4223.4456>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8001710:	b500      	push	{lr}
 8001712:	b083      	sub	sp, #12
 8001714:	1c02      	adds	r2, r0, #0
 8001716:	466b      	mov	r3, sp
 8001718:	3306      	adds	r3, #6
 800171a:	801a      	strh	r2, [r3, #0]

  stSetAlarm(time);
 800171c:	466b      	mov	r3, sp
 800171e:	3306      	adds	r3, #6
 8001720:	881b      	ldrh	r3, [r3, #0]
 8001722:	1c18      	adds	r0, r3, #0
 8001724:	f7ff fc54 	bl	8000fd0 <stSetAlarm>
}
 8001728:	b003      	add	sp, #12
 800172a:	bd00      	pop	{pc}
 800172c:	46c0      	nop			; (mov r8, r8)
 800172e:	46c0      	nop			; (mov r8, r8)

08001730 <port_timer_get_time.4136.4454>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8001730:	b508      	push	{r3, lr}

  return stGetCounter();
 8001732:	f7ff ffdd 	bl	80016f0 <st_lld_get_counter.4131.4461>
 8001736:	1c03      	adds	r3, r0, #0
}
 8001738:	1c18      	adds	r0, r3, #0
 800173a:	bd08      	pop	{r3, pc}
 800173c:	46c0      	nop			; (mov r8, r8)
 800173e:	46c0      	nop			; (mov r8, r8)

08001740 <chSysEnable.4138.4452>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8001740:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 8001742:	f7ff ffc5 	bl	80016d0 <port_enable.4127.4465>
}
 8001746:	bd08      	pop	{r3, pc}
 8001748:	46c0      	nop			; (mov r8, r8)
 800174a:	46c0      	nop			; (mov r8, r8)
 800174c:	46c0      	nop			; (mov r8, r8)
 800174e:	46c0      	nop			; (mov r8, r8)

08001750 <chSysLockFromISR.4144.4446>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001750:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001752:	f7ff ffad 	bl	80016b0 <port_lock_from_isr.4121.4471>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001756:	bd08      	pop	{r3, pc}
 8001758:	46c0      	nop			; (mov r8, r8)
 800175a:	46c0      	nop			; (mov r8, r8)
 800175c:	46c0      	nop			; (mov r8, r8)
 800175e:	46c0      	nop			; (mov r8, r8)

08001760 <chSysUnlockFromISR.4146.4444>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001760:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001762:	f7ff ffad 	bl	80016c0 <port_unlock_from_isr.4123.4469>
}
 8001766:	bd08      	pop	{r3, pc}
 8001768:	46c0      	nop			; (mov r8, r8)
 800176a:	46c0      	nop			; (mov r8, r8)
 800176c:	46c0      	nop			; (mov r8, r8)
 800176e:	46c0      	nop			; (mov r8, r8)

08001770 <chVTGetSystemTimeX.4148.4442>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8001770:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8001772:	f7ff ffdd 	bl	8001730 <port_timer_get_time.4136.4454>
 8001776:	1c03      	adds	r3, r0, #0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001778:	1c18      	adds	r0, r3, #0
 800177a:	bd08      	pop	{r3, pc}
 800177c:	46c0      	nop			; (mov r8, r8)
 800177e:	46c0      	nop			; (mov r8, r8)

08001780 <chVTDoTickI.4226.4440>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8001780:	b510      	push	{r4, lr}
 8001782:	b084      	sub	sp, #16
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8001784:	4b33      	ldr	r3, [pc, #204]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 8001786:	69db      	ldr	r3, [r3, #28]
 8001788:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 800178a:	466c      	mov	r4, sp
 800178c:	340a      	adds	r4, #10
 800178e:	f7ff ffef 	bl	8001770 <chVTGetSystemTimeX.4148.4442>
 8001792:	1c03      	adds	r3, r0, #0
 8001794:	8023      	strh	r3, [r4, #0]
 8001796:	e02e      	b.n	80017f6 <chVTDoTickI.4226.4440+0x76>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001798:	4b2e      	ldr	r3, [pc, #184]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 800179a:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800179c:	9b03      	ldr	r3, [sp, #12]
 800179e:	891b      	ldrh	r3, [r3, #8]
 80017a0:	18d3      	adds	r3, r2, r3
 80017a2:	b29a      	uxth	r2, r3
 80017a4:	4b2b      	ldr	r3, [pc, #172]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 80017a6:	84da      	strh	r2, [r3, #38]	; 0x26

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80017a8:	9b03      	ldr	r3, [sp, #12]
 80017aa:	681b      	ldr	r3, [r3, #0]
 80017ac:	4a2a      	ldr	r2, [pc, #168]	; (8001858 <chVTDoTickI.4226.4440+0xd8>)
 80017ae:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 80017b0:	9b03      	ldr	r3, [sp, #12]
 80017b2:	681a      	ldr	r2, [r3, #0]
 80017b4:	4b27      	ldr	r3, [pc, #156]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 80017b6:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
 80017b8:	9b03      	ldr	r3, [sp, #12]
 80017ba:	68db      	ldr	r3, [r3, #12]
 80017bc:	9301      	str	r3, [sp, #4]
    vtp->vt_func = NULL;
 80017be:	9b03      	ldr	r3, [sp, #12]
 80017c0:	2200      	movs	r2, #0
 80017c2:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80017c4:	4b23      	ldr	r3, [pc, #140]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 80017c6:	69da      	ldr	r2, [r3, #28]
 80017c8:	4b23      	ldr	r3, [pc, #140]	; (8001858 <chVTDoTickI.4226.4440+0xd8>)
 80017ca:	429a      	cmp	r2, r3
 80017cc:	d101      	bne.n	80017d2 <chVTDoTickI.4226.4440+0x52>
      port_timer_stop_alarm();
 80017ce:	f7ff ff97 	bl	8001700 <port_timer_stop_alarm.4221.4459>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 80017d2:	f7ff ffc5 	bl	8001760 <chSysUnlockFromISR.4146.4444>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 80017d6:	9b03      	ldr	r3, [sp, #12]
 80017d8:	691a      	ldr	r2, [r3, #16]
 80017da:	9b01      	ldr	r3, [sp, #4]
 80017dc:	1c10      	adds	r0, r2, #0
 80017de:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 80017e0:	f7ff ffb6 	bl	8001750 <chSysLockFromISR.4144.4446>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 80017e4:	4b1b      	ldr	r3, [pc, #108]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 80017e6:	69db      	ldr	r3, [r3, #28]
 80017e8:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 80017ea:	466c      	mov	r4, sp
 80017ec:	340a      	adds	r4, #10
 80017ee:	f7ff ffbf 	bl	8001770 <chVTGetSystemTimeX.4148.4442>
 80017f2:	1c03      	adds	r3, r0, #0
 80017f4:	8023      	strh	r3, [r4, #0]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80017f6:	9b03      	ldr	r3, [sp, #12]
 80017f8:	891a      	ldrh	r2, [r3, #8]
 80017fa:	4b16      	ldr	r3, [pc, #88]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 80017fc:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 80017fe:	4669      	mov	r1, sp
 8001800:	310a      	adds	r1, #10
 8001802:	8809      	ldrh	r1, [r1, #0]
 8001804:	1acb      	subs	r3, r1, r3
 8001806:	b29b      	uxth	r3, r3
 8001808:	429a      	cmp	r2, r3
 800180a:	d9c5      	bls.n	8001798 <chVTDoTickI.4226.4440+0x18>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800180c:	4b11      	ldr	r3, [pc, #68]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 800180e:	69da      	ldr	r2, [r3, #28]
 8001810:	4b11      	ldr	r3, [pc, #68]	; (8001858 <chVTDoTickI.4226.4440+0xd8>)
 8001812:	429a      	cmp	r2, r3
 8001814:	d01c      	beq.n	8001850 <chVTDoTickI.4226.4440+0xd0>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8001816:	4b0f      	ldr	r3, [pc, #60]	; (8001854 <chVTDoTickI.4226.4440+0xd4>)
 8001818:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800181a:	9b03      	ldr	r3, [sp, #12]
 800181c:	891b      	ldrh	r3, [r3, #8]
 800181e:	18d3      	adds	r3, r2, r3
 8001820:	b299      	uxth	r1, r3
 8001822:	ab02      	add	r3, sp, #8
 8001824:	466a      	mov	r2, sp
 8001826:	320a      	adds	r2, #10
 8001828:	8812      	ldrh	r2, [r2, #0]
 800182a:	1a8a      	subs	r2, r1, r2
 800182c:	801a      	strh	r2, [r3, #0]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800182e:	ab02      	add	r3, sp, #8
 8001830:	881b      	ldrh	r3, [r3, #0]
 8001832:	2b04      	cmp	r3, #4
 8001834:	d802      	bhi.n	800183c <chVTDoTickI.4226.4440+0xbc>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001836:	ab02      	add	r3, sp, #8
 8001838:	2205      	movs	r2, #5
 800183a:	801a      	strh	r2, [r3, #0]
  }
  port_timer_set_alarm(now + delta);
 800183c:	466a      	mov	r2, sp
 800183e:	320a      	adds	r2, #10
 8001840:	ab02      	add	r3, sp, #8
 8001842:	8812      	ldrh	r2, [r2, #0]
 8001844:	881b      	ldrh	r3, [r3, #0]
 8001846:	18d3      	adds	r3, r2, r3
 8001848:	b29b      	uxth	r3, r3
 800184a:	1c18      	adds	r0, r3, #0
 800184c:	f7ff ff60 	bl	8001710 <port_timer_set_alarm.4223.4456>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001850:	b004      	add	sp, #16
 8001852:	bd10      	pop	{r4, pc}
 8001854:	20000300 	.word	0x20000300
 8001858:	2000031c 	.word	0x2000031c
 800185c:	46c0      	nop			; (mov r8, r8)
 800185e:	46c0      	nop			; (mov r8, r8)

08001860 <chRegSetThreadName.4150.4437>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8001860:	b082      	sub	sp, #8
 8001862:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001864:	4b02      	ldr	r3, [pc, #8]	; (8001870 <chRegSetThreadName.4150.4437+0x10>)
 8001866:	699b      	ldr	r3, [r3, #24]
 8001868:	9a01      	ldr	r2, [sp, #4]
 800186a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800186c:	b002      	add	sp, #8
 800186e:	4770      	bx	lr
 8001870:	20000300 	.word	0x20000300
 8001874:	46c0      	nop			; (mov r8, r8)
 8001876:	46c0      	nop			; (mov r8, r8)
 8001878:	46c0      	nop			; (mov r8, r8)
 800187a:	46c0      	nop			; (mov r8, r8)
 800187c:	46c0      	nop			; (mov r8, r8)
 800187e:	46c0      	nop			; (mov r8, r8)

08001880 <chRegSetThreadNameX.4154.4433>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8001880:	b082      	sub	sp, #8
 8001882:	9001      	str	r0, [sp, #4]
 8001884:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8001886:	9b01      	ldr	r3, [sp, #4]
 8001888:	9a00      	ldr	r2, [sp, #0]
 800188a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800188c:	b002      	add	sp, #8
 800188e:	4770      	bx	lr

08001890 <_idle_thread.4218.4430>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001890:	b500      	push	{lr}
 8001892:	b083      	sub	sp, #12
 8001894:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8001896:	f7ff ff23 	bl	80016e0 <port_wait_for_interrupt.4129.4463>
 800189a:	e7fc      	b.n	8001896 <_idle_thread.4218.4430+0x6>
 800189c:	46c0      	nop			; (mov r8, r8)
 800189e:	46c0      	nop			; (mov r8, r8)

080018a0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80018a0:	b500      	push	{lr}
 80018a2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80018a4:	f7ff feec 	bl	8001680 <port_init.4106.4484>
  _scheduler_init();
 80018a8:	f000 fa12 	bl	8001cd0 <_scheduler_init.4355>
  _vt_init();
 80018ac:	f000 f880 	bl	80019b0 <_vt_init.4398>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80018b0:	f7ff fa46 	bl	8000d40 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80018b4:	f7ff fa9c 	bl	8000df0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80018b8:	4b12      	ldr	r3, [pc, #72]	; (8001904 <chSysInit+0x64>)
 80018ba:	1c18      	adds	r0, r3, #0
 80018bc:	2140      	movs	r1, #64	; 0x40
 80018be:	f000 fc17 	bl	80020f0 <_thread_init.4256>
 80018c2:	1c02      	adds	r2, r0, #0
 80018c4:	4b10      	ldr	r3, [pc, #64]	; (8001908 <chSysInit+0x68>)
 80018c6:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80018c8:	4b0f      	ldr	r3, [pc, #60]	; (8001908 <chSysInit+0x68>)
 80018ca:	699b      	ldr	r3, [r3, #24]
 80018cc:	2201      	movs	r2, #1
 80018ce:	771a      	strb	r2, [r3, #28]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 80018d0:	f7ff ff36 	bl	8001740 <chSysEnable.4138.4452>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80018d4:	4b0d      	ldr	r3, [pc, #52]	; (800190c <chSysInit+0x6c>)
 80018d6:	1c18      	adds	r0, r3, #0
 80018d8:	f7ff ffc2 	bl	8001860 <chRegSetThreadName.4150.4437>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80018dc:	4a0c      	ldr	r2, [pc, #48]	; (8001910 <chSysInit+0x70>)
 80018de:	4b0d      	ldr	r3, [pc, #52]	; (8001914 <chSysInit+0x74>)
 80018e0:	2100      	movs	r1, #0
 80018e2:	9100      	str	r1, [sp, #0]
 80018e4:	1c10      	adds	r0, r2, #0
 80018e6:	21c8      	movs	r1, #200	; 0xc8
 80018e8:	2201      	movs	r2, #1
 80018ea:	f000 fc59 	bl	80021a0 <chThdCreateStatic.4239>
 80018ee:	1c03      	adds	r3, r0, #0
 80018f0:	9303      	str	r3, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 80018f2:	9a03      	ldr	r2, [sp, #12]
 80018f4:	4b08      	ldr	r3, [pc, #32]	; (8001918 <chSysInit+0x78>)
 80018f6:	1c10      	adds	r0, r2, #0
 80018f8:	1c19      	adds	r1, r3, #0
 80018fa:	f7ff ffc1 	bl	8001880 <chRegSetThreadNameX.4154.4433>
  }
#endif
}
 80018fe:	b005      	add	sp, #20
 8001900:	bd00      	pop	{pc}
 8001902:	46c0      	nop			; (mov r8, r8)
 8001904:	2000032c 	.word	0x2000032c
 8001908:	20000300 	.word	0x20000300
 800190c:	08002340 	.word	0x08002340
 8001910:	20000360 	.word	0x20000360
 8001914:	08001891 	.word	0x08001891
 8001918:	08002330 	.word	0x08002330
 800191c:	46c0      	nop			; (mov r8, r8)
 800191e:	46c0      	nop			; (mov r8, r8)

08001920 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8001920:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8001922:	f7ff ff2d 	bl	8001780 <chVTDoTickI.4226.4440>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 8001926:	bd08      	pop	{r3, pc}
 8001928:	46c0      	nop			; (mov r8, r8)
 800192a:	46c0      	nop			; (mov r8, r8)
 800192c:	46c0      	nop			; (mov r8, r8)
 800192e:	46c0      	nop			; (mov r8, r8)

08001930 <st_lld_get_counter.4377.4412>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001930:	4b02      	ldr	r3, [pc, #8]	; (800193c <st_lld_get_counter.4377.4412+0xc>)
 8001932:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001934:	b29b      	uxth	r3, r3
}
 8001936:	1c18      	adds	r0, r3, #0
 8001938:	4770      	bx	lr
 800193a:	46c0      	nop			; (mov r8, r8)
 800193c:	40000400 	.word	0x40000400

08001940 <port_timer_start_alarm.4387.4409>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8001940:	b500      	push	{lr}
 8001942:	b083      	sub	sp, #12
 8001944:	1c02      	adds	r2, r0, #0
 8001946:	466b      	mov	r3, sp
 8001948:	3306      	adds	r3, #6
 800194a:	801a      	strh	r2, [r3, #0]

  stStartAlarm(time);
 800194c:	466b      	mov	r3, sp
 800194e:	3306      	adds	r3, #6
 8001950:	881b      	ldrh	r3, [r3, #0]
 8001952:	1c18      	adds	r0, r3, #0
 8001954:	f7ff fb24 	bl	8000fa0 <stStartAlarm>
}
 8001958:	b003      	add	sp, #12
 800195a:	bd00      	pop	{pc}
 800195c:	46c0      	nop			; (mov r8, r8)
 800195e:	46c0      	nop			; (mov r8, r8)

08001960 <port_timer_stop_alarm.4393.4407>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8001960:	b508      	push	{r3, lr}

  stStopAlarm();
 8001962:	f7ff fb2d 	bl	8000fc0 <stStopAlarm>
}
 8001966:	bd08      	pop	{r3, pc}
 8001968:	46c0      	nop			; (mov r8, r8)
 800196a:	46c0      	nop			; (mov r8, r8)
 800196c:	46c0      	nop			; (mov r8, r8)
 800196e:	46c0      	nop			; (mov r8, r8)

08001970 <port_timer_set_alarm.4390.4404>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8001970:	b500      	push	{lr}
 8001972:	b083      	sub	sp, #12
 8001974:	1c02      	adds	r2, r0, #0
 8001976:	466b      	mov	r3, sp
 8001978:	3306      	adds	r3, #6
 800197a:	801a      	strh	r2, [r3, #0]

  stSetAlarm(time);
 800197c:	466b      	mov	r3, sp
 800197e:	3306      	adds	r3, #6
 8001980:	881b      	ldrh	r3, [r3, #0]
 8001982:	1c18      	adds	r0, r3, #0
 8001984:	f7ff fb24 	bl	8000fd0 <stSetAlarm>
}
 8001988:	b003      	add	sp, #12
 800198a:	bd00      	pop	{pc}
 800198c:	46c0      	nop			; (mov r8, r8)
 800198e:	46c0      	nop			; (mov r8, r8)

08001990 <port_timer_get_time.4383.4402>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8001990:	b508      	push	{r3, lr}

  return stGetCounter();
 8001992:	f7ff ffcd 	bl	8001930 <st_lld_get_counter.4377.4412>
 8001996:	1c03      	adds	r3, r0, #0
}
 8001998:	1c18      	adds	r0, r3, #0
 800199a:	bd08      	pop	{r3, pc}
 800199c:	46c0      	nop			; (mov r8, r8)
 800199e:	46c0      	nop			; (mov r8, r8)

080019a0 <chVTGetSystemTimeX.4385.4400>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80019a0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80019a2:	f7ff fff5 	bl	8001990 <port_timer_get_time.4383.4402>
 80019a6:	1c03      	adds	r3, r0, #0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80019a8:	1c18      	adds	r0, r3, #0
 80019aa:	bd08      	pop	{r3, pc}
 80019ac:	46c0      	nop			; (mov r8, r8)
 80019ae:	46c0      	nop			; (mov r8, r8)

080019b0 <_vt_init.4398>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80019b0:	4b06      	ldr	r3, [pc, #24]	; (80019cc <_vt_init.4398+0x1c>)
 80019b2:	4a07      	ldr	r2, [pc, #28]	; (80019d0 <_vt_init.4398+0x20>)
 80019b4:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 80019b6:	4b05      	ldr	r3, [pc, #20]	; (80019cc <_vt_init.4398+0x1c>)
 80019b8:	4a05      	ldr	r2, [pc, #20]	; (80019d0 <_vt_init.4398+0x20>)
 80019ba:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 80019bc:	4b03      	ldr	r3, [pc, #12]	; (80019cc <_vt_init.4398+0x1c>)
 80019be:	2201      	movs	r2, #1
 80019c0:	4252      	negs	r2, r2
 80019c2:	849a      	strh	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 80019c4:	4b01      	ldr	r3, [pc, #4]	; (80019cc <_vt_init.4398+0x1c>)
 80019c6:	2200      	movs	r2, #0
 80019c8:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80019ca:	4770      	bx	lr
 80019cc:	20000300 	.word	0x20000300
 80019d0:	2000031c 	.word	0x2000031c
 80019d4:	46c0      	nop			; (mov r8, r8)
 80019d6:	46c0      	nop			; (mov r8, r8)
 80019d8:	46c0      	nop			; (mov r8, r8)
 80019da:	46c0      	nop			; (mov r8, r8)
 80019dc:	46c0      	nop			; (mov r8, r8)
 80019de:	46c0      	nop			; (mov r8, r8)

080019e0 <chVTDoSetI.4392>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80019e0:	b510      	push	{r4, lr}
 80019e2:	b086      	sub	sp, #24
 80019e4:	9003      	str	r0, [sp, #12]
 80019e6:	9201      	str	r2, [sp, #4]
 80019e8:	9300      	str	r3, [sp, #0]
 80019ea:	466b      	mov	r3, sp
 80019ec:	330a      	adds	r3, #10
 80019ee:	1c0a      	adds	r2, r1, #0
 80019f0:	801a      	strh	r2, [r3, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80019f2:	9b03      	ldr	r3, [sp, #12]
 80019f4:	9a00      	ldr	r2, [sp, #0]
 80019f6:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 80019f8:	9b03      	ldr	r3, [sp, #12]
 80019fa:	9a01      	ldr	r2, [sp, #4]
 80019fc:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 80019fe:	ac04      	add	r4, sp, #16
 8001a00:	f7ff ffce 	bl	80019a0 <chVTGetSystemTimeX.4385.4400>
 8001a04:	1c03      	adds	r3, r0, #0
 8001a06:	8023      	strh	r3, [r4, #0]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8001a08:	466b      	mov	r3, sp
 8001a0a:	330a      	adds	r3, #10
 8001a0c:	881b      	ldrh	r3, [r3, #0]
 8001a0e:	2b04      	cmp	r3, #4
 8001a10:	d803      	bhi.n	8001a1a <chVTDoSetI.4392+0x3a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001a12:	466b      	mov	r3, sp
 8001a14:	330a      	adds	r3, #10
 8001a16:	2205      	movs	r2, #5
 8001a18:	801a      	strh	r2, [r3, #0]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001a1a:	4b3f      	ldr	r3, [pc, #252]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001a1c:	69da      	ldr	r2, [r3, #28]
 8001a1e:	4b3f      	ldr	r3, [pc, #252]	; (8001b1c <chVTDoSetI.4392+0x13c>)
 8001a20:	429a      	cmp	r2, r3
 8001a22:	d11f      	bne.n	8001a64 <chVTDoSetI.4392+0x84>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8001a24:	4b3c      	ldr	r3, [pc, #240]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001a26:	aa04      	add	r2, sp, #16
 8001a28:	8812      	ldrh	r2, [r2, #0]
 8001a2a:	84da      	strh	r2, [r3, #38]	; 0x26
      ch.vtlist.vt_next = vtp;
 8001a2c:	4b3a      	ldr	r3, [pc, #232]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001a2e:	9a03      	ldr	r2, [sp, #12]
 8001a30:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
 8001a32:	4b39      	ldr	r3, [pc, #228]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001a34:	9a03      	ldr	r2, [sp, #12]
 8001a36:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8001a38:	9b03      	ldr	r3, [sp, #12]
 8001a3a:	4a38      	ldr	r2, [pc, #224]	; (8001b1c <chVTDoSetI.4392+0x13c>)
 8001a3c:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001a3e:	9b03      	ldr	r3, [sp, #12]
 8001a40:	4a36      	ldr	r2, [pc, #216]	; (8001b1c <chVTDoSetI.4392+0x13c>)
 8001a42:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 8001a44:	9b03      	ldr	r3, [sp, #12]
 8001a46:	466a      	mov	r2, sp
 8001a48:	320a      	adds	r2, #10
 8001a4a:	8812      	ldrh	r2, [r2, #0]
 8001a4c:	811a      	strh	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8001a4e:	4b32      	ldr	r3, [pc, #200]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001a50:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001a52:	466b      	mov	r3, sp
 8001a54:	330a      	adds	r3, #10
 8001a56:	881b      	ldrh	r3, [r3, #0]
 8001a58:	18d3      	adds	r3, r2, r3
 8001a5a:	b29b      	uxth	r3, r3
 8001a5c:	1c18      	adds	r0, r3, #0
 8001a5e:	f7ff ff6f 	bl	8001940 <port_timer_start_alarm.4387.4409>
 8001a62:	e056      	b.n	8001b12 <chVTDoSetI.4392+0x132>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001a64:	aa04      	add	r2, sp, #16
 8001a66:	466b      	mov	r3, sp
 8001a68:	330a      	adds	r3, #10
 8001a6a:	8812      	ldrh	r2, [r2, #0]
 8001a6c:	881b      	ldrh	r3, [r3, #0]
 8001a6e:	18d3      	adds	r3, r2, r3
 8001a70:	b299      	uxth	r1, r3
 8001a72:	4b29      	ldr	r3, [pc, #164]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001a74:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001a76:	466b      	mov	r3, sp
 8001a78:	3312      	adds	r3, #18
 8001a7a:	1a8a      	subs	r2, r1, r2
 8001a7c:	801a      	strh	r2, [r3, #0]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001a7e:	4b26      	ldr	r3, [pc, #152]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001a80:	69db      	ldr	r3, [r3, #28]
 8001a82:	891b      	ldrh	r3, [r3, #8]
 8001a84:	466a      	mov	r2, sp
 8001a86:	3212      	adds	r2, #18
 8001a88:	8812      	ldrh	r2, [r2, #0]
 8001a8a:	429a      	cmp	r2, r3
 8001a8c:	d209      	bcs.n	8001aa2 <chVTDoSetI.4392+0xc2>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 8001a8e:	4b22      	ldr	r3, [pc, #136]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001a90:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001a92:	466b      	mov	r3, sp
 8001a94:	3312      	adds	r3, #18
 8001a96:	881b      	ldrh	r3, [r3, #0]
 8001a98:	18d3      	adds	r3, r2, r3
 8001a9a:	b29b      	uxth	r3, r3
 8001a9c:	1c18      	adds	r0, r3, #0
 8001a9e:	f7ff ff67 	bl	8001970 <port_timer_set_alarm.4390.4404>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8001aa2:	4b1d      	ldr	r3, [pc, #116]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001aa4:	69db      	ldr	r3, [r3, #28]
 8001aa6:	9305      	str	r3, [sp, #20]
 8001aa8:	e00b      	b.n	8001ac2 <chVTDoSetI.4392+0xe2>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8001aaa:	9b05      	ldr	r3, [sp, #20]
 8001aac:	891a      	ldrh	r2, [r3, #8]
 8001aae:	466b      	mov	r3, sp
 8001ab0:	3312      	adds	r3, #18
 8001ab2:	4669      	mov	r1, sp
 8001ab4:	3112      	adds	r1, #18
 8001ab6:	8809      	ldrh	r1, [r1, #0]
 8001ab8:	1a8a      	subs	r2, r1, r2
 8001aba:	801a      	strh	r2, [r3, #0]
    p = p->vt_next;
 8001abc:	9b05      	ldr	r3, [sp, #20]
 8001abe:	681b      	ldr	r3, [r3, #0]
 8001ac0:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8001ac2:	9b05      	ldr	r3, [sp, #20]
 8001ac4:	891b      	ldrh	r3, [r3, #8]
 8001ac6:	466a      	mov	r2, sp
 8001ac8:	3212      	adds	r2, #18
 8001aca:	8812      	ldrh	r2, [r2, #0]
 8001acc:	429a      	cmp	r2, r3
 8001ace:	d8ec      	bhi.n	8001aaa <chVTDoSetI.4392+0xca>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8001ad0:	9b03      	ldr	r3, [sp, #12]
 8001ad2:	9a05      	ldr	r2, [sp, #20]
 8001ad4:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001ad6:	9b03      	ldr	r3, [sp, #12]
 8001ad8:	681b      	ldr	r3, [r3, #0]
 8001ada:	685a      	ldr	r2, [r3, #4]
 8001adc:	9b03      	ldr	r3, [sp, #12]
 8001ade:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 8001ae0:	9b03      	ldr	r3, [sp, #12]
 8001ae2:	685b      	ldr	r3, [r3, #4]
 8001ae4:	9a03      	ldr	r2, [sp, #12]
 8001ae6:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 8001ae8:	9b05      	ldr	r3, [sp, #20]
 8001aea:	9a03      	ldr	r2, [sp, #12]
 8001aec:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 8001aee:	9b03      	ldr	r3, [sp, #12]
 8001af0:	466a      	mov	r2, sp
 8001af2:	3212      	adds	r2, #18
 8001af4:	8812      	ldrh	r2, [r2, #0]
 8001af6:	811a      	strh	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001af8:	9b05      	ldr	r3, [sp, #20]
 8001afa:	891a      	ldrh	r2, [r3, #8]
 8001afc:	466b      	mov	r3, sp
 8001afe:	3312      	adds	r3, #18
 8001b00:	881b      	ldrh	r3, [r3, #0]
 8001b02:	1ad3      	subs	r3, r2, r3
 8001b04:	b29a      	uxth	r2, r3
 8001b06:	9b05      	ldr	r3, [sp, #20]
 8001b08:	811a      	strh	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001b0a:	4b03      	ldr	r3, [pc, #12]	; (8001b18 <chVTDoSetI.4392+0x138>)
 8001b0c:	2201      	movs	r2, #1
 8001b0e:	4252      	negs	r2, r2
 8001b10:	849a      	strh	r2, [r3, #36]	; 0x24
}
 8001b12:	b006      	add	sp, #24
 8001b14:	bd10      	pop	{r4, pc}
 8001b16:	46c0      	nop			; (mov r8, r8)
 8001b18:	20000300 	.word	0x20000300
 8001b1c:	2000031c 	.word	0x2000031c

08001b20 <chVTDoResetI.4388>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001b20:	b500      	push	{lr}
 8001b22:	b085      	sub	sp, #20
 8001b24:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8001b26:	4b38      	ldr	r3, [pc, #224]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001b28:	69da      	ldr	r2, [r3, #28]
 8001b2a:	9b01      	ldr	r3, [sp, #4]
 8001b2c:	429a      	cmp	r2, r3
 8001b2e:	d01c      	beq.n	8001b6a <chVTDoResetI.4388+0x4a>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8001b30:	9b01      	ldr	r3, [sp, #4]
 8001b32:	685b      	ldr	r3, [r3, #4]
 8001b34:	9a01      	ldr	r2, [sp, #4]
 8001b36:	6812      	ldr	r2, [r2, #0]
 8001b38:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8001b3a:	9b01      	ldr	r3, [sp, #4]
 8001b3c:	681b      	ldr	r3, [r3, #0]
 8001b3e:	9a01      	ldr	r2, [sp, #4]
 8001b40:	6852      	ldr	r2, [r2, #4]
 8001b42:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8001b44:	9b01      	ldr	r3, [sp, #4]
 8001b46:	2200      	movs	r2, #0
 8001b48:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8001b4a:	9b01      	ldr	r3, [sp, #4]
 8001b4c:	681a      	ldr	r2, [r3, #0]
 8001b4e:	4b2f      	ldr	r3, [pc, #188]	; (8001c0c <chVTDoResetI.4388+0xec>)
 8001b50:	429a      	cmp	r2, r3
 8001b52:	d057      	beq.n	8001c04 <chVTDoResetI.4388+0xe4>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8001b54:	9b01      	ldr	r3, [sp, #4]
 8001b56:	681a      	ldr	r2, [r3, #0]
 8001b58:	9b01      	ldr	r3, [sp, #4]
 8001b5a:	681b      	ldr	r3, [r3, #0]
 8001b5c:	8919      	ldrh	r1, [r3, #8]
 8001b5e:	9b01      	ldr	r3, [sp, #4]
 8001b60:	891b      	ldrh	r3, [r3, #8]
 8001b62:	18cb      	adds	r3, r1, r3
 8001b64:	b29b      	uxth	r3, r3
 8001b66:	8113      	strh	r3, [r2, #8]
 8001b68:	e04c      	b.n	8001c04 <chVTDoResetI.4388+0xe4>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8001b6a:	9b01      	ldr	r3, [sp, #4]
 8001b6c:	681a      	ldr	r2, [r3, #0]
 8001b6e:	4b26      	ldr	r3, [pc, #152]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001b70:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001b72:	4b25      	ldr	r3, [pc, #148]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001b74:	69db      	ldr	r3, [r3, #28]
 8001b76:	4a25      	ldr	r2, [pc, #148]	; (8001c0c <chVTDoResetI.4388+0xec>)
 8001b78:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8001b7a:	9b01      	ldr	r3, [sp, #4]
 8001b7c:	2200      	movs	r2, #0
 8001b7e:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001b80:	4b21      	ldr	r3, [pc, #132]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001b82:	69da      	ldr	r2, [r3, #28]
 8001b84:	4b21      	ldr	r3, [pc, #132]	; (8001c0c <chVTDoResetI.4388+0xec>)
 8001b86:	429a      	cmp	r2, r3
 8001b88:	d102      	bne.n	8001b90 <chVTDoResetI.4388+0x70>
    port_timer_stop_alarm();
 8001b8a:	f7ff fee9 	bl	8001960 <port_timer_stop_alarm.4393.4407>
 8001b8e:	e039      	b.n	8001c04 <chVTDoResetI.4388+0xe4>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8001b90:	4b1d      	ldr	r3, [pc, #116]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001b92:	69da      	ldr	r2, [r3, #28]
 8001b94:	4b1c      	ldr	r3, [pc, #112]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001b96:	69db      	ldr	r3, [r3, #28]
 8001b98:	8919      	ldrh	r1, [r3, #8]
 8001b9a:	9b01      	ldr	r3, [sp, #4]
 8001b9c:	891b      	ldrh	r3, [r3, #8]
 8001b9e:	18cb      	adds	r3, r1, r3
 8001ba0:	b29b      	uxth	r3, r3
 8001ba2:	8113      	strh	r3, [r2, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8001ba4:	f7ff fefc 	bl	80019a0 <chVTGetSystemTimeX.4385.4400>
 8001ba8:	1c03      	adds	r3, r0, #0
 8001baa:	1c19      	adds	r1, r3, #0
 8001bac:	4b16      	ldr	r3, [pc, #88]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001bae:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001bb0:	ab03      	add	r3, sp, #12
 8001bb2:	1a8a      	subs	r2, r1, r2
 8001bb4:	801a      	strh	r2, [r3, #0]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8001bb6:	4b14      	ldr	r3, [pc, #80]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001bb8:	69db      	ldr	r3, [r3, #28]
 8001bba:	891b      	ldrh	r3, [r3, #8]
 8001bbc:	aa03      	add	r2, sp, #12
 8001bbe:	8812      	ldrh	r2, [r2, #0]
 8001bc0:	429a      	cmp	r2, r3
 8001bc2:	d21f      	bcs.n	8001c04 <chVTDoResetI.4388+0xe4>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8001bc4:	4b10      	ldr	r3, [pc, #64]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001bc6:	69db      	ldr	r3, [r3, #28]
 8001bc8:	8919      	ldrh	r1, [r3, #8]
 8001bca:	466b      	mov	r3, sp
 8001bcc:	330e      	adds	r3, #14
 8001bce:	aa03      	add	r2, sp, #12
 8001bd0:	8812      	ldrh	r2, [r2, #0]
 8001bd2:	1a8a      	subs	r2, r1, r2
 8001bd4:	801a      	strh	r2, [r3, #0]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8001bd6:	466b      	mov	r3, sp
 8001bd8:	330e      	adds	r3, #14
 8001bda:	881b      	ldrh	r3, [r3, #0]
 8001bdc:	2b04      	cmp	r3, #4
 8001bde:	d803      	bhi.n	8001be8 <chVTDoResetI.4388+0xc8>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001be0:	466b      	mov	r3, sp
 8001be2:	330e      	adds	r3, #14
 8001be4:	2205      	movs	r2, #5
 8001be6:	801a      	strh	r2, [r3, #0]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8001be8:	4b07      	ldr	r3, [pc, #28]	; (8001c08 <chVTDoResetI.4388+0xe8>)
 8001bea:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8001bec:	ab03      	add	r3, sp, #12
 8001bee:	881b      	ldrh	r3, [r3, #0]
 8001bf0:	18d3      	adds	r3, r2, r3
 8001bf2:	b29a      	uxth	r2, r3
 8001bf4:	466b      	mov	r3, sp
 8001bf6:	330e      	adds	r3, #14
 8001bf8:	881b      	ldrh	r3, [r3, #0]
 8001bfa:	18d3      	adds	r3, r2, r3
 8001bfc:	b29b      	uxth	r3, r3
 8001bfe:	1c18      	adds	r0, r3, #0
 8001c00:	f7ff feb6 	bl	8001970 <port_timer_set_alarm.4390.4404>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001c04:	b005      	add	sp, #20
 8001c06:	bd00      	pop	{pc}
 8001c08:	20000300 	.word	0x20000300
 8001c0c:	2000031c 	.word	0x2000031c

08001c10 <port_lock.4537.4386>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c10:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001c12:	4770      	bx	lr
 8001c14:	46c0      	nop			; (mov r8, r8)
 8001c16:	46c0      	nop			; (mov r8, r8)
 8001c18:	46c0      	nop			; (mov r8, r8)
 8001c1a:	46c0      	nop			; (mov r8, r8)
 8001c1c:	46c0      	nop			; (mov r8, r8)
 8001c1e:	46c0      	nop			; (mov r8, r8)

08001c20 <port_unlock.4540.4384>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c20:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001c22:	4770      	bx	lr
 8001c24:	46c0      	nop			; (mov r8, r8)
 8001c26:	46c0      	nop			; (mov r8, r8)
 8001c28:	46c0      	nop			; (mov r8, r8)
 8001c2a:	46c0      	nop			; (mov r8, r8)
 8001c2c:	46c0      	nop			; (mov r8, r8)
 8001c2e:	46c0      	nop			; (mov r8, r8)

08001c30 <port_lock_from_isr.4542.4382>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001c30:	b508      	push	{r3, lr}

  port_lock();
 8001c32:	f7ff ffed 	bl	8001c10 <port_lock.4537.4386>
}
 8001c36:	bd08      	pop	{r3, pc}
 8001c38:	46c0      	nop			; (mov r8, r8)
 8001c3a:	46c0      	nop			; (mov r8, r8)
 8001c3c:	46c0      	nop			; (mov r8, r8)
 8001c3e:	46c0      	nop			; (mov r8, r8)

08001c40 <port_unlock_from_isr.4544.4380>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001c40:	b508      	push	{r3, lr}

  port_unlock();
 8001c42:	f7ff ffed 	bl	8001c20 <port_unlock.4540.4384>
}
 8001c46:	bd08      	pop	{r3, pc}
 8001c48:	46c0      	nop			; (mov r8, r8)
 8001c4a:	46c0      	nop			; (mov r8, r8)
 8001c4c:	46c0      	nop			; (mov r8, r8)
 8001c4e:	46c0      	nop			; (mov r8, r8)

08001c50 <queue_init.4546.4377>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001c50:	b082      	sub	sp, #8
 8001c52:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001c54:	9b01      	ldr	r3, [sp, #4]
 8001c56:	9a01      	ldr	r2, [sp, #4]
 8001c58:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001c5a:	9b01      	ldr	r3, [sp, #4]
 8001c5c:	9a01      	ldr	r2, [sp, #4]
 8001c5e:	605a      	str	r2, [r3, #4]
}
 8001c60:	b002      	add	sp, #8
 8001c62:	4770      	bx	lr
 8001c64:	46c0      	nop			; (mov r8, r8)
 8001c66:	46c0      	nop			; (mov r8, r8)
 8001c68:	46c0      	nop			; (mov r8, r8)
 8001c6a:	46c0      	nop			; (mov r8, r8)
 8001c6c:	46c0      	nop			; (mov r8, r8)
 8001c6e:	46c0      	nop			; (mov r8, r8)

08001c70 <chSysLockFromISR.4615.4373>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001c70:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001c72:	f7ff ffdd 	bl	8001c30 <port_lock_from_isr.4542.4382>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001c76:	bd08      	pop	{r3, pc}
 8001c78:	46c0      	nop			; (mov r8, r8)
 8001c7a:	46c0      	nop			; (mov r8, r8)
 8001c7c:	46c0      	nop			; (mov r8, r8)
 8001c7e:	46c0      	nop			; (mov r8, r8)

08001c80 <chSysUnlockFromISR.4617.4371>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001c80:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001c82:	f7ff ffdd 	bl	8001c40 <port_unlock_from_isr.4544.4380>
}
 8001c86:	bd08      	pop	{r3, pc}
 8001c88:	46c0      	nop			; (mov r8, r8)
 8001c8a:	46c0      	nop			; (mov r8, r8)
 8001c8c:	46c0      	nop			; (mov r8, r8)
 8001c8e:	46c0      	nop			; (mov r8, r8)

08001c90 <chVTIsArmedI.4619.4360>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8001c90:	b082      	sub	sp, #8
 8001c92:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8001c94:	9b01      	ldr	r3, [sp, #4]
 8001c96:	68db      	ldr	r3, [r3, #12]
 8001c98:	1e5a      	subs	r2, r3, #1
 8001c9a:	4193      	sbcs	r3, r2
 8001c9c:	b2db      	uxtb	r3, r3
}
 8001c9e:	1c18      	adds	r0, r3, #0
 8001ca0:	b002      	add	sp, #8
 8001ca2:	4770      	bx	lr
 8001ca4:	46c0      	nop			; (mov r8, r8)
 8001ca6:	46c0      	nop			; (mov r8, r8)
 8001ca8:	46c0      	nop			; (mov r8, r8)
 8001caa:	46c0      	nop			; (mov r8, r8)
 8001cac:	46c0      	nop			; (mov r8, r8)
 8001cae:	46c0      	nop			; (mov r8, r8)

08001cb0 <chSemFastSignalI.4633.4357>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8001cb0:	b082      	sub	sp, #8
 8001cb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8001cb4:	9b01      	ldr	r3, [sp, #4]
 8001cb6:	689b      	ldr	r3, [r3, #8]
 8001cb8:	1c5a      	adds	r2, r3, #1
 8001cba:	9b01      	ldr	r3, [sp, #4]
 8001cbc:	609a      	str	r2, [r3, #8]
}
 8001cbe:	b002      	add	sp, #8
 8001cc0:	4770      	bx	lr
 8001cc2:	46c0      	nop			; (mov r8, r8)
 8001cc4:	46c0      	nop			; (mov r8, r8)
 8001cc6:	46c0      	nop			; (mov r8, r8)
 8001cc8:	46c0      	nop			; (mov r8, r8)
 8001cca:	46c0      	nop			; (mov r8, r8)
 8001ccc:	46c0      	nop			; (mov r8, r8)
 8001cce:	46c0      	nop			; (mov r8, r8)

08001cd0 <_scheduler_init.4355>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8001cd0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8001cd2:	4b07      	ldr	r3, [pc, #28]	; (8001cf0 <_scheduler_init.4355+0x20>)
 8001cd4:	1c18      	adds	r0, r3, #0
 8001cd6:	f7ff ffbb 	bl	8001c50 <queue_init.4546.4377>
  ch.rlist.r_prio = NOPRIO;
 8001cda:	4b05      	ldr	r3, [pc, #20]	; (8001cf0 <_scheduler_init.4355+0x20>)
 8001cdc:	2200      	movs	r2, #0
 8001cde:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8001ce0:	4b03      	ldr	r3, [pc, #12]	; (8001cf0 <_scheduler_init.4355+0x20>)
 8001ce2:	4a03      	ldr	r2, [pc, #12]	; (8001cf0 <_scheduler_init.4355+0x20>)
 8001ce4:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8001ce6:	4b02      	ldr	r3, [pc, #8]	; (8001cf0 <_scheduler_init.4355+0x20>)
 8001ce8:	4a01      	ldr	r2, [pc, #4]	; (8001cf0 <_scheduler_init.4355+0x20>)
 8001cea:	615a      	str	r2, [r3, #20]
#endif
}
 8001cec:	bd08      	pop	{r3, pc}
 8001cee:	46c0      	nop			; (mov r8, r8)
 8001cf0:	20000300 	.word	0x20000300
 8001cf4:	46c0      	nop			; (mov r8, r8)
 8001cf6:	46c0      	nop			; (mov r8, r8)
 8001cf8:	46c0      	nop			; (mov r8, r8)
 8001cfa:	46c0      	nop			; (mov r8, r8)
 8001cfc:	46c0      	nop			; (mov r8, r8)
 8001cfe:	46c0      	nop			; (mov r8, r8)

08001d00 <queue_insert.4347>:
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8001d00:	b082      	sub	sp, #8
 8001d02:	9001      	str	r0, [sp, #4]
 8001d04:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8001d06:	9b01      	ldr	r3, [sp, #4]
 8001d08:	9a00      	ldr	r2, [sp, #0]
 8001d0a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8001d0c:	9b00      	ldr	r3, [sp, #0]
 8001d0e:	685a      	ldr	r2, [r3, #4]
 8001d10:	9b01      	ldr	r3, [sp, #4]
 8001d12:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001d14:	9b01      	ldr	r3, [sp, #4]
 8001d16:	685b      	ldr	r3, [r3, #4]
 8001d18:	9a01      	ldr	r2, [sp, #4]
 8001d1a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8001d1c:	9b00      	ldr	r3, [sp, #0]
 8001d1e:	9a01      	ldr	r2, [sp, #4]
 8001d20:	605a      	str	r2, [r3, #4]
}
 8001d22:	b002      	add	sp, #8
 8001d24:	4770      	bx	lr
 8001d26:	46c0      	nop			; (mov r8, r8)
 8001d28:	46c0      	nop			; (mov r8, r8)
 8001d2a:	46c0      	nop			; (mov r8, r8)
 8001d2c:	46c0      	nop			; (mov r8, r8)
 8001d2e:	46c0      	nop			; (mov r8, r8)

08001d30 <queue_fifo_remove>:
 * @param[in] tqp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001d30:	b084      	sub	sp, #16
 8001d32:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001d34:	9b01      	ldr	r3, [sp, #4]
 8001d36:	681b      	ldr	r3, [r3, #0]
 8001d38:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001d3a:	9b03      	ldr	r3, [sp, #12]
 8001d3c:	681a      	ldr	r2, [r3, #0]
 8001d3e:	9b01      	ldr	r3, [sp, #4]
 8001d40:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001d42:	9b01      	ldr	r3, [sp, #4]
 8001d44:	681b      	ldr	r3, [r3, #0]
 8001d46:	9a01      	ldr	r2, [sp, #4]
 8001d48:	605a      	str	r2, [r3, #4]

  return tp;
 8001d4a:	9b03      	ldr	r3, [sp, #12]
}
 8001d4c:	1c18      	adds	r0, r3, #0
 8001d4e:	b004      	add	sp, #16
 8001d50:	4770      	bx	lr
 8001d52:	46c0      	nop			; (mov r8, r8)
 8001d54:	46c0      	nop			; (mov r8, r8)
 8001d56:	46c0      	nop			; (mov r8, r8)
 8001d58:	46c0      	nop			; (mov r8, r8)
 8001d5a:	46c0      	nop			; (mov r8, r8)
 8001d5c:	46c0      	nop			; (mov r8, r8)
 8001d5e:	46c0      	nop			; (mov r8, r8)

08001d60 <queue_dequeue>:
 * @param[in] tp        the pointer to the thread to be removed from the queue
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_dequeue(thread_t *tp) {
 8001d60:	b082      	sub	sp, #8
 8001d62:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8001d64:	9b01      	ldr	r3, [sp, #4]
 8001d66:	685b      	ldr	r3, [r3, #4]
 8001d68:	9a01      	ldr	r2, [sp, #4]
 8001d6a:	6812      	ldr	r2, [r2, #0]
 8001d6c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001d6e:	9b01      	ldr	r3, [sp, #4]
 8001d70:	681b      	ldr	r3, [r3, #0]
 8001d72:	9a01      	ldr	r2, [sp, #4]
 8001d74:	6852      	ldr	r2, [r2, #4]
 8001d76:	605a      	str	r2, [r3, #4]

  return tp;
 8001d78:	9b01      	ldr	r3, [sp, #4]
}
 8001d7a:	1c18      	adds	r0, r3, #0
 8001d7c:	b002      	add	sp, #8
 8001d7e:	4770      	bx	lr

08001d80 <list_remove.4331>:
 * @param[in] tlp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *list_remove(threads_list_t *tlp) {
 8001d80:	b084      	sub	sp, #16
 8001d82:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8001d84:	9b01      	ldr	r3, [sp, #4]
 8001d86:	681b      	ldr	r3, [r3, #0]
 8001d88:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8001d8a:	9b03      	ldr	r3, [sp, #12]
 8001d8c:	681a      	ldr	r2, [r3, #0]
 8001d8e:	9b01      	ldr	r3, [sp, #4]
 8001d90:	601a      	str	r2, [r3, #0]

  return tp;
 8001d92:	9b03      	ldr	r3, [sp, #12]
}
 8001d94:	1c18      	adds	r0, r3, #0
 8001d96:	b004      	add	sp, #16
 8001d98:	4770      	bx	lr
 8001d9a:	46c0      	nop			; (mov r8, r8)
 8001d9c:	46c0      	nop			; (mov r8, r8)
 8001d9e:	46c0      	nop			; (mov r8, r8)

08001da0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001da0:	b084      	sub	sp, #16
 8001da2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001da4:	9b01      	ldr	r3, [sp, #4]
 8001da6:	2200      	movs	r2, #0
 8001da8:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001daa:	4b0e      	ldr	r3, [pc, #56]	; (8001de4 <chSchReadyI+0x44>)
 8001dac:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8001dae:	9b03      	ldr	r3, [sp, #12]
 8001db0:	681b      	ldr	r3, [r3, #0]
 8001db2:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8001db4:	9b03      	ldr	r3, [sp, #12]
 8001db6:	689a      	ldr	r2, [r3, #8]
 8001db8:	9b01      	ldr	r3, [sp, #4]
 8001dba:	689b      	ldr	r3, [r3, #8]
 8001dbc:	429a      	cmp	r2, r3
 8001dbe:	d2f6      	bcs.n	8001dae <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001dc0:	9b01      	ldr	r3, [sp, #4]
 8001dc2:	9a03      	ldr	r2, [sp, #12]
 8001dc4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8001dc6:	9b03      	ldr	r3, [sp, #12]
 8001dc8:	685a      	ldr	r2, [r3, #4]
 8001dca:	9b01      	ldr	r3, [sp, #4]
 8001dcc:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001dce:	9b01      	ldr	r3, [sp, #4]
 8001dd0:	685b      	ldr	r3, [r3, #4]
 8001dd2:	9a01      	ldr	r2, [sp, #4]
 8001dd4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8001dd6:	9b03      	ldr	r3, [sp, #12]
 8001dd8:	9a01      	ldr	r2, [sp, #4]
 8001dda:	605a      	str	r2, [r3, #4]

  return tp;
 8001ddc:	9b01      	ldr	r3, [sp, #4]
}
 8001dde:	1c18      	adds	r0, r3, #0
 8001de0:	b004      	add	sp, #16
 8001de2:	4770      	bx	lr
 8001de4:	20000300 	.word	0x20000300
 8001de8:	46c0      	nop			; (mov r8, r8)
 8001dea:	46c0      	nop			; (mov r8, r8)
 8001dec:	46c0      	nop			; (mov r8, r8)
 8001dee:	46c0      	nop			; (mov r8, r8)

08001df0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8001df0:	b500      	push	{lr}
 8001df2:	b085      	sub	sp, #20
 8001df4:	1c02      	adds	r2, r0, #0
 8001df6:	466b      	mov	r3, sp
 8001df8:	3307      	adds	r3, #7
 8001dfa:	701a      	strb	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8001dfc:	4b0d      	ldr	r3, [pc, #52]	; (8001e34 <chSchGoSleepS+0x44>)
 8001dfe:	699b      	ldr	r3, [r3, #24]
 8001e00:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8001e02:	9b03      	ldr	r3, [sp, #12]
 8001e04:	466a      	mov	r2, sp
 8001e06:	3207      	adds	r2, #7
 8001e08:	7812      	ldrb	r2, [r2, #0]
 8001e0a:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001e0c:	4b09      	ldr	r3, [pc, #36]	; (8001e34 <chSchGoSleepS+0x44>)
 8001e0e:	1c18      	adds	r0, r3, #0
 8001e10:	f7ff ff8e 	bl	8001d30 <queue_fifo_remove>
 8001e14:	1c02      	adds	r2, r0, #0
 8001e16:	4b07      	ldr	r3, [pc, #28]	; (8001e34 <chSchGoSleepS+0x44>)
 8001e18:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001e1a:	4b06      	ldr	r3, [pc, #24]	; (8001e34 <chSchGoSleepS+0x44>)
 8001e1c:	699b      	ldr	r3, [r3, #24]
 8001e1e:	2201      	movs	r2, #1
 8001e20:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 8001e22:	4b04      	ldr	r3, [pc, #16]	; (8001e34 <chSchGoSleepS+0x44>)
 8001e24:	699a      	ldr	r2, [r3, #24]
 8001e26:	9b03      	ldr	r3, [sp, #12]
 8001e28:	1c10      	adds	r0, r2, #0
 8001e2a:	1c19      	adds	r1, r3, #0
 8001e2c:	f7fe f9b0 	bl	8000190 <_port_switch>
}
 8001e30:	b005      	add	sp, #20
 8001e32:	bd00      	pop	{pc}
 8001e34:	20000300 	.word	0x20000300
 8001e38:	46c0      	nop			; (mov r8, r8)
 8001e3a:	46c0      	nop			; (mov r8, r8)
 8001e3c:	46c0      	nop			; (mov r8, r8)
 8001e3e:	46c0      	nop			; (mov r8, r8)

08001e40 <wakeup.4666.4322>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8001e40:	b500      	push	{lr}
 8001e42:	b085      	sub	sp, #20
 8001e44:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8001e46:	9b01      	ldr	r3, [sp, #4]
 8001e48:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8001e4a:	f7ff ff11 	bl	8001c70 <chSysLockFromISR.4615.4373>
  switch (tp->p_state) {
 8001e4e:	9b03      	ldr	r3, [sp, #12]
 8001e50:	7f1b      	ldrb	r3, [r3, #28]
 8001e52:	2b07      	cmp	r3, #7
 8001e54:	d815      	bhi.n	8001e82 <wakeup.4666.4322+0x42>
 8001e56:	009a      	lsls	r2, r3, #2
 8001e58:	4b10      	ldr	r3, [pc, #64]	; (8001e9c <wakeup.4666.4322+0x5c>)
 8001e5a:	18d3      	adds	r3, r2, r3
 8001e5c:	681b      	ldr	r3, [r3, #0]
 8001e5e:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8001e60:	f7ff ff0e 	bl	8001c80 <chSysUnlockFromISR.4617.4371>
 8001e64:	e017      	b.n	8001e96 <wakeup.4666.4322+0x56>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8001e66:	9b03      	ldr	r3, [sp, #12]
 8001e68:	6a1b      	ldr	r3, [r3, #32]
 8001e6a:	2200      	movs	r2, #0
 8001e6c:	601a      	str	r2, [r3, #0]
 8001e6e:	e008      	b.n	8001e82 <wakeup.4666.4322+0x42>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8001e70:	9b03      	ldr	r3, [sp, #12]
 8001e72:	6a1b      	ldr	r3, [r3, #32]
 8001e74:	1c18      	adds	r0, r3, #0
 8001e76:	f7ff ff1b 	bl	8001cb0 <chSemFastSignalI.4633.4357>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8001e7a:	9b03      	ldr	r3, [sp, #12]
 8001e7c:	1c18      	adds	r0, r3, #0
 8001e7e:	f7ff ff6f 	bl	8001d60 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001e82:	9b03      	ldr	r3, [sp, #12]
 8001e84:	2201      	movs	r2, #1
 8001e86:	4252      	negs	r2, r2
 8001e88:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8001e8a:	9b03      	ldr	r3, [sp, #12]
 8001e8c:	1c18      	adds	r0, r3, #0
 8001e8e:	f7ff ff87 	bl	8001da0 <chSchReadyI>
  chSysUnlockFromISR();
 8001e92:	f7ff fef5 	bl	8001c80 <chSysUnlockFromISR.4617.4371>
}
 8001e96:	b005      	add	sp, #20
 8001e98:	bd00      	pop	{pc}
 8001e9a:	46c0      	nop			; (mov r8, r8)
 8001e9c:	080023f0 	.word	0x080023f0

08001ea0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001ea0:	b500      	push	{lr}
 8001ea2:	b089      	sub	sp, #36	; 0x24
 8001ea4:	1c0a      	adds	r2, r1, #0
 8001ea6:	466b      	mov	r3, sp
 8001ea8:	3307      	adds	r3, #7
 8001eaa:	1c01      	adds	r1, r0, #0
 8001eac:	7019      	strb	r1, [r3, #0]
 8001eae:	ab01      	add	r3, sp, #4
 8001eb0:	801a      	strh	r2, [r3, #0]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001eb2:	ab01      	add	r3, sp, #4
 8001eb4:	881a      	ldrh	r2, [r3, #0]
 8001eb6:	4b14      	ldr	r3, [pc, #80]	; (8001f08 <chSchGoSleepTimeoutS+0x68>)
 8001eb8:	429a      	cmp	r2, r3
 8001eba:	d019      	beq.n	8001ef0 <chSchGoSleepTimeoutS+0x50>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8001ebc:	4b13      	ldr	r3, [pc, #76]	; (8001f0c <chSchGoSleepTimeoutS+0x6c>)
 8001ebe:	699b      	ldr	r3, [r3, #24]
 8001ec0:	a803      	add	r0, sp, #12
 8001ec2:	aa01      	add	r2, sp, #4
 8001ec4:	8811      	ldrh	r1, [r2, #0]
 8001ec6:	4a12      	ldr	r2, [pc, #72]	; (8001f10 <chSchGoSleepTimeoutS+0x70>)
 8001ec8:	f7ff fd8a 	bl	80019e0 <chVTDoSetI.4392>
    chSchGoSleepS(newstate);
 8001ecc:	466b      	mov	r3, sp
 8001ece:	3307      	adds	r3, #7
 8001ed0:	781b      	ldrb	r3, [r3, #0]
 8001ed2:	1c18      	adds	r0, r3, #0
 8001ed4:	f7ff ff8c 	bl	8001df0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8001ed8:	ab03      	add	r3, sp, #12
 8001eda:	1c18      	adds	r0, r3, #0
 8001edc:	f7ff fed8 	bl	8001c90 <chVTIsArmedI.4619.4360>
 8001ee0:	1c03      	adds	r3, r0, #0
 8001ee2:	2b00      	cmp	r3, #0
 8001ee4:	d00a      	beq.n	8001efc <chSchGoSleepTimeoutS+0x5c>
      chVTDoResetI(&vt);
 8001ee6:	ab03      	add	r3, sp, #12
 8001ee8:	1c18      	adds	r0, r3, #0
 8001eea:	f7ff fe19 	bl	8001b20 <chVTDoResetI.4388>
 8001eee:	e005      	b.n	8001efc <chSchGoSleepTimeoutS+0x5c>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001ef0:	466b      	mov	r3, sp
 8001ef2:	3307      	adds	r3, #7
 8001ef4:	781b      	ldrb	r3, [r3, #0]
 8001ef6:	1c18      	adds	r0, r3, #0
 8001ef8:	f7ff ff7a 	bl	8001df0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8001efc:	4b03      	ldr	r3, [pc, #12]	; (8001f0c <chSchGoSleepTimeoutS+0x6c>)
 8001efe:	699b      	ldr	r3, [r3, #24]
 8001f00:	6a1b      	ldr	r3, [r3, #32]
}
 8001f02:	1c18      	adds	r0, r3, #0
 8001f04:	b009      	add	sp, #36	; 0x24
 8001f06:	bd00      	pop	{pc}
 8001f08:	0000ffff 	.word	0x0000ffff
 8001f0c:	20000300 	.word	0x20000300
 8001f10:	08001e41 	.word	0x08001e41
 8001f14:	46c0      	nop			; (mov r8, r8)
 8001f16:	46c0      	nop			; (mov r8, r8)
 8001f18:	46c0      	nop			; (mov r8, r8)
 8001f1a:	46c0      	nop			; (mov r8, r8)
 8001f1c:	46c0      	nop			; (mov r8, r8)
 8001f1e:	46c0      	nop			; (mov r8, r8)

08001f20 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001f20:	b500      	push	{lr}
 8001f22:	b085      	sub	sp, #20
 8001f24:	9001      	str	r0, [sp, #4]
 8001f26:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8001f28:	9b01      	ldr	r3, [sp, #4]
 8001f2a:	9a00      	ldr	r2, [sp, #0]
 8001f2c:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001f2e:	9b01      	ldr	r3, [sp, #4]
 8001f30:	689a      	ldr	r2, [r3, #8]
 8001f32:	4b0f      	ldr	r3, [pc, #60]	; (8001f70 <chSchWakeupS+0x50>)
 8001f34:	699b      	ldr	r3, [r3, #24]
 8001f36:	689b      	ldr	r3, [r3, #8]
 8001f38:	429a      	cmp	r2, r3
 8001f3a:	d804      	bhi.n	8001f46 <chSchWakeupS+0x26>
    (void) chSchReadyI(ntp);
 8001f3c:	9b01      	ldr	r3, [sp, #4]
 8001f3e:	1c18      	adds	r0, r3, #0
 8001f40:	f7ff ff2e 	bl	8001da0 <chSchReadyI>
 8001f44:	e012      	b.n	8001f6c <chSchWakeupS+0x4c>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8001f46:	4b0a      	ldr	r3, [pc, #40]	; (8001f70 <chSchWakeupS+0x50>)
 8001f48:	699b      	ldr	r3, [r3, #24]
 8001f4a:	1c18      	adds	r0, r3, #0
 8001f4c:	f7ff ff28 	bl	8001da0 <chSchReadyI>
 8001f50:	1c03      	adds	r3, r0, #0
 8001f52:	9303      	str	r3, [sp, #12]
    setcurrp(ntp);
 8001f54:	4b06      	ldr	r3, [pc, #24]	; (8001f70 <chSchWakeupS+0x50>)
 8001f56:	9a01      	ldr	r2, [sp, #4]
 8001f58:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001f5a:	9b01      	ldr	r3, [sp, #4]
 8001f5c:	2201      	movs	r2, #1
 8001f5e:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8001f60:	9a01      	ldr	r2, [sp, #4]
 8001f62:	9b03      	ldr	r3, [sp, #12]
 8001f64:	1c10      	adds	r0, r2, #0
 8001f66:	1c19      	adds	r1, r3, #0
 8001f68:	f7fe f912 	bl	8000190 <_port_switch>
  }
}
 8001f6c:	b005      	add	sp, #20
 8001f6e:	bd00      	pop	{pc}
 8001f70:	20000300 	.word	0x20000300
 8001f74:	46c0      	nop			; (mov r8, r8)
 8001f76:	46c0      	nop			; (mov r8, r8)
 8001f78:	46c0      	nop			; (mov r8, r8)
 8001f7a:	46c0      	nop			; (mov r8, r8)
 8001f7c:	46c0      	nop			; (mov r8, r8)
 8001f7e:	46c0      	nop			; (mov r8, r8)

08001f80 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8001f80:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001f82:	4b08      	ldr	r3, [pc, #32]	; (8001fa4 <chSchIsPreemptionRequired+0x24>)
 8001f84:	681b      	ldr	r3, [r3, #0]
 8001f86:	689b      	ldr	r3, [r3, #8]
 8001f88:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8001f8a:	4b06      	ldr	r3, [pc, #24]	; (8001fa4 <chSchIsPreemptionRequired+0x24>)
 8001f8c:	699b      	ldr	r3, [r3, #24]
 8001f8e:	689b      	ldr	r3, [r3, #8]
 8001f90:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001f92:	9b01      	ldr	r3, [sp, #4]
 8001f94:	9a00      	ldr	r2, [sp, #0]
 8001f96:	429a      	cmp	r2, r3
 8001f98:	419b      	sbcs	r3, r3
 8001f9a:	425b      	negs	r3, r3
 8001f9c:	b2db      	uxtb	r3, r3
#endif
}
 8001f9e:	1c18      	adds	r0, r3, #0
 8001fa0:	b002      	add	sp, #8
 8001fa2:	4770      	bx	lr
 8001fa4:	20000300 	.word	0x20000300
 8001fa8:	46c0      	nop			; (mov r8, r8)
 8001faa:	46c0      	nop			; (mov r8, r8)
 8001fac:	46c0      	nop			; (mov r8, r8)
 8001fae:	46c0      	nop			; (mov r8, r8)

08001fb0 <chSchDoRescheduleAhead.4306>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8001fb0:	b500      	push	{lr}
 8001fb2:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8001fb4:	4b19      	ldr	r3, [pc, #100]	; (800201c <chSchDoRescheduleAhead.4306+0x6c>)
 8001fb6:	699b      	ldr	r3, [r3, #24]
 8001fb8:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001fba:	4b18      	ldr	r3, [pc, #96]	; (800201c <chSchDoRescheduleAhead.4306+0x6c>)
 8001fbc:	1c18      	adds	r0, r3, #0
 8001fbe:	f7ff feb7 	bl	8001d30 <queue_fifo_remove>
 8001fc2:	1c02      	adds	r2, r0, #0
 8001fc4:	4b15      	ldr	r3, [pc, #84]	; (800201c <chSchDoRescheduleAhead.4306+0x6c>)
 8001fc6:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001fc8:	4b14      	ldr	r3, [pc, #80]	; (800201c <chSchDoRescheduleAhead.4306+0x6c>)
 8001fca:	699b      	ldr	r3, [r3, #24]
 8001fcc:	2201      	movs	r2, #1
 8001fce:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8001fd0:	9b00      	ldr	r3, [sp, #0]
 8001fd2:	2200      	movs	r2, #0
 8001fd4:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001fd6:	4b11      	ldr	r3, [pc, #68]	; (800201c <chSchDoRescheduleAhead.4306+0x6c>)
 8001fd8:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8001fda:	9b01      	ldr	r3, [sp, #4]
 8001fdc:	681b      	ldr	r3, [r3, #0]
 8001fde:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8001fe0:	9b01      	ldr	r3, [sp, #4]
 8001fe2:	689a      	ldr	r2, [r3, #8]
 8001fe4:	9b00      	ldr	r3, [sp, #0]
 8001fe6:	689b      	ldr	r3, [r3, #8]
 8001fe8:	429a      	cmp	r2, r3
 8001fea:	d8f6      	bhi.n	8001fda <chSchDoRescheduleAhead.4306+0x2a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001fec:	9b00      	ldr	r3, [sp, #0]
 8001fee:	9a01      	ldr	r2, [sp, #4]
 8001ff0:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8001ff2:	9b01      	ldr	r3, [sp, #4]
 8001ff4:	685a      	ldr	r2, [r3, #4]
 8001ff6:	9b00      	ldr	r3, [sp, #0]
 8001ff8:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8001ffa:	9b00      	ldr	r3, [sp, #0]
 8001ffc:	685b      	ldr	r3, [r3, #4]
 8001ffe:	9a00      	ldr	r2, [sp, #0]
 8002000:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8002002:	9b01      	ldr	r3, [sp, #4]
 8002004:	9a00      	ldr	r2, [sp, #0]
 8002006:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8002008:	4b04      	ldr	r3, [pc, #16]	; (800201c <chSchDoRescheduleAhead.4306+0x6c>)
 800200a:	699a      	ldr	r2, [r3, #24]
 800200c:	9b00      	ldr	r3, [sp, #0]
 800200e:	1c10      	adds	r0, r2, #0
 8002010:	1c19      	adds	r1, r3, #0
 8002012:	f7fe f8bd 	bl	8000190 <_port_switch>
}
 8002016:	b003      	add	sp, #12
 8002018:	bd00      	pop	{pc}
 800201a:	46c0      	nop			; (mov r8, r8)
 800201c:	20000300 	.word	0x20000300

08002020 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8002020:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8002022:	f7ff ffc5 	bl	8001fb0 <chSchDoRescheduleAhead.4306>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8002026:	bd08      	pop	{r3, pc}
 8002028:	46c0      	nop			; (mov r8, r8)
 800202a:	46c0      	nop			; (mov r8, r8)
 800202c:	46c0      	nop			; (mov r8, r8)
 800202e:	46c0      	nop			; (mov r8, r8)

08002030 <port_lock.4742.4302>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002030:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8002032:	4770      	bx	lr
 8002034:	46c0      	nop			; (mov r8, r8)
 8002036:	46c0      	nop			; (mov r8, r8)
 8002038:	46c0      	nop			; (mov r8, r8)
 800203a:	46c0      	nop			; (mov r8, r8)
 800203c:	46c0      	nop			; (mov r8, r8)
 800203e:	46c0      	nop			; (mov r8, r8)

08002040 <port_unlock.4745.4300>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002040:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8002042:	4770      	bx	lr
 8002044:	46c0      	nop			; (mov r8, r8)
 8002046:	46c0      	nop			; (mov r8, r8)
 8002048:	46c0      	nop			; (mov r8, r8)
 800204a:	46c0      	nop			; (mov r8, r8)
 800204c:	46c0      	nop			; (mov r8, r8)
 800204e:	46c0      	nop			; (mov r8, r8)

08002050 <list_init.4754.4293>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8002050:	b082      	sub	sp, #8
 8002052:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8002054:	9b01      	ldr	r3, [sp, #4]
 8002056:	9a01      	ldr	r2, [sp, #4]
 8002058:	601a      	str	r2, [r3, #0]
}
 800205a:	b002      	add	sp, #8
 800205c:	4770      	bx	lr
 800205e:	46c0      	nop			; (mov r8, r8)

08002060 <list_notempty.4820.4290>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8002060:	b082      	sub	sp, #8
 8002062:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8002064:	9b01      	ldr	r3, [sp, #4]
 8002066:	681a      	ldr	r2, [r3, #0]
 8002068:	9b01      	ldr	r3, [sp, #4]
 800206a:	1ad3      	subs	r3, r2, r3
 800206c:	1e5a      	subs	r2, r3, #1
 800206e:	4193      	sbcs	r3, r2
 8002070:	b2db      	uxtb	r3, r3
}
 8002072:	1c18      	adds	r0, r3, #0
 8002074:	b002      	add	sp, #8
 8002076:	4770      	bx	lr
 8002078:	46c0      	nop			; (mov r8, r8)
 800207a:	46c0      	nop			; (mov r8, r8)
 800207c:	46c0      	nop			; (mov r8, r8)
 800207e:	46c0      	nop			; (mov r8, r8)

08002080 <queue_notempty.4824.4287>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002080:	b082      	sub	sp, #8
 8002082:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002084:	9b01      	ldr	r3, [sp, #4]
 8002086:	681a      	ldr	r2, [r3, #0]
 8002088:	9b01      	ldr	r3, [sp, #4]
 800208a:	1ad3      	subs	r3, r2, r3
 800208c:	1e5a      	subs	r2, r3, #1
 800208e:	4193      	sbcs	r3, r2
 8002090:	b2db      	uxtb	r3, r3
}
 8002092:	1c18      	adds	r0, r3, #0
 8002094:	b002      	add	sp, #8
 8002096:	4770      	bx	lr
 8002098:	46c0      	nop			; (mov r8, r8)
 800209a:	46c0      	nop			; (mov r8, r8)
 800209c:	46c0      	nop			; (mov r8, r8)
 800209e:	46c0      	nop			; (mov r8, r8)

080020a0 <chSysLock.4829.4281>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 80020a0:	b508      	push	{r3, lr}

  port_lock();
 80020a2:	f7ff ffc5 	bl	8002030 <port_lock.4742.4302>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80020a6:	bd08      	pop	{r3, pc}
 80020a8:	46c0      	nop			; (mov r8, r8)
 80020aa:	46c0      	nop			; (mov r8, r8)
 80020ac:	46c0      	nop			; (mov r8, r8)
 80020ae:	46c0      	nop			; (mov r8, r8)

080020b0 <chSysUnlock.4831.4279>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80020b0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80020b2:	f7ff ffc5 	bl	8002040 <port_unlock.4745.4300>
}
 80020b6:	bd08      	pop	{r3, pc}
 80020b8:	46c0      	nop			; (mov r8, r8)
 80020ba:	46c0      	nop			; (mov r8, r8)
 80020bc:	46c0      	nop			; (mov r8, r8)
 80020be:	46c0      	nop			; (mov r8, r8)

080020c0 <chThdDoDequeueNextI.4850.4260>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80020c0:	b500      	push	{lr}
 80020c2:	b085      	sub	sp, #20
 80020c4:	9001      	str	r0, [sp, #4]
 80020c6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 80020c8:	9b01      	ldr	r3, [sp, #4]
 80020ca:	1c18      	adds	r0, r3, #0
 80020cc:	f7ff fe30 	bl	8001d30 <queue_fifo_remove>
 80020d0:	1c03      	adds	r3, r0, #0
 80020d2:	9303      	str	r3, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80020d4:	9b03      	ldr	r3, [sp, #12]
 80020d6:	9a00      	ldr	r2, [sp, #0]
 80020d8:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80020da:	9b03      	ldr	r3, [sp, #12]
 80020dc:	1c18      	adds	r0, r3, #0
 80020de:	f7ff fe5f 	bl	8001da0 <chSchReadyI>
}
 80020e2:	b005      	add	sp, #20
 80020e4:	bd00      	pop	{pc}
 80020e6:	46c0      	nop			; (mov r8, r8)
 80020e8:	46c0      	nop			; (mov r8, r8)
 80020ea:	46c0      	nop			; (mov r8, r8)
 80020ec:	46c0      	nop			; (mov r8, r8)
 80020ee:	46c0      	nop			; (mov r8, r8)

080020f0 <_thread_init.4256>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 80020f0:	b500      	push	{lr}
 80020f2:	b083      	sub	sp, #12
 80020f4:	9001      	str	r0, [sp, #4]
 80020f6:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 80020f8:	9b01      	ldr	r3, [sp, #4]
 80020fa:	9a00      	ldr	r2, [sp, #0]
 80020fc:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 80020fe:	9b01      	ldr	r3, [sp, #4]
 8002100:	2202      	movs	r2, #2
 8002102:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002104:	9b01      	ldr	r3, [sp, #4]
 8002106:	2200      	movs	r2, #0
 8002108:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800210a:	9b01      	ldr	r3, [sp, #4]
 800210c:	9a00      	ldr	r2, [sp, #0]
 800210e:	62da      	str	r2, [r3, #44]	; 0x2c
  tp->p_mtxlist = NULL;
 8002110:	9b01      	ldr	r3, [sp, #4]
 8002112:	2200      	movs	r2, #0
 8002114:	629a      	str	r2, [r3, #40]	; 0x28
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002116:	9b01      	ldr	r3, [sp, #4]
 8002118:	2200      	movs	r2, #0
 800211a:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800211c:	9b01      	ldr	r3, [sp, #4]
 800211e:	4a0b      	ldr	r2, [pc, #44]	; (800214c <_thread_init.4256+0x5c>)
 8002120:	611a      	str	r2, [r3, #16]
 8002122:	4b0a      	ldr	r3, [pc, #40]	; (800214c <_thread_init.4256+0x5c>)
 8002124:	695a      	ldr	r2, [r3, #20]
 8002126:	9b01      	ldr	r3, [sp, #4]
 8002128:	615a      	str	r2, [r3, #20]
 800212a:	9b01      	ldr	r3, [sp, #4]
 800212c:	695b      	ldr	r3, [r3, #20]
 800212e:	9a01      	ldr	r2, [sp, #4]
 8002130:	611a      	str	r2, [r3, #16]
 8002132:	4b06      	ldr	r3, [pc, #24]	; (800214c <_thread_init.4256+0x5c>)
 8002134:	9a01      	ldr	r2, [sp, #4]
 8002136:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8002138:	9b01      	ldr	r3, [sp, #4]
 800213a:	3324      	adds	r3, #36	; 0x24
 800213c:	1c18      	adds	r0, r3, #0
 800213e:	f7ff ff87 	bl	8002050 <list_init.4754.4293>
  chTMStartMeasurementX(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 8002142:	9b01      	ldr	r3, [sp, #4]
}
 8002144:	1c18      	adds	r0, r3, #0
 8002146:	b003      	add	sp, #12
 8002148:	bd00      	pop	{pc}
 800214a:	46c0      	nop			; (mov r8, r8)
 800214c:	20000300 	.word	0x20000300

08002150 <chThdCreateI.4248>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8002150:	b500      	push	{lr}
 8002152:	b087      	sub	sp, #28
 8002154:	9003      	str	r0, [sp, #12]
 8002156:	9102      	str	r1, [sp, #8]
 8002158:	9201      	str	r2, [sp, #4]
 800215a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800215c:	9b03      	ldr	r3, [sp, #12]
 800215e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002160:	9b02      	ldr	r3, [sp, #8]
 8002162:	3b24      	subs	r3, #36	; 0x24
 8002164:	9a03      	ldr	r2, [sp, #12]
 8002166:	18d2      	adds	r2, r2, r3
 8002168:	9b05      	ldr	r3, [sp, #20]
 800216a:	60da      	str	r2, [r3, #12]
 800216c:	9b05      	ldr	r3, [sp, #20]
 800216e:	68db      	ldr	r3, [r3, #12]
 8002170:	9a00      	ldr	r2, [sp, #0]
 8002172:	611a      	str	r2, [r3, #16]
 8002174:	9b05      	ldr	r3, [sp, #20]
 8002176:	68db      	ldr	r3, [r3, #12]
 8002178:	9a08      	ldr	r2, [sp, #32]
 800217a:	615a      	str	r2, [r3, #20]
 800217c:	9b05      	ldr	r3, [sp, #20]
 800217e:	68db      	ldr	r3, [r3, #12]
 8002180:	4a05      	ldr	r2, [pc, #20]	; (8002198 <chThdCreateI.4248+0x48>)
 8002182:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 8002184:	9a05      	ldr	r2, [sp, #20]
 8002186:	9b01      	ldr	r3, [sp, #4]
 8002188:	1c10      	adds	r0, r2, #0
 800218a:	1c19      	adds	r1, r3, #0
 800218c:	f7ff ffb0 	bl	80020f0 <_thread_init.4256>
 8002190:	1c03      	adds	r3, r0, #0
}
 8002192:	1c18      	adds	r0, r3, #0
 8002194:	b007      	add	sp, #28
 8002196:	bd00      	pop	{pc}
 8002198:	080001b1 	.word	0x080001b1
 800219c:	46c0      	nop			; (mov r8, r8)
 800219e:	46c0      	nop			; (mov r8, r8)

080021a0 <chThdCreateStatic.4239>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80021a0:	b510      	push	{r4, lr}
 80021a2:	b088      	sub	sp, #32
 80021a4:	9005      	str	r0, [sp, #20]
 80021a6:	9104      	str	r1, [sp, #16]
 80021a8:	9203      	str	r2, [sp, #12]
 80021aa:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80021ac:	f7ff ff78 	bl	80020a0 <chSysLock.4829.4281>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80021b0:	9805      	ldr	r0, [sp, #20]
 80021b2:	9904      	ldr	r1, [sp, #16]
 80021b4:	9a03      	ldr	r2, [sp, #12]
 80021b6:	9b02      	ldr	r3, [sp, #8]
 80021b8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80021ba:	9400      	str	r4, [sp, #0]
 80021bc:	f7ff ffc8 	bl	8002150 <chThdCreateI.4248>
 80021c0:	1c03      	adds	r3, r0, #0
 80021c2:	9307      	str	r3, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 80021c4:	9b07      	ldr	r3, [sp, #28]
 80021c6:	1c18      	adds	r0, r3, #0
 80021c8:	2100      	movs	r1, #0
 80021ca:	f7ff fea9 	bl	8001f20 <chSchWakeupS>
  chSysUnlock();
 80021ce:	f7ff ff6f 	bl	80020b0 <chSysUnlock.4831.4279>

  return tp;
 80021d2:	9b07      	ldr	r3, [sp, #28]
}
 80021d4:	1c18      	adds	r0, r3, #0
 80021d6:	b008      	add	sp, #32
 80021d8:	bd10      	pop	{r4, pc}
 80021da:	46c0      	nop			; (mov r8, r8)
 80021dc:	46c0      	nop			; (mov r8, r8)
 80021de:	46c0      	nop			; (mov r8, r8)

080021e0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80021e0:	b500      	push	{lr}
 80021e2:	b083      	sub	sp, #12
 80021e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80021e6:	f7ff ff5b 	bl	80020a0 <chSysLock.4829.4281>
  chThdExitS(msg);
 80021ea:	9b01      	ldr	r3, [sp, #4]
 80021ec:	1c18      	adds	r0, r3, #0
 80021ee:	f000 f807 	bl	8002200 <chThdExitS.4212>
  /* The thread never returns here.*/
}
 80021f2:	b003      	add	sp, #12
 80021f4:	bd00      	pop	{pc}
 80021f6:	46c0      	nop			; (mov r8, r8)
 80021f8:	46c0      	nop			; (mov r8, r8)
 80021fa:	46c0      	nop			; (mov r8, r8)
 80021fc:	46c0      	nop			; (mov r8, r8)
 80021fe:	46c0      	nop			; (mov r8, r8)

08002200 <chThdExitS.4212>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8002200:	b500      	push	{lr}
 8002202:	b085      	sub	sp, #20
 8002204:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8002206:	4b16      	ldr	r3, [pc, #88]	; (8002260 <chThdExitS.4212+0x60>)
 8002208:	699b      	ldr	r3, [r3, #24]
 800220a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 800220c:	9b03      	ldr	r3, [sp, #12]
 800220e:	9a01      	ldr	r2, [sp, #4]
 8002210:	621a      	str	r2, [r3, #32]
 8002212:	e008      	b.n	8002226 <chThdExitS.4212+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8002214:	9b03      	ldr	r3, [sp, #12]
 8002216:	3324      	adds	r3, #36	; 0x24
 8002218:	1c18      	adds	r0, r3, #0
 800221a:	f7ff fdb1 	bl	8001d80 <list_remove.4331>
 800221e:	1c03      	adds	r3, r0, #0
 8002220:	1c18      	adds	r0, r3, #0
 8002222:	f7ff fdbd 	bl	8001da0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8002226:	9b03      	ldr	r3, [sp, #12]
 8002228:	3324      	adds	r3, #36	; 0x24
 800222a:	1c18      	adds	r0, r3, #0
 800222c:	f7ff ff18 	bl	8002060 <list_notempty.4820.4290>
 8002230:	1c03      	adds	r3, r0, #0
 8002232:	2b00      	cmp	r3, #0
 8002234:	d1ee      	bne.n	8002214 <chThdExitS.4212+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8002236:	9b03      	ldr	r3, [sp, #12]
 8002238:	7f5b      	ldrb	r3, [r3, #29]
 800223a:	1c1a      	adds	r2, r3, #0
 800223c:	2303      	movs	r3, #3
 800223e:	4013      	ands	r3, r2
 8002240:	d109      	bne.n	8002256 <chThdExitS.4212+0x56>
    REG_REMOVE(tp);
 8002242:	9b03      	ldr	r3, [sp, #12]
 8002244:	695b      	ldr	r3, [r3, #20]
 8002246:	9a03      	ldr	r2, [sp, #12]
 8002248:	6912      	ldr	r2, [r2, #16]
 800224a:	611a      	str	r2, [r3, #16]
 800224c:	9b03      	ldr	r3, [sp, #12]
 800224e:	691b      	ldr	r3, [r3, #16]
 8002250:	9a03      	ldr	r2, [sp, #12]
 8002252:	6952      	ldr	r2, [r2, #20]
 8002254:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8002256:	200f      	movs	r0, #15
 8002258:	f7ff fdca 	bl	8001df0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 800225c:	b005      	add	sp, #20
 800225e:	bd00      	pop	{pc}
 8002260:	20000300 	.word	0x20000300
 8002264:	46c0      	nop			; (mov r8, r8)
 8002266:	46c0      	nop			; (mov r8, r8)
 8002268:	46c0      	nop			; (mov r8, r8)
 800226a:	46c0      	nop			; (mov r8, r8)
 800226c:	46c0      	nop			; (mov r8, r8)
 800226e:	46c0      	nop			; (mov r8, r8)

08002270 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8002270:	b500      	push	{lr}
 8002272:	b083      	sub	sp, #12
 8002274:	9001      	str	r0, [sp, #4]
 8002276:	1c0a      	adds	r2, r1, #0
 8002278:	466b      	mov	r3, sp
 800227a:	3302      	adds	r3, #2
 800227c:	801a      	strh	r2, [r3, #0]

  if (TIME_IMMEDIATE == timeout) {
 800227e:	466b      	mov	r3, sp
 8002280:	3302      	adds	r3, #2
 8002282:	881b      	ldrh	r3, [r3, #0]
 8002284:	2b00      	cmp	r3, #0
 8002286:	d102      	bne.n	800228e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
 8002288:	2301      	movs	r3, #1
 800228a:	425b      	negs	r3, r3
 800228c:	e00e      	b.n	80022ac <chThdEnqueueTimeoutS+0x3c>
  }

  queue_insert(currp, tqp);
 800228e:	4b09      	ldr	r3, [pc, #36]	; (80022b4 <chThdEnqueueTimeoutS+0x44>)
 8002290:	699a      	ldr	r2, [r3, #24]
 8002292:	9b01      	ldr	r3, [sp, #4]
 8002294:	1c10      	adds	r0, r2, #0
 8002296:	1c19      	adds	r1, r3, #0
 8002298:	f7ff fd32 	bl	8001d00 <queue_insert.4347>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800229c:	466b      	mov	r3, sp
 800229e:	3302      	adds	r3, #2
 80022a0:	881b      	ldrh	r3, [r3, #0]
 80022a2:	2004      	movs	r0, #4
 80022a4:	1c19      	adds	r1, r3, #0
 80022a6:	f7ff fdfb 	bl	8001ea0 <chSchGoSleepTimeoutS>
 80022aa:	1c03      	adds	r3, r0, #0
}
 80022ac:	1c18      	adds	r0, r3, #0
 80022ae:	b003      	add	sp, #12
 80022b0:	bd00      	pop	{pc}
 80022b2:	46c0      	nop			; (mov r8, r8)
 80022b4:	20000300 	.word	0x20000300
 80022b8:	46c0      	nop			; (mov r8, r8)
 80022ba:	46c0      	nop			; (mov r8, r8)
 80022bc:	46c0      	nop			; (mov r8, r8)
 80022be:	46c0      	nop			; (mov r8, r8)

080022c0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80022c0:	b500      	push	{lr}
 80022c2:	b083      	sub	sp, #12
 80022c4:	9001      	str	r0, [sp, #4]
 80022c6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 80022c8:	9b01      	ldr	r3, [sp, #4]
 80022ca:	1c18      	adds	r0, r3, #0
 80022cc:	f7ff fed8 	bl	8002080 <queue_notempty.4824.4287>
 80022d0:	1c03      	adds	r3, r0, #0
 80022d2:	2b00      	cmp	r3, #0
 80022d4:	d005      	beq.n	80022e2 <chThdDequeueNextI+0x22>
    chThdDoDequeueNextI(tqp, msg);
 80022d6:	9a01      	ldr	r2, [sp, #4]
 80022d8:	9b00      	ldr	r3, [sp, #0]
 80022da:	1c10      	adds	r0, r2, #0
 80022dc:	1c19      	adds	r1, r3, #0
 80022de:	f7ff feef 	bl	80020c0 <chThdDoDequeueNextI.4850.4260>
  }
}
 80022e2:	b003      	add	sp, #12
 80022e4:	bd00      	pop	{pc}
 80022e6:	46c0      	nop			; (mov r8, r8)
 80022e8:	46c0      	nop			; (mov r8, r8)
 80022ea:	46c0      	nop			; (mov r8, r8)
 80022ec:	46c0      	nop			; (mov r8, r8)
 80022ee:	46c0      	nop			; (mov r8, r8)

080022f0 <queue_init.5370.4099>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80022f0:	b082      	sub	sp, #8
 80022f2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80022f4:	9b01      	ldr	r3, [sp, #4]
 80022f6:	9a01      	ldr	r2, [sp, #4]
 80022f8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80022fa:	9b01      	ldr	r3, [sp, #4]
 80022fc:	9a01      	ldr	r2, [sp, #4]
 80022fe:	605a      	str	r2, [r3, #4]
}
 8002300:	b002      	add	sp, #8
 8002302:	4770      	bx	lr
 8002304:	46c0      	nop			; (mov r8, r8)
 8002306:	46c0      	nop			; (mov r8, r8)
 8002308:	46c0      	nop			; (mov r8, r8)
 800230a:	46c0      	nop			; (mov r8, r8)
 800230c:	46c0      	nop			; (mov r8, r8)
 800230e:	46c0      	nop			; (mov r8, r8)

08002310 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8002310:	b500      	push	{lr}
 8002312:	b083      	sub	sp, #12
 8002314:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8002316:	9b01      	ldr	r3, [sp, #4]
 8002318:	1c18      	adds	r0, r3, #0
 800231a:	f7ff ffe9 	bl	80022f0 <queue_init.5370.4099>
  mp->m_owner = NULL;
 800231e:	9b01      	ldr	r3, [sp, #4]
 8002320:	2200      	movs	r2, #0
 8002322:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8002324:	b003      	add	sp, #12
 8002326:	bd00      	pop	{pc}
 8002328:	46c0      	nop			; (mov r8, r8)
 800232a:	46c0      	nop			; (mov r8, r8)
 800232c:	46c0      	nop			; (mov r8, r8)
 800232e:	46c0      	nop			; (mov r8, r8)
 8002330:	656c6469 	.word	0x656c6469
	...

08002340 <ch_debug>:
 8002340:	6e69616d 18401600 08300204 1814100c     main..@...0.....
 8002350:	001d1c00 00000000 00000000 00000000     ................

08002360 <vmt.6507.4489>:
 8002360:	080001d1 08000201 08000231 08000271     ........1...q...
 8002370:	080002a1 080002e1 08000311 08000341     ............A...

08002380 <pal_default_config>:
 8002380:	280000a4 00000000 ffffff57 65555501     ...(....W....UUe
 8002390:	0000ffff 00001100 00000000 00000000     ................
 80023a0:	00000000 ffffffff 55555555 0000ffff     ........UUUU....
	...
 80023c0:	ffffffff 51555555 0000ffff 00000000     ....UUUQ........
	...
 80023e0:	55555550 0000ffff 00000000 00000000     PUUU............
 80023f0:	08001e60 08001e82 08001e82 08001e66     `...........f...
 8002400:	08001e7a 08001e70 08001e82 08001e7a     z...p.......z...
