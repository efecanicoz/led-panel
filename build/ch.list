
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4821      	ldr	r0, [pc, #132]	; (8000148 <endfiniloop+0x4>)
 80000c4:	f380 8809 	msr	PSP, r0
 80000c8:	2002      	movs	r0, #2
 80000ca:	f380 8814 	msr	CONTROL, r0
 80000ce:	f3bf 8f6f 	isb	sy
 80000d2:	f002 f8a5 	bl	8002220 <__core_init>
 80000d6:	f000 fc03 	bl	80008e0 <__early_init>
 80000da:	481c      	ldr	r0, [pc, #112]	; (800014c <endfiniloop+0x8>)
 80000dc:	491c      	ldr	r1, [pc, #112]	; (8000150 <endfiniloop+0xc>)
 80000de:	4a1d      	ldr	r2, [pc, #116]	; (8000154 <endfiniloop+0x10>)

080000e0 <msloop>:
 80000e0:	4291      	cmp	r1, r2
 80000e2:	da02      	bge.n	80000ea <endmsloop>
 80000e4:	6008      	str	r0, [r1, #0]
 80000e6:	3104      	adds	r1, #4
 80000e8:	e7fa      	b.n	80000e0 <msloop>

080000ea <endmsloop>:
 80000ea:	491b      	ldr	r1, [pc, #108]	; (8000158 <endfiniloop+0x14>)
 80000ec:	4a16      	ldr	r2, [pc, #88]	; (8000148 <endfiniloop+0x4>)

080000ee <psloop>:
 80000ee:	4291      	cmp	r1, r2
 80000f0:	da02      	bge.n	80000f8 <endpsloop>
 80000f2:	6008      	str	r0, [r1, #0]
 80000f4:	3104      	adds	r1, #4
 80000f6:	e7fa      	b.n	80000ee <psloop>

080000f8 <endpsloop>:
 80000f8:	4918      	ldr	r1, [pc, #96]	; (800015c <endfiniloop+0x18>)
 80000fa:	4a19      	ldr	r2, [pc, #100]	; (8000160 <endfiniloop+0x1c>)
 80000fc:	4b19      	ldr	r3, [pc, #100]	; (8000164 <endfiniloop+0x20>)

080000fe <dloop>:
 80000fe:	429a      	cmp	r2, r3
 8000100:	da04      	bge.n	800010c <enddloop>
 8000102:	6808      	ldr	r0, [r1, #0]
 8000104:	6010      	str	r0, [r2, #0]
 8000106:	3104      	adds	r1, #4
 8000108:	3204      	adds	r2, #4
 800010a:	e7f8      	b.n	80000fe <dloop>

0800010c <enddloop>:
 800010c:	2000      	movs	r0, #0
 800010e:	4916      	ldr	r1, [pc, #88]	; (8000168 <endfiniloop+0x24>)
 8000110:	4a16      	ldr	r2, [pc, #88]	; (800016c <endfiniloop+0x28>)

08000112 <bloop>:
 8000112:	4291      	cmp	r1, r2
 8000114:	da02      	bge.n	800011c <endbloop>
 8000116:	6008      	str	r0, [r1, #0]
 8000118:	3104      	adds	r1, #4
 800011a:	e7fa      	b.n	8000112 <bloop>

0800011c <endbloop>:
 800011c:	f002 f888 	bl	8002230 <__late_init>
 8000120:	4c13      	ldr	r4, [pc, #76]	; (8000170 <endfiniloop+0x2c>)
 8000122:	4d14      	ldr	r5, [pc, #80]	; (8000174 <endfiniloop+0x30>)

08000124 <initloop>:
 8000124:	42ac      	cmp	r4, r5
 8000126:	da03      	bge.n	8000130 <endinitloop>
 8000128:	6821      	ldr	r1, [r4, #0]
 800012a:	4788      	blx	r1
 800012c:	3404      	adds	r4, #4
 800012e:	e7f9      	b.n	8000124 <initloop>

08000130 <endinitloop>:
 8000130:	f000 fd66 	bl	8000c00 <main>
 8000134:	4c10      	ldr	r4, [pc, #64]	; (8000178 <endfiniloop+0x34>)
 8000136:	4d11      	ldr	r5, [pc, #68]	; (800017c <endfiniloop+0x38>)

08000138 <finiloop>:
 8000138:	42ac      	cmp	r4, r5
 800013a:	da03      	bge.n	8000144 <endfiniloop>
 800013c:	6821      	ldr	r1, [r4, #0]
 800013e:	4788      	blx	r1
 8000140:	3404      	adds	r4, #4
 8000142:	e7f9      	b.n	8000138 <finiloop>

08000144 <endfiniloop>:
 8000144:	490e      	ldr	r1, [pc, #56]	; (8000180 <endfiniloop+0x3c>)
 8000146:	4708      	bx	r1
 8000148:	20000300 	.word	0x20000300
 800014c:	55555555 	.word	0x55555555
 8000150:	20000000 	.word	0x20000000
 8000154:	20000200 	.word	0x20000200
 8000158:	20000200 	.word	0x20000200
 800015c:	080031c0 	.word	0x080031c0
 8000160:	20000300 	.word	0x20000300
 8000164:	20000300 	.word	0x20000300
 8000168:	20000300 	.word	0x20000300
 800016c:	200004d4 	.word	0x200004d4
 8000170:	080000c0 	.word	0x080000c0
 8000174:	080000c0 	.word	0x080000c0
 8000178:	080000c0 	.word	0x080000c0
 800017c:	080000c0 	.word	0x080000c0
 8000180:	08002241 	.word	0x08002241
	...

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	b662      	cpsie	i
 80001b2:	1c28      	adds	r0, r5, #0
 80001b4:	47a0      	blx	r4
 80001b6:	2000      	movs	r0, #0
 80001b8:	f002 fe9a 	bl	8002ef0 <chThdExit>

080001bc <_port_switch_from_isr>:
 80001bc:	f002 fdb8 	bl	8002d30 <chSchDoReschedule>

080001c0 <_port_exit_from_isr>:
 80001c0:	4a01      	ldr	r2, [pc, #4]	; (80001c8 <_port_exit_from_isr+0x8>)
 80001c2:	4b02      	ldr	r3, [pc, #8]	; (80001cc <_port_exit_from_isr+0xc>)
 80001c4:	6013      	str	r3, [r2, #0]
 80001c6:	e7fe      	b.n	80001c6 <_port_exit_from_isr+0x6>
 80001c8:	e000ed04 	.word	0xe000ed04
 80001cc:	80000000 	.word	0x80000000

080001d0 <__aeabi_uidiv>:
 80001d0:	2900      	cmp	r1, #0
 80001d2:	d034      	beq.n	800023e <.udivsi3_skip_div0_test+0x6a>

080001d4 <.udivsi3_skip_div0_test>:
 80001d4:	2301      	movs	r3, #1
 80001d6:	2200      	movs	r2, #0
 80001d8:	b410      	push	{r4}
 80001da:	4288      	cmp	r0, r1
 80001dc:	d32c      	bcc.n	8000238 <.udivsi3_skip_div0_test+0x64>
 80001de:	2401      	movs	r4, #1
 80001e0:	0724      	lsls	r4, r4, #28
 80001e2:	42a1      	cmp	r1, r4
 80001e4:	d204      	bcs.n	80001f0 <.udivsi3_skip_div0_test+0x1c>
 80001e6:	4281      	cmp	r1, r0
 80001e8:	d202      	bcs.n	80001f0 <.udivsi3_skip_div0_test+0x1c>
 80001ea:	0109      	lsls	r1, r1, #4
 80001ec:	011b      	lsls	r3, r3, #4
 80001ee:	e7f8      	b.n	80001e2 <.udivsi3_skip_div0_test+0xe>
 80001f0:	00e4      	lsls	r4, r4, #3
 80001f2:	42a1      	cmp	r1, r4
 80001f4:	d204      	bcs.n	8000200 <.udivsi3_skip_div0_test+0x2c>
 80001f6:	4281      	cmp	r1, r0
 80001f8:	d202      	bcs.n	8000200 <.udivsi3_skip_div0_test+0x2c>
 80001fa:	0049      	lsls	r1, r1, #1
 80001fc:	005b      	lsls	r3, r3, #1
 80001fe:	e7f8      	b.n	80001f2 <.udivsi3_skip_div0_test+0x1e>
 8000200:	4288      	cmp	r0, r1
 8000202:	d301      	bcc.n	8000208 <.udivsi3_skip_div0_test+0x34>
 8000204:	1a40      	subs	r0, r0, r1
 8000206:	431a      	orrs	r2, r3
 8000208:	084c      	lsrs	r4, r1, #1
 800020a:	42a0      	cmp	r0, r4
 800020c:	d302      	bcc.n	8000214 <.udivsi3_skip_div0_test+0x40>
 800020e:	1b00      	subs	r0, r0, r4
 8000210:	085c      	lsrs	r4, r3, #1
 8000212:	4322      	orrs	r2, r4
 8000214:	088c      	lsrs	r4, r1, #2
 8000216:	42a0      	cmp	r0, r4
 8000218:	d302      	bcc.n	8000220 <.udivsi3_skip_div0_test+0x4c>
 800021a:	1b00      	subs	r0, r0, r4
 800021c:	089c      	lsrs	r4, r3, #2
 800021e:	4322      	orrs	r2, r4
 8000220:	08cc      	lsrs	r4, r1, #3
 8000222:	42a0      	cmp	r0, r4
 8000224:	d302      	bcc.n	800022c <.udivsi3_skip_div0_test+0x58>
 8000226:	1b00      	subs	r0, r0, r4
 8000228:	08dc      	lsrs	r4, r3, #3
 800022a:	4322      	orrs	r2, r4
 800022c:	2800      	cmp	r0, #0
 800022e:	d003      	beq.n	8000238 <.udivsi3_skip_div0_test+0x64>
 8000230:	091b      	lsrs	r3, r3, #4
 8000232:	d001      	beq.n	8000238 <.udivsi3_skip_div0_test+0x64>
 8000234:	0909      	lsrs	r1, r1, #4
 8000236:	e7e3      	b.n	8000200 <.udivsi3_skip_div0_test+0x2c>
 8000238:	1c10      	adds	r0, r2, #0
 800023a:	bc10      	pop	{r4}
 800023c:	4770      	bx	lr
 800023e:	2800      	cmp	r0, #0
 8000240:	d001      	beq.n	8000246 <.udivsi3_skip_div0_test+0x72>
 8000242:	2000      	movs	r0, #0
 8000244:	43c0      	mvns	r0, r0
 8000246:	b407      	push	{r0, r1, r2}
 8000248:	4802      	ldr	r0, [pc, #8]	; (8000254 <.udivsi3_skip_div0_test+0x80>)
 800024a:	a102      	add	r1, pc, #8	; (adr r1, 8000254 <.udivsi3_skip_div0_test+0x80>)
 800024c:	1840      	adds	r0, r0, r1
 800024e:	9002      	str	r0, [sp, #8]
 8000250:	bd03      	pop	{r0, r1, pc}
 8000252:	46c0      	nop			; (mov r8, r8)
 8000254:	0000001d 	.word	0x0000001d

08000258 <__aeabi_uidivmod>:
 8000258:	2900      	cmp	r1, #0
 800025a:	d0f0      	beq.n	800023e <.udivsi3_skip_div0_test+0x6a>
 800025c:	b503      	push	{r0, r1, lr}
 800025e:	f7ff ffb9 	bl	80001d4 <.udivsi3_skip_div0_test>
 8000262:	bc0e      	pop	{r1, r2, r3}
 8000264:	4342      	muls	r2, r0
 8000266:	1a89      	subs	r1, r1, r2
 8000268:	4718      	bx	r3
 800026a:	46c0      	nop			; (mov r8, r8)
 800026c:	0000      	movs	r0, r0
	...

08000270 <__aeabi_idiv0>:
 8000270:	4770      	bx	lr
 8000272:	46c0      	nop			; (mov r8, r8)
	...

08000280 <Vector48.4318>:
/**
 * @brief   EXTI[17],EXTI[19],EXTI[20] interrupt handler (RTC).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector48) {
 8000280:	b500      	push	{lr}
 8000282:	b083      	sub	sp, #12
 8000284:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8000286:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR & EXTI->IMR & ((1 << 17) | (1 << 19) | (1 << 20));
 8000288:	4b1c      	ldr	r3, [pc, #112]	; (80002fc <Vector48.4318+0x7c>)
 800028a:	695a      	ldr	r2, [r3, #20]
 800028c:	4b1b      	ldr	r3, [pc, #108]	; (80002fc <Vector48.4318+0x7c>)
 800028e:	681b      	ldr	r3, [r3, #0]
 8000290:	401a      	ands	r2, r3
 8000292:	23d0      	movs	r3, #208	; 0xd0
 8000294:	035b      	lsls	r3, r3, #13
 8000296:	4013      	ands	r3, r2
 8000298:	9300      	str	r3, [sp, #0]
  EXTI->PR = pr;
 800029a:	4b18      	ldr	r3, [pc, #96]	; (80002fc <Vector48.4318+0x7c>)
 800029c:	9a00      	ldr	r2, [sp, #0]
 800029e:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 17))
 80002a0:	9a00      	ldr	r2, [sp, #0]
 80002a2:	2380      	movs	r3, #128	; 0x80
 80002a4:	029b      	lsls	r3, r3, #10
 80002a6:	4013      	ands	r3, r2
 80002a8:	d007      	beq.n	80002ba <Vector48.4318+0x3a>
    EXTD1.config->channels[17].cb(&EXTD1, 17);
 80002aa:	4b15      	ldr	r3, [pc, #84]	; (8000300 <Vector48.4318+0x80>)
 80002ac:	685a      	ldr	r2, [r3, #4]
 80002ae:	238c      	movs	r3, #140	; 0x8c
 80002b0:	58d3      	ldr	r3, [r2, r3]
 80002b2:	4a13      	ldr	r2, [pc, #76]	; (8000300 <Vector48.4318+0x80>)
 80002b4:	1c10      	adds	r0, r2, #0
 80002b6:	2111      	movs	r1, #17
 80002b8:	4798      	blx	r3
  if (pr & (1 << 19))
 80002ba:	9a00      	ldr	r2, [sp, #0]
 80002bc:	2380      	movs	r3, #128	; 0x80
 80002be:	031b      	lsls	r3, r3, #12
 80002c0:	4013      	ands	r3, r2
 80002c2:	d007      	beq.n	80002d4 <Vector48.4318+0x54>
    EXTD1.config->channels[19].cb(&EXTD1, 19);
 80002c4:	4b0e      	ldr	r3, [pc, #56]	; (8000300 <Vector48.4318+0x80>)
 80002c6:	685a      	ldr	r2, [r3, #4]
 80002c8:	239c      	movs	r3, #156	; 0x9c
 80002ca:	58d3      	ldr	r3, [r2, r3]
 80002cc:	4a0c      	ldr	r2, [pc, #48]	; (8000300 <Vector48.4318+0x80>)
 80002ce:	1c10      	adds	r0, r2, #0
 80002d0:	2113      	movs	r1, #19
 80002d2:	4798      	blx	r3
  if (pr & (1 << 20))
 80002d4:	9a00      	ldr	r2, [sp, #0]
 80002d6:	2380      	movs	r3, #128	; 0x80
 80002d8:	035b      	lsls	r3, r3, #13
 80002da:	4013      	ands	r3, r2
 80002dc:	d007      	beq.n	80002ee <Vector48.4318+0x6e>
    EXTD1.config->channels[20].cb(&EXTD1, 20);
 80002de:	4b08      	ldr	r3, [pc, #32]	; (8000300 <Vector48.4318+0x80>)
 80002e0:	685a      	ldr	r2, [r3, #4]
 80002e2:	23a4      	movs	r3, #164	; 0xa4
 80002e4:	58d3      	ldr	r3, [r2, r3]
 80002e6:	4a06      	ldr	r2, [pc, #24]	; (8000300 <Vector48.4318+0x80>)
 80002e8:	1c10      	adds	r0, r2, #0
 80002ea:	2114      	movs	r1, #20
 80002ec:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80002ee:	9b01      	ldr	r3, [sp, #4]
 80002f0:	1c18      	adds	r0, r3, #0
 80002f2:	f001 fba5 	bl	8001a40 <_port_irq_epilogue>
}
 80002f6:	b003      	add	sp, #12
 80002f8:	bd00      	pop	{pc}
 80002fa:	46c0      	nop			; (mov r8, r8)
 80002fc:	40010400 	.word	0x40010400
 8000300:	20000450 	.word	0x20000450
 8000304:	46c0      	nop			; (mov r8, r8)
 8000306:	46c0      	nop			; (mov r8, r8)
 8000308:	46c0      	nop			; (mov r8, r8)
 800030a:	46c0      	nop			; (mov r8, r8)
 800030c:	46c0      	nop			; (mov r8, r8)
 800030e:	46c0      	nop			; (mov r8, r8)

08000310 <ext_lld_exti_irq_enable>:
/**
 * @brief   Enables EXTI IRQ sources.
 *
 * @notapi
 */
void ext_lld_exti_irq_enable(void) {
 8000310:	b508      	push	{r3, lr}

  nvicEnableVector(EXTI0_1_IRQn, STM32_EXT_EXTI0_1_IRQ_PRIORITY);
 8000312:	2005      	movs	r0, #5
 8000314:	2103      	movs	r1, #3
 8000316:	f000 feeb 	bl	80010f0 <nvicEnableVector>
  nvicEnableVector(EXTI2_3_IRQn, STM32_EXT_EXTI2_3_IRQ_PRIORITY);
 800031a:	2006      	movs	r0, #6
 800031c:	2103      	movs	r1, #3
 800031e:	f000 fee7 	bl	80010f0 <nvicEnableVector>
  nvicEnableVector(EXTI4_15_IRQn, STM32_EXT_EXTI4_15_IRQ_PRIORITY);
 8000322:	2007      	movs	r0, #7
 8000324:	2103      	movs	r1, #3
 8000326:	f000 fee3 	bl	80010f0 <nvicEnableVector>
#if !defined(STM32F030) && !defined(STM32F070)
  nvicEnableVector(PVD_IRQn, STM32_EXT_EXTI16_IRQ_PRIORITY);
  nvicEnableVector(ADC1_COMP_IRQn, STM32_EXT_EXTI21_22_IRQ_PRIORITY);
#endif
  nvicEnableVector(RTC_IRQn, STM32_EXT_EXTI17_20_IRQ_PRIORITY);
 800032a:	2002      	movs	r0, #2
 800032c:	2103      	movs	r1, #3
 800032e:	f000 fedf 	bl	80010f0 <nvicEnableVector>
}
 8000332:	bd08      	pop	{r3, pc}
 8000334:	46c0      	nop			; (mov r8, r8)
 8000336:	46c0      	nop			; (mov r8, r8)
 8000338:	46c0      	nop			; (mov r8, r8)
 800033a:	46c0      	nop			; (mov r8, r8)
 800033c:	46c0      	nop			; (mov r8, r8)
 800033e:	46c0      	nop			; (mov r8, r8)

08000340 <initgpio.6917.4308>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8000340:	b082      	sub	sp, #8
 8000342:	9001      	str	r0, [sp, #4]
 8000344:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8000346:	9b00      	ldr	r3, [sp, #0]
 8000348:	685a      	ldr	r2, [r3, #4]
 800034a:	9b01      	ldr	r3, [sp, #4]
 800034c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800034e:	9b00      	ldr	r3, [sp, #0]
 8000350:	689a      	ldr	r2, [r3, #8]
 8000352:	9b01      	ldr	r3, [sp, #4]
 8000354:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000356:	9b00      	ldr	r3, [sp, #0]
 8000358:	68da      	ldr	r2, [r3, #12]
 800035a:	9b01      	ldr	r3, [sp, #4]
 800035c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800035e:	9b00      	ldr	r3, [sp, #0]
 8000360:	691a      	ldr	r2, [r3, #16]
 8000362:	9b01      	ldr	r3, [sp, #4]
 8000364:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000366:	9b00      	ldr	r3, [sp, #0]
 8000368:	695a      	ldr	r2, [r3, #20]
 800036a:	9b01      	ldr	r3, [sp, #4]
 800036c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800036e:	9b00      	ldr	r3, [sp, #0]
 8000370:	699a      	ldr	r2, [r3, #24]
 8000372:	9b01      	ldr	r3, [sp, #4]
 8000374:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000376:	9b00      	ldr	r3, [sp, #0]
 8000378:	681a      	ldr	r2, [r3, #0]
 800037a:	9b01      	ldr	r3, [sp, #4]
 800037c:	601a      	str	r2, [r3, #0]
}
 800037e:	b002      	add	sp, #8
 8000380:	4770      	bx	lr
 8000382:	46c0      	nop			; (mov r8, r8)
 8000384:	46c0      	nop			; (mov r8, r8)
 8000386:	46c0      	nop			; (mov r8, r8)
 8000388:	46c0      	nop			; (mov r8, r8)
 800038a:	46c0      	nop			; (mov r8, r8)
 800038c:	46c0      	nop			; (mov r8, r8)
 800038e:	46c0      	nop			; (mov r8, r8)

08000390 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8000390:	b500      	push	{lr}
 8000392:	b083      	sub	sp, #12
 8000394:	9001      	str	r0, [sp, #4]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000396:	4b12      	ldr	r3, [pc, #72]	; (80003e0 <_pal_lld_init+0x50>)
 8000398:	4a11      	ldr	r2, [pc, #68]	; (80003e0 <_pal_lld_init+0x50>)
 800039a:	6952      	ldr	r2, [r2, #20]
 800039c:	219c      	movs	r1, #156	; 0x9c
 800039e:	03c9      	lsls	r1, r1, #15
 80003a0:	430a      	orrs	r2, r1
 80003a2:	615a      	str	r2, [r3, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 80003a4:	9b01      	ldr	r3, [sp, #4]
 80003a6:	2290      	movs	r2, #144	; 0x90
 80003a8:	05d2      	lsls	r2, r2, #23
 80003aa:	1c10      	adds	r0, r2, #0
 80003ac:	1c19      	adds	r1, r3, #0
 80003ae:	f7ff ffc7 	bl	8000340 <initgpio.6917.4308>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 80003b2:	9b01      	ldr	r3, [sp, #4]
 80003b4:	331c      	adds	r3, #28
 80003b6:	4a0b      	ldr	r2, [pc, #44]	; (80003e4 <_pal_lld_init+0x54>)
 80003b8:	1c10      	adds	r0, r2, #0
 80003ba:	1c19      	adds	r1, r3, #0
 80003bc:	f7ff ffc0 	bl	8000340 <initgpio.6917.4308>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80003c0:	9b01      	ldr	r3, [sp, #4]
 80003c2:	3338      	adds	r3, #56	; 0x38
 80003c4:	4a08      	ldr	r2, [pc, #32]	; (80003e8 <_pal_lld_init+0x58>)
 80003c6:	1c10      	adds	r0, r2, #0
 80003c8:	1c19      	adds	r1, r3, #0
 80003ca:	f7ff ffb9 	bl	8000340 <initgpio.6917.4308>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 80003ce:	9b01      	ldr	r3, [sp, #4]
 80003d0:	3354      	adds	r3, #84	; 0x54
 80003d2:	4a06      	ldr	r2, [pc, #24]	; (80003ec <_pal_lld_init+0x5c>)
 80003d4:	1c10      	adds	r0, r2, #0
 80003d6:	1c19      	adds	r1, r3, #0
 80003d8:	f7ff ffb2 	bl	8000340 <initgpio.6917.4308>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 80003dc:	b003      	add	sp, #12
 80003de:	bd00      	pop	{pc}
 80003e0:	40021000 	.word	0x40021000
 80003e4:	48000400 	.word	0x48000400
 80003e8:	48000800 	.word	0x48000800
 80003ec:	48001400 	.word	0x48001400

080003f0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80003f0:	b08e      	sub	sp, #56	; 0x38
 80003f2:	9003      	str	r0, [sp, #12]
 80003f4:	9102      	str	r1, [sp, #8]
 80003f6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80003f8:	9a01      	ldr	r2, [sp, #4]
 80003fa:	2303      	movs	r3, #3
 80003fc:	4013      	ands	r3, r2
 80003fe:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8000400:	9a01      	ldr	r2, [sp, #4]
 8000402:	2304      	movs	r3, #4
 8000404:	4013      	ands	r3, r2
 8000406:	089b      	lsrs	r3, r3, #2
 8000408:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800040a:	9a01      	ldr	r2, [sp, #4]
 800040c:	2318      	movs	r3, #24
 800040e:	4013      	ands	r3, r2
 8000410:	08db      	lsrs	r3, r3, #3
 8000412:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8000414:	9a01      	ldr	r2, [sp, #4]
 8000416:	2360      	movs	r3, #96	; 0x60
 8000418:	4013      	ands	r3, r2
 800041a:	095b      	lsrs	r3, r3, #5
 800041c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800041e:	9a01      	ldr	r2, [sp, #4]
 8000420:	23f0      	movs	r3, #240	; 0xf0
 8000422:	00db      	lsls	r3, r3, #3
 8000424:	4013      	ands	r3, r2
 8000426:	09db      	lsrs	r3, r3, #7
 8000428:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 800042a:	2300      	movs	r3, #0
 800042c:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800042e:	9a02      	ldr	r2, [sp, #8]
 8000430:	2301      	movs	r3, #1
 8000432:	4013      	ands	r3, r2
 8000434:	d058      	beq.n	80004e8 <_pal_lld_setgroupmode+0xf8>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8000436:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8000438:	2307      	movs	r3, #7
 800043a:	4013      	ands	r3, r2
 800043c:	009b      	lsls	r3, r3, #2
 800043e:	9a08      	ldr	r2, [sp, #32]
 8000440:	1c11      	adds	r1, r2, #0
 8000442:	4099      	lsls	r1, r3
 8000444:	1c0b      	adds	r3, r1, #0
 8000446:	9307      	str	r3, [sp, #28]
      m4 = 15 << ((bit & 7) * 4);
 8000448:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800044a:	2307      	movs	r3, #7
 800044c:	4013      	ands	r3, r2
 800044e:	009b      	lsls	r3, r3, #2
 8000450:	220f      	movs	r2, #15
 8000452:	1c11      	adds	r1, r2, #0
 8000454:	4099      	lsls	r1, r3
 8000456:	1c0b      	adds	r3, r1, #0
 8000458:	9306      	str	r3, [sp, #24]
      if (bit < 8)
 800045a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800045c:	2b07      	cmp	r3, #7
 800045e:	d809      	bhi.n	8000474 <_pal_lld_setgroupmode+0x84>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8000460:	9b03      	ldr	r3, [sp, #12]
 8000462:	6a1b      	ldr	r3, [r3, #32]
 8000464:	9a06      	ldr	r2, [sp, #24]
 8000466:	43d2      	mvns	r2, r2
 8000468:	401a      	ands	r2, r3
 800046a:	9b07      	ldr	r3, [sp, #28]
 800046c:	431a      	orrs	r2, r3
 800046e:	9b03      	ldr	r3, [sp, #12]
 8000470:	621a      	str	r2, [r3, #32]
 8000472:	e008      	b.n	8000486 <_pal_lld_setgroupmode+0x96>
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000474:	9b03      	ldr	r3, [sp, #12]
 8000476:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000478:	9a06      	ldr	r2, [sp, #24]
 800047a:	43d2      	mvns	r2, r2
 800047c:	401a      	ands	r2, r3
 800047e:	9b07      	ldr	r3, [sp, #28]
 8000480:	431a      	orrs	r2, r3
 8000482:	9b03      	ldr	r3, [sp, #12]
 8000484:	625a      	str	r2, [r3, #36]	; 0x24
      m1 = 1 << bit;
 8000486:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000488:	2201      	movs	r2, #1
 800048a:	1c11      	adds	r1, r2, #0
 800048c:	4099      	lsls	r1, r3
 800048e:	1c0b      	adds	r3, r1, #0
 8000490:	9305      	str	r3, [sp, #20]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000492:	9b03      	ldr	r3, [sp, #12]
 8000494:	685b      	ldr	r3, [r3, #4]
 8000496:	9a05      	ldr	r2, [sp, #20]
 8000498:	43d2      	mvns	r2, r2
 800049a:	401a      	ands	r2, r3
 800049c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800049e:	431a      	orrs	r2, r3
 80004a0:	9b03      	ldr	r3, [sp, #12]
 80004a2:	605a      	str	r2, [r3, #4]
      m2 = 3 << (bit * 2);
 80004a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80004a6:	005b      	lsls	r3, r3, #1
 80004a8:	2203      	movs	r2, #3
 80004aa:	1c11      	adds	r1, r2, #0
 80004ac:	4099      	lsls	r1, r3
 80004ae:	1c0b      	adds	r3, r1, #0
 80004b0:	9304      	str	r3, [sp, #16]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80004b2:	9b03      	ldr	r3, [sp, #12]
 80004b4:	689b      	ldr	r3, [r3, #8]
 80004b6:	9a04      	ldr	r2, [sp, #16]
 80004b8:	43d2      	mvns	r2, r2
 80004ba:	401a      	ands	r2, r3
 80004bc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80004be:	431a      	orrs	r2, r3
 80004c0:	9b03      	ldr	r3, [sp, #12]
 80004c2:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80004c4:	9b03      	ldr	r3, [sp, #12]
 80004c6:	68db      	ldr	r3, [r3, #12]
 80004c8:	9a04      	ldr	r2, [sp, #16]
 80004ca:	43d2      	mvns	r2, r2
 80004cc:	401a      	ands	r2, r3
 80004ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80004d0:	431a      	orrs	r2, r3
 80004d2:	9b03      	ldr	r3, [sp, #12]
 80004d4:	60da      	str	r2, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 80004d6:	9b03      	ldr	r3, [sp, #12]
 80004d8:	681b      	ldr	r3, [r3, #0]
 80004da:	9a04      	ldr	r2, [sp, #16]
 80004dc:	43d2      	mvns	r2, r2
 80004de:	401a      	ands	r2, r3
 80004e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80004e2:	431a      	orrs	r2, r3
 80004e4:	9b03      	ldr	r3, [sp, #12]
 80004e6:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
 80004e8:	9b02      	ldr	r3, [sp, #8]
 80004ea:	085b      	lsrs	r3, r3, #1
 80004ec:	9302      	str	r3, [sp, #8]
    if (!mask)
 80004ee:	9b02      	ldr	r3, [sp, #8]
 80004f0:	2b00      	cmp	r3, #0
 80004f2:	d00f      	beq.n	8000514 <_pal_lld_setgroupmode+0x124>
      return;
    otyper <<= 1;
 80004f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80004f6:	005b      	lsls	r3, r3, #1
 80004f8:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 80004fa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80004fc:	009b      	lsls	r3, r3, #2
 80004fe:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 8000500:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000502:	009b      	lsls	r3, r3, #2
 8000504:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8000506:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8000508:	009b      	lsls	r3, r3, #2
 800050a:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800050c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800050e:	3301      	adds	r3, #1
 8000510:	9309      	str	r3, [sp, #36]	; 0x24
 8000512:	e78c      	b.n	800042e <_pal_lld_setgroupmode+0x3e>
  }
}
 8000514:	b00e      	add	sp, #56	; 0x38
 8000516:	4770      	bx	lr
 8000518:	46c0      	nop			; (mov r8, r8)
 800051a:	46c0      	nop			; (mov r8, r8)
 800051c:	46c0      	nop			; (mov r8, r8)
 800051e:	46c0      	nop			; (mov r8, r8)

08000520 <port_lock.6988.4258>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000520:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000522:	4770      	bx	lr
 8000524:	46c0      	nop			; (mov r8, r8)
 8000526:	46c0      	nop			; (mov r8, r8)
 8000528:	46c0      	nop			; (mov r8, r8)
 800052a:	46c0      	nop			; (mov r8, r8)
 800052c:	46c0      	nop			; (mov r8, r8)
 800052e:	46c0      	nop			; (mov r8, r8)

08000530 <port_unlock.6991.4256>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000530:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000532:	4770      	bx	lr
 8000534:	46c0      	nop			; (mov r8, r8)
 8000536:	46c0      	nop			; (mov r8, r8)
 8000538:	46c0      	nop			; (mov r8, r8)
 800053a:	46c0      	nop			; (mov r8, r8)
 800053c:	46c0      	nop			; (mov r8, r8)
 800053e:	46c0      	nop			; (mov r8, r8)

08000540 <port_lock_from_isr.6993.4254>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000540:	b508      	push	{r3, lr}

  port_lock();
 8000542:	f7ff ffed 	bl	8000520 <port_lock.6988.4258>
}
 8000546:	bd08      	pop	{r3, pc}
 8000548:	46c0      	nop			; (mov r8, r8)
 800054a:	46c0      	nop			; (mov r8, r8)
 800054c:	46c0      	nop			; (mov r8, r8)
 800054e:	46c0      	nop			; (mov r8, r8)

08000550 <port_unlock_from_isr.6995.4252>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000550:	b508      	push	{r3, lr}

  port_unlock();
 8000552:	f7ff ffed 	bl	8000530 <port_unlock.6991.4256>
}
 8000556:	bd08      	pop	{r3, pc}
 8000558:	46c0      	nop			; (mov r8, r8)
 800055a:	46c0      	nop			; (mov r8, r8)
 800055c:	46c0      	nop			; (mov r8, r8)
 800055e:	46c0      	nop			; (mov r8, r8)

08000560 <chSysLockFromISR.6997.4250>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000560:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000562:	f7ff ffed 	bl	8000540 <port_lock_from_isr.6993.4254>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000566:	bd08      	pop	{r3, pc}
 8000568:	46c0      	nop			; (mov r8, r8)
 800056a:	46c0      	nop			; (mov r8, r8)
 800056c:	46c0      	nop			; (mov r8, r8)
 800056e:	46c0      	nop			; (mov r8, r8)

08000570 <chSysUnlockFromISR.6999.4248>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000570:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000572:	f7ff ffed 	bl	8000550 <port_unlock_from_isr.6995.4252>
}
 8000576:	bd08      	pop	{r3, pc}
 8000578:	46c0      	nop			; (mov r8, r8)
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	46c0      	nop			; (mov r8, r8)
 800057e:	46c0      	nop			; (mov r8, r8)

08000580 <osalSysLockFromISR.7001.4246>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8000580:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8000582:	f7ff ffed 	bl	8000560 <chSysLockFromISR.6997.4250>
}
 8000586:	bd08      	pop	{r3, pc}
 8000588:	46c0      	nop			; (mov r8, r8)
 800058a:	46c0      	nop			; (mov r8, r8)
 800058c:	46c0      	nop			; (mov r8, r8)
 800058e:	46c0      	nop			; (mov r8, r8)

08000590 <osalSysUnlockFromISR.7003.4244>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8000590:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8000592:	f7ff ffed 	bl	8000570 <chSysUnlockFromISR.6999.4248>
}
 8000596:	bd08      	pop	{r3, pc}
 8000598:	46c0      	nop			; (mov r8, r8)
 800059a:	46c0      	nop			; (mov r8, r8)
 800059c:	46c0      	nop			; (mov r8, r8)
 800059e:	46c0      	nop			; (mov r8, r8)

080005a0 <osalEventBroadcastFlagsI.7005.4240>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80005a0:	b082      	sub	sp, #8
 80005a2:	9001      	str	r0, [sp, #4]
 80005a4:	9100      	str	r1, [sp, #0]

  esp->flags |= flags;
 80005a6:	9b01      	ldr	r3, [sp, #4]
 80005a8:	681a      	ldr	r2, [r3, #0]
 80005aa:	9b00      	ldr	r3, [sp, #0]
 80005ac:	431a      	orrs	r2, r3
 80005ae:	9b01      	ldr	r3, [sp, #4]
 80005b0:	601a      	str	r2, [r3, #0]
}
 80005b2:	b002      	add	sp, #8
 80005b4:	4770      	bx	lr
 80005b6:	46c0      	nop			; (mov r8, r8)
 80005b8:	46c0      	nop			; (mov r8, r8)
 80005ba:	46c0      	nop			; (mov r8, r8)
 80005bc:	46c0      	nop			; (mov r8, r8)
 80005be:	46c0      	nop			; (mov r8, r8)

080005c0 <usart_init.7091.4236>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 80005c0:	b500      	push	{lr}
 80005c2:	b085      	sub	sp, #20
 80005c4:	9001      	str	r0, [sp, #4]
 80005c6:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 80005c8:	9b01      	ldr	r3, [sp, #4]
 80005ca:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80005cc:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 80005ce:	9b01      	ldr	r3, [sp, #4]
 80005d0:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 80005d2:	9b00      	ldr	r3, [sp, #0]
 80005d4:	681b      	ldr	r3, [r3, #0]
 80005d6:	1c10      	adds	r0, r2, #0
 80005d8:	1c19      	adds	r1, r3, #0
 80005da:	f7ff fdf9 	bl	80001d0 <__aeabi_uidiv>
 80005de:	1c03      	adds	r3, r0, #0
 80005e0:	1c1a      	adds	r2, r3, #0
 80005e2:	9b03      	ldr	r3, [sp, #12]
 80005e4:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80005e6:	9b00      	ldr	r3, [sp, #0]
 80005e8:	689b      	ldr	r3, [r3, #8]
 80005ea:	2240      	movs	r2, #64	; 0x40
 80005ec:	431a      	orrs	r2, r3
 80005ee:	9b03      	ldr	r3, [sp, #12]
 80005f0:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80005f2:	9b00      	ldr	r3, [sp, #0]
 80005f4:	68db      	ldr	r3, [r3, #12]
 80005f6:	2201      	movs	r2, #1
 80005f8:	431a      	orrs	r2, r3
 80005fa:	9b03      	ldr	r3, [sp, #12]
 80005fc:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80005fe:	9b00      	ldr	r3, [sp, #0]
 8000600:	685b      	ldr	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8000602:	222e      	movs	r2, #46	; 0x2e
 8000604:	32ff      	adds	r2, #255	; 0xff
 8000606:	431a      	orrs	r2, r3
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000608:	9b03      	ldr	r3, [sp, #12]
 800060a:	601a      	str	r2, [r3, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800060c:	9b03      	ldr	r3, [sp, #12]
 800060e:	2201      	movs	r2, #1
 8000610:	4252      	negs	r2, r2
 8000612:	621a      	str	r2, [r3, #32]
}
 8000614:	b005      	add	sp, #20
 8000616:	bd00      	pop	{pc}
 8000618:	46c0      	nop			; (mov r8, r8)
 800061a:	46c0      	nop			; (mov r8, r8)
 800061c:	46c0      	nop			; (mov r8, r8)
 800061e:	46c0      	nop			; (mov r8, r8)

08000620 <usart_deinit.7143.4233>:
 * @brief   USART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] u         pointer to an USART I/O block
 */
static void usart_deinit(USART_TypeDef *u) {
 8000620:	b082      	sub	sp, #8
 8000622:	9001      	str	r0, [sp, #4]

  u->CR1 = 0;
 8000624:	9b01      	ldr	r3, [sp, #4]
 8000626:	2200      	movs	r2, #0
 8000628:	601a      	str	r2, [r3, #0]
  u->CR2 = 0;
 800062a:	9b01      	ldr	r3, [sp, #4]
 800062c:	2200      	movs	r2, #0
 800062e:	605a      	str	r2, [r3, #4]
  u->CR3 = 0;
 8000630:	9b01      	ldr	r3, [sp, #4]
 8000632:	2200      	movs	r2, #0
 8000634:	609a      	str	r2, [r3, #8]
}
 8000636:	b002      	add	sp, #8
 8000638:	4770      	bx	lr
 800063a:	46c0      	nop			; (mov r8, r8)
 800063c:	46c0      	nop			; (mov r8, r8)
 800063e:	46c0      	nop			; (mov r8, r8)

08000640 <set_error.7146.4229>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 8000640:	b500      	push	{lr}
 8000642:	b085      	sub	sp, #20
 8000644:	9001      	str	r0, [sp, #4]
 8000646:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 8000648:	2300      	movs	r3, #0
 800064a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 800064c:	9a00      	ldr	r2, [sp, #0]
 800064e:	2308      	movs	r3, #8
 8000650:	4013      	ands	r3, r2
 8000652:	d003      	beq.n	800065c <set_error.7146.4229+0x1c>
    sts |= SD_OVERRUN_ERROR;
 8000654:	9b03      	ldr	r3, [sp, #12]
 8000656:	2280      	movs	r2, #128	; 0x80
 8000658:	4313      	orrs	r3, r2
 800065a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 800065c:	9a00      	ldr	r2, [sp, #0]
 800065e:	2301      	movs	r3, #1
 8000660:	4013      	ands	r3, r2
 8000662:	d003      	beq.n	800066c <set_error.7146.4229+0x2c>
    sts |= SD_PARITY_ERROR;
 8000664:	9b03      	ldr	r3, [sp, #12]
 8000666:	2220      	movs	r2, #32
 8000668:	4313      	orrs	r3, r2
 800066a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 800066c:	9a00      	ldr	r2, [sp, #0]
 800066e:	2302      	movs	r3, #2
 8000670:	4013      	ands	r3, r2
 8000672:	d003      	beq.n	800067c <set_error.7146.4229+0x3c>
    sts |= SD_FRAMING_ERROR;
 8000674:	9b03      	ldr	r3, [sp, #12]
 8000676:	2240      	movs	r2, #64	; 0x40
 8000678:	4313      	orrs	r3, r2
 800067a:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 800067c:	9a00      	ldr	r2, [sp, #0]
 800067e:	2304      	movs	r3, #4
 8000680:	4013      	ands	r3, r2
 8000682:	d004      	beq.n	800068e <set_error.7146.4229+0x4e>
    sts |= SD_NOISE_ERROR;
 8000684:	9b03      	ldr	r3, [sp, #12]
 8000686:	2280      	movs	r2, #128	; 0x80
 8000688:	0052      	lsls	r2, r2, #1
 800068a:	4313      	orrs	r3, r2
 800068c:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 800068e:	f7ff ff77 	bl	8000580 <osalSysLockFromISR.7001.4246>
  chnAddFlagsI(sdp, sts);
 8000692:	9b01      	ldr	r3, [sp, #4]
 8000694:	1d1a      	adds	r2, r3, #4
 8000696:	9b03      	ldr	r3, [sp, #12]
 8000698:	1c10      	adds	r0, r2, #0
 800069a:	1c19      	adds	r1, r3, #0
 800069c:	f7ff ff80 	bl	80005a0 <osalEventBroadcastFlagsI.7005.4240>
  osalSysUnlockFromISR();
 80006a0:	f7ff ff76 	bl	8000590 <osalSysUnlockFromISR.7003.4244>
}
 80006a4:	b005      	add	sp, #20
 80006a6:	bd00      	pop	{pc}
 80006a8:	46c0      	nop			; (mov r8, r8)
 80006aa:	46c0      	nop			; (mov r8, r8)
 80006ac:	46c0      	nop			; (mov r8, r8)
 80006ae:	46c0      	nop			; (mov r8, r8)

080006b0 <serve_interrupt.7150.4226>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 80006b0:	b500      	push	{lr}
 80006b2:	b087      	sub	sp, #28
 80006b4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 80006b6:	9b01      	ldr	r3, [sp, #4]
 80006b8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80006ba:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 80006bc:	9b05      	ldr	r3, [sp, #20]
 80006be:	681b      	ldr	r3, [r3, #0]
 80006c0:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80006c2:	9b05      	ldr	r3, [sp, #20]
 80006c4:	69db      	ldr	r3, [r3, #28]
 80006c6:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 80006c8:	9b05      	ldr	r3, [sp, #20]
 80006ca:	9a03      	ldr	r2, [sp, #12]
 80006cc:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80006ce:	9a03      	ldr	r2, [sp, #12]
 80006d0:	230f      	movs	r3, #15
 80006d2:	4013      	ands	r3, r2
 80006d4:	d005      	beq.n	80006e2 <serve_interrupt.7150.4226+0x32>
    set_error(sdp, isr);
 80006d6:	9a01      	ldr	r2, [sp, #4]
 80006d8:	9b03      	ldr	r3, [sp, #12]
 80006da:	1c10      	adds	r0, r2, #0
 80006dc:	1c19      	adds	r1, r3, #0
 80006de:	f7ff ffaf 	bl	8000640 <set_error.7146.4229>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80006e2:	9a03      	ldr	r2, [sp, #12]
 80006e4:	2380      	movs	r3, #128	; 0x80
 80006e6:	005b      	lsls	r3, r3, #1
 80006e8:	4013      	ands	r3, r2
 80006ea:	d00b      	beq.n	8000704 <serve_interrupt.7150.4226+0x54>
    osalSysLockFromISR();
 80006ec:	f7ff ff48 	bl	8000580 <osalSysLockFromISR.7001.4246>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 80006f0:	9b01      	ldr	r3, [sp, #4]
 80006f2:	1d1a      	adds	r2, r3, #4
 80006f4:	2380      	movs	r3, #128	; 0x80
 80006f6:	009b      	lsls	r3, r3, #2
 80006f8:	1c10      	adds	r0, r2, #0
 80006fa:	1c19      	adds	r1, r3, #0
 80006fc:	f7ff ff50 	bl	80005a0 <osalEventBroadcastFlagsI.7005.4240>
    osalSysUnlockFromISR();
 8000700:	f7ff ff46 	bl	8000590 <osalSysUnlockFromISR.7003.4244>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000704:	9a03      	ldr	r2, [sp, #12]
 8000706:	2320      	movs	r3, #32
 8000708:	4013      	ands	r3, r2
 800070a:	d00c      	beq.n	8000726 <serve_interrupt.7150.4226+0x76>
    osalSysLockFromISR();
 800070c:	f7ff ff38 	bl	8000580 <osalSysLockFromISR.7001.4246>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000710:	9b05      	ldr	r3, [sp, #20]
 8000712:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8000714:	b29b      	uxth	r3, r3
 8000716:	b2db      	uxtb	r3, r3
 8000718:	9a01      	ldr	r2, [sp, #4]
 800071a:	1c10      	adds	r0, r2, #0
 800071c:	1c19      	adds	r1, r3, #0
 800071e:	f000 fcbf 	bl	80010a0 <sdIncomingDataI>
    osalSysUnlockFromISR();
 8000722:	f7ff ff35 	bl	8000590 <osalSysUnlockFromISR.7003.4244>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000726:	9a04      	ldr	r2, [sp, #16]
 8000728:	2380      	movs	r3, #128	; 0x80
 800072a:	4013      	ands	r3, r2
 800072c:	d023      	beq.n	8000776 <serve_interrupt.7150.4226+0xc6>
 800072e:	9a03      	ldr	r2, [sp, #12]
 8000730:	2380      	movs	r3, #128	; 0x80
 8000732:	4013      	ands	r3, r2
 8000734:	d01f      	beq.n	8000776 <serve_interrupt.7150.4226+0xc6>
    msg_t b;
    osalSysLockFromISR();
 8000736:	f7ff ff23 	bl	8000580 <osalSysLockFromISR.7001.4246>
    b = oqGetI(&sdp->oqueue);
 800073a:	9b01      	ldr	r3, [sp, #4]
 800073c:	3330      	adds	r3, #48	; 0x30
 800073e:	1c18      	adds	r0, r3, #0
 8000740:	f001 fc76 	bl	8002030 <oqGetI>
 8000744:	1c03      	adds	r3, r0, #0
 8000746:	9302      	str	r3, [sp, #8]
    if (b < Q_OK) {
 8000748:	9b02      	ldr	r3, [sp, #8]
 800074a:	2b00      	cmp	r3, #0
 800074c:	da0d      	bge.n	800076a <serve_interrupt.7150.4226+0xba>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800074e:	9b01      	ldr	r3, [sp, #4]
 8000750:	3304      	adds	r3, #4
 8000752:	1c18      	adds	r0, r3, #0
 8000754:	2108      	movs	r1, #8
 8000756:	f7ff ff23 	bl	80005a0 <osalEventBroadcastFlagsI.7005.4240>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800075a:	9b04      	ldr	r3, [sp, #16]
 800075c:	22c0      	movs	r2, #192	; 0xc0
 800075e:	4393      	bics	r3, r2
 8000760:	2240      	movs	r2, #64	; 0x40
 8000762:	431a      	orrs	r2, r3
 8000764:	9b05      	ldr	r3, [sp, #20]
 8000766:	601a      	str	r2, [r3, #0]
 8000768:	e003      	b.n	8000772 <serve_interrupt.7150.4226+0xc2>
    }
    else
      u->TDR = b;
 800076a:	9b02      	ldr	r3, [sp, #8]
 800076c:	b29a      	uxth	r2, r3
 800076e:	9b05      	ldr	r3, [sp, #20]
 8000770:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 8000772:	f7ff ff0d 	bl	8000590 <osalSysUnlockFromISR.7003.4244>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000776:	9a03      	ldr	r2, [sp, #12]
 8000778:	2340      	movs	r3, #64	; 0x40
 800077a:	4013      	ands	r3, r2
 800077c:	d023      	beq.n	80007c6 <serve_interrupt.7150.4226+0x116>
    osalSysLockFromISR();
 800077e:	f7ff feff 	bl	8000580 <osalSysLockFromISR.7001.4246>
    if (oqIsEmptyI(&sdp->oqueue))
 8000782:	9b01      	ldr	r3, [sp, #4]
 8000784:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000786:	9b01      	ldr	r3, [sp, #4]
 8000788:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800078a:	429a      	cmp	r2, r3
 800078c:	d105      	bne.n	800079a <serve_interrupt.7150.4226+0xea>
 800078e:	9b01      	ldr	r3, [sp, #4]
 8000790:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000792:	2b00      	cmp	r3, #0
 8000794:	d001      	beq.n	800079a <serve_interrupt.7150.4226+0xea>
 8000796:	2301      	movs	r3, #1
 8000798:	e000      	b.n	800079c <serve_interrupt.7150.4226+0xec>
 800079a:	2300      	movs	r3, #0
 800079c:	1c1a      	adds	r2, r3, #0
 800079e:	2301      	movs	r3, #1
 80007a0:	4013      	ands	r3, r2
 80007a2:	b2db      	uxtb	r3, r3
 80007a4:	2b00      	cmp	r3, #0
 80007a6:	d005      	beq.n	80007b4 <serve_interrupt.7150.4226+0x104>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 80007a8:	9b01      	ldr	r3, [sp, #4]
 80007aa:	3304      	adds	r3, #4
 80007ac:	1c18      	adds	r0, r3, #0
 80007ae:	2110      	movs	r1, #16
 80007b0:	f7ff fef6 	bl	80005a0 <osalEventBroadcastFlagsI.7005.4240>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80007b4:	9b04      	ldr	r3, [sp, #16]
 80007b6:	2240      	movs	r2, #64	; 0x40
 80007b8:	1c19      	adds	r1, r3, #0
 80007ba:	4391      	bics	r1, r2
 80007bc:	1c0a      	adds	r2, r1, #0
 80007be:	9b05      	ldr	r3, [sp, #20]
 80007c0:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 80007c2:	f7ff fee5 	bl	8000590 <osalSysUnlockFromISR.7003.4244>
  }
}
 80007c6:	b007      	add	sp, #28
 80007c8:	bd00      	pop	{pc}
 80007ca:	46c0      	nop			; (mov r8, r8)
 80007cc:	46c0      	nop			; (mov r8, r8)
 80007ce:	46c0      	nop			; (mov r8, r8)

080007d0 <notify1.7015.4221>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {
 80007d0:	b082      	sub	sp, #8
 80007d2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 80007d4:	4b03      	ldr	r3, [pc, #12]	; (80007e4 <notify1.7015.4221+0x14>)
 80007d6:	4a03      	ldr	r2, [pc, #12]	; (80007e4 <notify1.7015.4221+0x14>)
 80007d8:	6812      	ldr	r2, [r2, #0]
 80007da:	2180      	movs	r1, #128	; 0x80
 80007dc:	430a      	orrs	r2, r1
 80007de:	601a      	str	r2, [r3, #0]
}
 80007e0:	b002      	add	sp, #8
 80007e2:	4770      	bx	lr
 80007e4:	40013800 	.word	0x40013800
 80007e8:	46c0      	nop			; (mov r8, r8)
 80007ea:	46c0      	nop			; (mov r8, r8)
 80007ec:	46c0      	nop			; (mov r8, r8)
 80007ee:	46c0      	nop			; (mov r8, r8)

080007f0 <VectorAC.4224>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 80007f0:	b500      	push	{lr}
 80007f2:	b083      	sub	sp, #12
 80007f4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80007f6:	9301      	str	r3, [sp, #4]

  serve_interrupt(&SD1);
 80007f8:	4b04      	ldr	r3, [pc, #16]	; (800080c <VectorAC.4224+0x1c>)
 80007fa:	1c18      	adds	r0, r3, #0
 80007fc:	f7ff ff58 	bl	80006b0 <serve_interrupt.7150.4226>

  OSAL_IRQ_EPILOGUE();
 8000800:	9b01      	ldr	r3, [sp, #4]
 8000802:	1c18      	adds	r0, r3, #0
 8000804:	f001 f91c 	bl	8001a40 <_port_irq_epilogue>
}
 8000808:	b003      	add	sp, #12
 800080a:	bd00      	pop	{pc}
 800080c:	20000458 	.word	0x20000458

08000810 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8000810:	b508      	push	{r3, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8000812:	4a09      	ldr	r2, [pc, #36]	; (8000838 <sd_lld_init+0x28>)
 8000814:	4b09      	ldr	r3, [pc, #36]	; (800083c <sd_lld_init+0x2c>)
 8000816:	1c10      	adds	r0, r2, #0
 8000818:	2100      	movs	r1, #0
 800081a:	1c1a      	adds	r2, r3, #0
 800081c:	f000 fbd8 	bl	8000fd0 <sdObjectInit>
  SD1.usart = USART1;
 8000820:	4b05      	ldr	r3, [pc, #20]	; (8000838 <sd_lld_init+0x28>)
 8000822:	4a07      	ldr	r2, [pc, #28]	; (8000840 <sd_lld_init+0x30>)
 8000824:	675a      	str	r2, [r3, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 8000826:	4b04      	ldr	r3, [pc, #16]	; (8000838 <sd_lld_init+0x28>)
 8000828:	4a06      	ldr	r2, [pc, #24]	; (8000844 <sd_lld_init+0x34>)
 800082a:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_USART1_NUMBER)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 800082c:	201b      	movs	r0, #27
 800082e:	2103      	movs	r1, #3
 8000830:	f000 fc5e 	bl	80010f0 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 8000834:	bd08      	pop	{r3, pc}
 8000836:	46c0      	nop			; (mov r8, r8)
 8000838:	20000458 	.word	0x20000458
 800083c:	080007d1 	.word	0x080007d1
 8000840:	40013800 	.word	0x40013800
 8000844:	02dc6c00 	.word	0x02dc6c00
 8000848:	46c0      	nop			; (mov r8, r8)
 800084a:	46c0      	nop			; (mov r8, r8)
 800084c:	46c0      	nop			; (mov r8, r8)
 800084e:	46c0      	nop			; (mov r8, r8)

08000850 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8000850:	b500      	push	{lr}
 8000852:	b083      	sub	sp, #12
 8000854:	9001      	str	r0, [sp, #4]
 8000856:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8000858:	9b00      	ldr	r3, [sp, #0]
 800085a:	2b00      	cmp	r3, #0
 800085c:	d101      	bne.n	8000862 <sd_lld_start+0x12>
    config = &default_config;
 800085e:	4b0c      	ldr	r3, [pc, #48]	; (8000890 <sd_lld_start+0x40>)
 8000860:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8000862:	9b01      	ldr	r3, [sp, #4]
 8000864:	7a1b      	ldrb	r3, [r3, #8]
 8000866:	2b01      	cmp	r3, #1
 8000868:	d10a      	bne.n	8000880 <sd_lld_start+0x30>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 800086a:	9a01      	ldr	r2, [sp, #4]
 800086c:	4b09      	ldr	r3, [pc, #36]	; (8000894 <sd_lld_start+0x44>)
 800086e:	429a      	cmp	r2, r3
 8000870:	d106      	bne.n	8000880 <sd_lld_start+0x30>
      rccEnableUSART1(FALSE);
 8000872:	4b09      	ldr	r3, [pc, #36]	; (8000898 <sd_lld_start+0x48>)
 8000874:	4a08      	ldr	r2, [pc, #32]	; (8000898 <sd_lld_start+0x48>)
 8000876:	6992      	ldr	r2, [r2, #24]
 8000878:	2180      	movs	r1, #128	; 0x80
 800087a:	01c9      	lsls	r1, r1, #7
 800087c:	430a      	orrs	r2, r1
 800087e:	619a      	str	r2, [r3, #24]
    if (&SD8 == sdp) {
      rccEnableUART8(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
 8000880:	9a01      	ldr	r2, [sp, #4]
 8000882:	9b00      	ldr	r3, [sp, #0]
 8000884:	1c10      	adds	r0, r2, #0
 8000886:	1c19      	adds	r1, r3, #0
 8000888:	f7ff fe9a 	bl	80005c0 <usart_init.7091.4236>
}
 800088c:	b003      	add	sp, #12
 800088e:	bd00      	pop	{pc}
 8000890:	08003080 	.word	0x08003080
 8000894:	20000458 	.word	0x20000458
 8000898:	40021000 	.word	0x40021000
 800089c:	46c0      	nop			; (mov r8, r8)
 800089e:	46c0      	nop			; (mov r8, r8)

080008a0 <sd_lld_stop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {
 80008a0:	b500      	push	{lr}
 80008a2:	b083      	sub	sp, #12
 80008a4:	9001      	str	r0, [sp, #4]

  if (sdp->state == SD_READY) {
 80008a6:	9b01      	ldr	r3, [sp, #4]
 80008a8:	7a1b      	ldrb	r3, [r3, #8]
 80008aa:	2b02      	cmp	r3, #2
 80008ac:	d10e      	bne.n	80008cc <sd_lld_stop+0x2c>
    /* UART is de-initialized then clocks are disabled.*/
    usart_deinit(sdp->usart);
 80008ae:	9b01      	ldr	r3, [sp, #4]
 80008b0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80008b2:	1c18      	adds	r0, r3, #0
 80008b4:	f7ff feb4 	bl	8000620 <usart_deinit.7143.4233>

#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 80008b8:	9a01      	ldr	r2, [sp, #4]
 80008ba:	4b05      	ldr	r3, [pc, #20]	; (80008d0 <sd_lld_stop+0x30>)
 80008bc:	429a      	cmp	r2, r3
 80008be:	d105      	bne.n	80008cc <sd_lld_stop+0x2c>
      rccDisableUSART1(FALSE);
 80008c0:	4b04      	ldr	r3, [pc, #16]	; (80008d4 <sd_lld_stop+0x34>)
 80008c2:	4a04      	ldr	r2, [pc, #16]	; (80008d4 <sd_lld_stop+0x34>)
 80008c4:	6991      	ldr	r1, [r2, #24]
 80008c6:	4a04      	ldr	r2, [pc, #16]	; (80008d8 <sd_lld_stop+0x38>)
 80008c8:	400a      	ands	r2, r1
 80008ca:	619a      	str	r2, [r3, #24]
      rccDisableUART8(FALSE);
      return;
    }
#endif
  }
}
 80008cc:	b003      	add	sp, #12
 80008ce:	bd00      	pop	{pc}
 80008d0:	20000458 	.word	0x20000458
 80008d4:	40021000 	.word	0x40021000
 80008d8:	ffffbfff 	.word	0xffffbfff
 80008dc:	46c0      	nop<und>			; (mov r8, r8)
 80008de:	46c0      	nop<und>			; (mov r8, r8)

080008e0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 80008e0:	b508      	push<und>	{r3, lr}

  stm32_clock_init();
 80008e2:	f000 fcad 	bl	8001240 <stm32_clock_init>
}
 80008e6:	bd08      	pop	{r3, pc}
 80008e8:	46c0      	nop			; (mov r8, r8)
 80008ea:	46c0      	nop			; (mov r8, r8)
 80008ec:	46c0      	nop			; (mov r8, r8)
 80008ee:	46c0      	nop			; (mov r8, r8)

080008f0 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 80008f0:	4770      	bx	lr
 80008f2:	46c0      	nop			; (mov r8, r8)
 80008f4:	46c0      	nop			; (mov r8, r8)
 80008f6:	46c0      	nop			; (mov r8, r8)
 80008f8:	46c0      	nop			; (mov r8, r8)
 80008fa:	46c0      	nop			; (mov r8, r8)
 80008fc:	46c0      	nop			; (mov r8, r8)
 80008fe:	46c0      	nop			; (mov r8, r8)

08000900 <reflect.7217.4072>:
 * Returns:		The reflection of the original data.
 *
 *********************************************************************/
static unsigned long
reflect(unsigned long data, unsigned char nBits)
{
 8000900:	b084      	sub	sp, #16
 8000902:	9001      	str	r0, [sp, #4]
 8000904:	1c0a      	adds	r2, r1, #0
 8000906:	466b      	mov	r3, sp
 8000908:	3303      	adds	r3, #3
 800090a:	701a      	strb	r2, [r3, #0]
	unsigned long  reflection = 0x00000000;
 800090c:	2300      	movs	r3, #0
 800090e:	9303      	str	r3, [sp, #12]
	unsigned char  bit;

	/*
	 * Reflect the data about the center bit.
	 */
	for (bit = 0; bit < nBits; ++bit)
 8000910:	466b      	mov	r3, sp
 8000912:	330b      	adds	r3, #11
 8000914:	2200      	movs	r2, #0
 8000916:	701a      	strb	r2, [r3, #0]
 8000918:	e01c      	b.n	8000954 <reflect.7217.4072+0x54>
	{
		/*
		 * If the LSB bit is set, set the reflection of it.
		 */
		if (data & 0x01)
 800091a:	9a01      	ldr	r2, [sp, #4]
 800091c:	2301      	movs	r3, #1
 800091e:	4013      	ands	r3, r2
 8000920:	d00e      	beq.n	8000940 <reflect.7217.4072+0x40>
		{
			reflection |= (1 << ((nBits - 1) - bit));
 8000922:	466b      	mov	r3, sp
 8000924:	3303      	adds	r3, #3
 8000926:	781b      	ldrb	r3, [r3, #0]
 8000928:	1e5a      	subs	r2, r3, #1
 800092a:	466b      	mov	r3, sp
 800092c:	330b      	adds	r3, #11
 800092e:	781b      	ldrb	r3, [r3, #0]
 8000930:	1ad3      	subs	r3, r2, r3
 8000932:	2201      	movs	r2, #1
 8000934:	1c11      	adds	r1, r2, #0
 8000936:	4099      	lsls	r1, r3
 8000938:	1c0b      	adds	r3, r1, #0
 800093a:	9a03      	ldr	r2, [sp, #12]
 800093c:	4313      	orrs	r3, r2
 800093e:	9303      	str	r3, [sp, #12]
		}

		data = (data >> 1);
 8000940:	9b01      	ldr	r3, [sp, #4]
 8000942:	085b      	lsrs	r3, r3, #1
 8000944:	9301      	str	r3, [sp, #4]
	unsigned char  bit;

	/*
	 * Reflect the data about the center bit.
	 */
	for (bit = 0; bit < nBits; ++bit)
 8000946:	466b      	mov	r3, sp
 8000948:	330b      	adds	r3, #11
 800094a:	466a      	mov	r2, sp
 800094c:	320b      	adds	r2, #11
 800094e:	7812      	ldrb	r2, [r2, #0]
 8000950:	3201      	adds	r2, #1
 8000952:	701a      	strb	r2, [r3, #0]
 8000954:	466a      	mov	r2, sp
 8000956:	320b      	adds	r2, #11
 8000958:	466b      	mov	r3, sp
 800095a:	3303      	adds	r3, #3
 800095c:	7812      	ldrb	r2, [r2, #0]
 800095e:	781b      	ldrb	r3, [r3, #0]
 8000960:	429a      	cmp	r2, r3
 8000962:	d3da      	bcc.n	800091a <reflect.7217.4072+0x1a>
		}

		data = (data >> 1);
	}

	return (reflection);
 8000964:	9b03      	ldr	r3, [sp, #12]

}	/* reflect() */
 8000966:	1c18      	adds	r0, r3, #0
 8000968:	b004      	add	sp, #16
 800096a:	4770      	bx	lr
 800096c:	46c0      	nop			; (mov r8, r8)
 800096e:	46c0      	nop			; (mov r8, r8)

08000970 <crcSlow.4068>:
 * Returns:		The CRC of the message.
 *
 *********************************************************************/
crc
crcSlow(unsigned char  message[], int nBytes)
{
 8000970:	b500      	push	{lr}
 8000972:	b087      	sub	sp, #28
 8000974:	9001      	str	r0, [sp, #4]
 8000976:	9100      	str	r1, [sp, #0]
    crc            remainder = INITIAL_REMAINDER;
 8000978:	466b      	mov	r3, sp
 800097a:	3316      	adds	r3, #22
 800097c:	2200      	movs	r2, #0
 800097e:	801a      	strh	r2, [r3, #0]


    /*
     * Perform modulo-2 division, a byte at a time.
     */
    for (byte = 0; byte < nBytes; ++byte)
 8000980:	2300      	movs	r3, #0
 8000982:	9304      	str	r3, [sp, #16]
 8000984:	e040      	b.n	8000a08 <crcSlow.4068+0x98>
    {
        /*
         * Bring the next byte into the remainder.
         */
        remainder ^= (REFLECT_DATA(message[byte]) << (WIDTH - 8));
 8000986:	9b04      	ldr	r3, [sp, #16]
 8000988:	9a01      	ldr	r2, [sp, #4]
 800098a:	18d3      	adds	r3, r2, r3
 800098c:	781b      	ldrb	r3, [r3, #0]
 800098e:	1c18      	adds	r0, r3, #0
 8000990:	2108      	movs	r1, #8
 8000992:	f7ff ffb5 	bl	8000900 <reflect.7217.4072>
 8000996:	1c03      	adds	r3, r0, #0
 8000998:	b2db      	uxtb	r3, r3
 800099a:	021b      	lsls	r3, r3, #8
 800099c:	b29a      	uxth	r2, r3
 800099e:	466b      	mov	r3, sp
 80009a0:	3316      	adds	r3, #22
 80009a2:	881b      	ldrh	r3, [r3, #0]
 80009a4:	4053      	eors	r3, r2
 80009a6:	b29a      	uxth	r2, r3
 80009a8:	466b      	mov	r3, sp
 80009aa:	3316      	adds	r3, #22
 80009ac:	801a      	strh	r2, [r3, #0]

        /*
         * Perform modulo-2 division, a bit at a time.
         */
        for (bit = 8; bit > 0; --bit)
 80009ae:	466b      	mov	r3, sp
 80009b0:	330f      	adds	r3, #15
 80009b2:	2208      	movs	r2, #8
 80009b4:	701a      	strb	r2, [r3, #0]
 80009b6:	e01f      	b.n	80009f8 <crcSlow.4068+0x88>
        {
            /*
             * Try to divide the current data bit.
             */
            if (remainder & TOPBIT)
 80009b8:	466b      	mov	r3, sp
 80009ba:	3316      	adds	r3, #22
 80009bc:	881b      	ldrh	r3, [r3, #0]
 80009be:	b21b      	sxth	r3, r3
 80009c0:	2b00      	cmp	r3, #0
 80009c2:	da0b      	bge.n	80009dc <crcSlow.4068+0x6c>
            {
                remainder = (remainder << 1) ^ POLYNOMIAL;
 80009c4:	466b      	mov	r3, sp
 80009c6:	3316      	adds	r3, #22
 80009c8:	881b      	ldrh	r3, [r3, #0]
 80009ca:	005b      	lsls	r3, r3, #1
 80009cc:	b29b      	uxth	r3, r3
 80009ce:	4a16      	ldr	r2, [pc, #88]	; (8000a28 <crcSlow.4068+0xb8>)
 80009d0:	4053      	eors	r3, r2
 80009d2:	b29a      	uxth	r2, r3
 80009d4:	466b      	mov	r3, sp
 80009d6:	3316      	adds	r3, #22
 80009d8:	801a      	strh	r2, [r3, #0]
 80009da:	e006      	b.n	80009ea <crcSlow.4068+0x7a>
            }
            else
            {
                remainder = (remainder << 1);
 80009dc:	466a      	mov	r2, sp
 80009de:	3216      	adds	r2, #22
 80009e0:	466b      	mov	r3, sp
 80009e2:	3316      	adds	r3, #22
 80009e4:	881b      	ldrh	r3, [r3, #0]
 80009e6:	18db      	adds	r3, r3, r3
 80009e8:	8013      	strh	r3, [r2, #0]
        remainder ^= (REFLECT_DATA(message[byte]) << (WIDTH - 8));

        /*
         * Perform modulo-2 division, a bit at a time.
         */
        for (bit = 8; bit > 0; --bit)
 80009ea:	466b      	mov	r3, sp
 80009ec:	330f      	adds	r3, #15
 80009ee:	466a      	mov	r2, sp
 80009f0:	320f      	adds	r2, #15
 80009f2:	7812      	ldrb	r2, [r2, #0]
 80009f4:	3a01      	subs	r2, #1
 80009f6:	701a      	strb	r2, [r3, #0]
 80009f8:	466b      	mov	r3, sp
 80009fa:	330f      	adds	r3, #15
 80009fc:	781b      	ldrb	r3, [r3, #0]
 80009fe:	2b00      	cmp	r3, #0
 8000a00:	d1da      	bne.n	80009b8 <crcSlow.4068+0x48>


    /*
     * Perform modulo-2 division, a byte at a time.
     */
    for (byte = 0; byte < nBytes; ++byte)
 8000a02:	9b04      	ldr	r3, [sp, #16]
 8000a04:	3301      	adds	r3, #1
 8000a06:	9304      	str	r3, [sp, #16]
 8000a08:	9a04      	ldr	r2, [sp, #16]
 8000a0a:	9b00      	ldr	r3, [sp, #0]
 8000a0c:	429a      	cmp	r2, r3
 8000a0e:	dbba      	blt.n	8000986 <crcSlow.4068+0x16>
    }

    /*
     * The final remainder is the CRC result.
     */
    return (REFLECT_REMAINDER(remainder) ^ FINAL_XOR_VALUE);
 8000a10:	466b      	mov	r3, sp
 8000a12:	3316      	adds	r3, #22
 8000a14:	881b      	ldrh	r3, [r3, #0]
 8000a16:	1c18      	adds	r0, r3, #0
 8000a18:	2110      	movs	r1, #16
 8000a1a:	f7ff ff71 	bl	8000900 <reflect.7217.4072>
 8000a1e:	1c03      	adds	r3, r0, #0
 8000a20:	b29b      	uxth	r3, r3

}   /* crcSlow() */
 8000a22:	1c18      	adds	r0, r3, #0
 8000a24:	b007      	add	sp, #28
 8000a26:	bd00      	pop	{pc}
 8000a28:	ffff8005 	.word	0xffff8005
 8000a2c:	46c0      	nop			; (mov r8, r8)
 8000a2e:	46c0      	nop			; (mov r8, r8)

08000a30 <port_lock.7237.4058>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a30:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000a32:	4770      	bx	lr
 8000a34:	46c0      	nop			; (mov r8, r8)
 8000a36:	46c0      	nop			; (mov r8, r8)
 8000a38:	46c0      	nop			; (mov r8, r8)
 8000a3a:	46c0      	nop			; (mov r8, r8)
 8000a3c:	46c0      	nop			; (mov r8, r8)
 8000a3e:	46c0      	nop			; (mov r8, r8)

08000a40 <port_unlock.7240.4056>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a40:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000a42:	4770      	bx	lr
 8000a44:	46c0      	nop			; (mov r8, r8)
 8000a46:	46c0      	nop			; (mov r8, r8)
 8000a48:	46c0      	nop			; (mov r8, r8)
 8000a4a:	46c0      	nop			; (mov r8, r8)
 8000a4c:	46c0      	nop			; (mov r8, r8)
 8000a4e:	46c0      	nop			; (mov r8, r8)

08000a50 <port_lock_from_isr.7242.4054>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000a50:	b508      	push	{r3, lr}

  port_lock();
 8000a52:	f7ff ffed 	bl	8000a30 <port_lock.7237.4058>
}
 8000a56:	bd08      	pop	{r3, pc}
 8000a58:	46c0      	nop			; (mov r8, r8)
 8000a5a:	46c0      	nop			; (mov r8, r8)
 8000a5c:	46c0      	nop			; (mov r8, r8)
 8000a5e:	46c0      	nop			; (mov r8, r8)

08000a60 <port_unlock_from_isr.7244.4052>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000a60:	b508      	push	{r3, lr}

  port_unlock();
 8000a62:	f7ff ffed 	bl	8000a40 <port_unlock.7240.4056>
}
 8000a66:	bd08      	pop	{r3, pc}
 8000a68:	46c0      	nop			; (mov r8, r8)
 8000a6a:	46c0      	nop			; (mov r8, r8)
 8000a6c:	46c0      	nop			; (mov r8, r8)
 8000a6e:	46c0      	nop			; (mov r8, r8)

08000a70 <chSysLockFromISR.7246.4050>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000a70:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000a72:	f7ff ffed 	bl	8000a50 <port_lock_from_isr.7242.4054>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000a76:	bd08      	pop	{r3, pc}
 8000a78:	46c0      	nop			; (mov r8, r8)
 8000a7a:	46c0      	nop			; (mov r8, r8)
 8000a7c:	46c0      	nop			; (mov r8, r8)
 8000a7e:	46c0      	nop			; (mov r8, r8)

08000a80 <chSysUnlockFromISR.7248.4048>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000a80:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000a82:	f7ff ffed 	bl	8000a60 <port_unlock_from_isr.7244.4052>
}
 8000a86:	bd08      	pop	{r3, pc}
 8000a88:	46c0      	nop			; (mov r8, r8)
 8000a8a:	46c0      	nop			; (mov r8, r8)
 8000a8c:	46c0      	nop			; (mov r8, r8)
 8000a8e:	46c0      	nop			; (mov r8, r8)

08000a90 <extcb2.7250.4025>:
static void sleep(void);
static void prepareForSend(uint8_t *, uint8_t);

/* Wake up callback.*/
static void extcb2(EXTDriver *extp, expchannel_t channel) 
{
 8000a90:	b500      	push	{lr}
 8000a92:	b083      	sub	sp, #12
 8000a94:	9001      	str	r0, [sp, #4]
 8000a96:	9100      	str	r1, [sp, #0]
	(void)extp;
	(void)channel;
	
	chSysLockFromISR();
 8000a98:	f7ff ffea 	bl	8000a70 <chSysLockFromISR.7246.4050>
	/* we must reinit clocks after waking up ESPECIALLY if use HSE or HSI+PLL */
	stm32_clock_init();
 8000a9c:	f000 fbd0 	bl	8001240 <stm32_clock_init>

	extChannelDisableI(&EXTD1, 0);
 8000aa0:	4b15      	ldr	r3, [pc, #84]	; (8000af8 <extcb2.7250.4025+0x68>)
 8000aa2:	1c18      	adds	r0, r3, #0
 8000aa4:	2100      	movs	r1, #0
 8000aa6:	f000 fdab 	bl	8001600 <ext_lld_channel_disable>
	extChannelDisableI(&EXTD1, 1);
 8000aaa:	4b13      	ldr	r3, [pc, #76]	; (8000af8 <extcb2.7250.4025+0x68>)
 8000aac:	1c18      	adds	r0, r3, #0
 8000aae:	2101      	movs	r1, #1
 8000ab0:	f000 fda6 	bl	8001600 <ext_lld_channel_disable>
	extChannelDisableI(&EXTD1, 4);
 8000ab4:	4b10      	ldr	r3, [pc, #64]	; (8000af8 <extcb2.7250.4025+0x68>)
 8000ab6:	1c18      	adds	r0, r3, #0
 8000ab8:	2104      	movs	r1, #4
 8000aba:	f000 fda1 	bl	8001600 <ext_lld_channel_disable>
	extChannelDisableI(&EXTD1, 5);
 8000abe:	4b0e      	ldr	r3, [pc, #56]	; (8000af8 <extcb2.7250.4025+0x68>)
 8000ac0:	1c18      	adds	r0, r3, #0
 8000ac2:	2105      	movs	r1, #5
 8000ac4:	f000 fd9c 	bl	8001600 <ext_lld_channel_disable>
	extChannelDisableI(&EXTD1, 6);
 8000ac8:	4b0b      	ldr	r3, [pc, #44]	; (8000af8 <extcb2.7250.4025+0x68>)
 8000aca:	1c18      	adds	r0, r3, #0
 8000acc:	2106      	movs	r1, #6
 8000ace:	f000 fd97 	bl	8001600 <ext_lld_channel_disable>
	extChannelDisableI(&EXTD1, 7);
 8000ad2:	4b09      	ldr	r3, [pc, #36]	; (8000af8 <extcb2.7250.4025+0x68>)
 8000ad4:	1c18      	adds	r0, r3, #0
 8000ad6:	2107      	movs	r1, #7
 8000ad8:	f000 fd92 	bl	8001600 <ext_lld_channel_disable>
	extChannelDisableI(&EXTD1, 9);
 8000adc:	4b06      	ldr	r3, [pc, #24]	; (8000af8 <extcb2.7250.4025+0x68>)
 8000ade:	1c18      	adds	r0, r3, #0
 8000ae0:	2109      	movs	r1, #9
 8000ae2:	f000 fd8d 	bl	8001600 <ext_lld_channel_disable>
	extChannelDisableI(&EXTD1, 10);
 8000ae6:	4b04      	ldr	r3, [pc, #16]	; (8000af8 <extcb2.7250.4025+0x68>)
 8000ae8:	1c18      	adds	r0, r3, #0
 8000aea:	210a      	movs	r1, #10
 8000aec:	f000 fd88 	bl	8001600 <ext_lld_channel_disable>
	chSysUnlockFromISR();
 8000af0:	f7ff ffc6 	bl	8000a80 <chSysUnlockFromISR.7248.4048>
}
 8000af4:	b003      	add	sp, #12
 8000af6:	bd00      	pop	{pc}
 8000af8:	20000450 	.word	0x20000450
 8000afc:	46c0      	nop			; (mov r8, r8)
 8000afe:	46c0      	nop			; (mov r8, r8)

08000b00 <prepareForSend.7271.4018>:
   {EXT_CH_MODE_DISABLED, NULL},
  }
};

static void prepareForSend(uint8_t *packet, uint8_t msg)
{
 8000b00:	b510      	push	{r4, lr}
 8000b02:	b084      	sub	sp, #16
 8000b04:	9001      	str	r0, [sp, #4]
 8000b06:	1c0a      	adds	r2, r1, #0
 8000b08:	466b      	mov	r3, sp
 8000b0a:	3303      	adds	r3, #3
 8000b0c:	701a      	strb	r2, [r3, #0]
	packet[0] = SOH;
 8000b0e:	9b01      	ldr	r3, [sp, #4]
 8000b10:	2201      	movs	r2, #1
 8000b12:	701a      	strb	r2, [r3, #0]
	packet[1] = ID;
 8000b14:	9b01      	ldr	r3, [sp, #4]
 8000b16:	3301      	adds	r3, #1
 8000b18:	22f0      	movs	r2, #240	; 0xf0
 8000b1a:	701a      	strb	r2, [r3, #0]
	packet[2] = TO;
 8000b1c:	9b01      	ldr	r3, [sp, #4]
 8000b1e:	3302      	adds	r3, #2
 8000b20:	2210      	movs	r2, #16
 8000b22:	701a      	strb	r2, [r3, #0]
	packet[3] = msg;
 8000b24:	9b01      	ldr	r3, [sp, #4]
 8000b26:	3303      	adds	r3, #3
 8000b28:	466a      	mov	r2, sp
 8000b2a:	3203      	adds	r2, #3
 8000b2c:	7812      	ldrb	r2, [r2, #0]
 8000b2e:	701a      	strb	r2, [r3, #0]
	uint16_t crcRes = crcSlow(packet, 4);
 8000b30:	466c      	mov	r4, sp
 8000b32:	340e      	adds	r4, #14
 8000b34:	9b01      	ldr	r3, [sp, #4]
 8000b36:	1c18      	adds	r0, r3, #0
 8000b38:	2104      	movs	r1, #4
 8000b3a:	f7ff ff19 	bl	8000970 <crcSlow.4068>
 8000b3e:	1c03      	adds	r3, r0, #0
 8000b40:	8023      	strh	r3, [r4, #0]
	packet[4] = crcRes >> 8;//high byte
 8000b42:	9b01      	ldr	r3, [sp, #4]
 8000b44:	3304      	adds	r3, #4
 8000b46:	466a      	mov	r2, sp
 8000b48:	320e      	adds	r2, #14
 8000b4a:	8812      	ldrh	r2, [r2, #0]
 8000b4c:	0a12      	lsrs	r2, r2, #8
 8000b4e:	b292      	uxth	r2, r2
 8000b50:	b2d2      	uxtb	r2, r2
 8000b52:	701a      	strb	r2, [r3, #0]
	packet[5] = crcRes;//low byte
 8000b54:	9b01      	ldr	r3, [sp, #4]
 8000b56:	3305      	adds	r3, #5
 8000b58:	466a      	mov	r2, sp
 8000b5a:	320e      	adds	r2, #14
 8000b5c:	8812      	ldrh	r2, [r2, #0]
 8000b5e:	b2d2      	uxtb	r2, r2
 8000b60:	701a      	strb	r2, [r3, #0]
	packet[6] = EOT;
 8000b62:	9b01      	ldr	r3, [sp, #4]
 8000b64:	3306      	adds	r3, #6
 8000b66:	2204      	movs	r2, #4
 8000b68:	701a      	strb	r2, [r3, #0]
	return;
}
 8000b6a:	b004      	add	sp, #16
 8000b6c:	bd10      	pop	{r4, pc}
 8000b6e:	46c0      	nop			; (mov r8, r8)

08000b70 <sleep.7277.4016>:

static void sleep(void)
{
 8000b70:	b508      	push	{r3, lr}
	extChannelEnable(&EXTD1, 0);
 8000b72:	4b1e      	ldr	r3, [pc, #120]	; (8000bec <sleep.7277.4016+0x7c>)
 8000b74:	1c18      	adds	r0, r3, #0
 8000b76:	2100      	movs	r1, #0
 8000b78:	f000 f8f2 	bl	8000d60 <extChannelEnable>
	extChannelEnable(&EXTD1, 1);
 8000b7c:	4b1b      	ldr	r3, [pc, #108]	; (8000bec <sleep.7277.4016+0x7c>)
 8000b7e:	1c18      	adds	r0, r3, #0
 8000b80:	2101      	movs	r1, #1
 8000b82:	f000 f8ed 	bl	8000d60 <extChannelEnable>
	extChannelEnable(&EXTD1, 4);
 8000b86:	4b19      	ldr	r3, [pc, #100]	; (8000bec <sleep.7277.4016+0x7c>)
 8000b88:	1c18      	adds	r0, r3, #0
 8000b8a:	2104      	movs	r1, #4
 8000b8c:	f000 f8e8 	bl	8000d60 <extChannelEnable>
	extChannelEnable(&EXTD1, 5);
 8000b90:	4b16      	ldr	r3, [pc, #88]	; (8000bec <sleep.7277.4016+0x7c>)
 8000b92:	1c18      	adds	r0, r3, #0
 8000b94:	2105      	movs	r1, #5
 8000b96:	f000 f8e3 	bl	8000d60 <extChannelEnable>
	extChannelEnable(&EXTD1, 6);
 8000b9a:	4b14      	ldr	r3, [pc, #80]	; (8000bec <sleep.7277.4016+0x7c>)
 8000b9c:	1c18      	adds	r0, r3, #0
 8000b9e:	2106      	movs	r1, #6
 8000ba0:	f000 f8de 	bl	8000d60 <extChannelEnable>
	extChannelEnable(&EXTD1, 7);
 8000ba4:	4b11      	ldr	r3, [pc, #68]	; (8000bec <sleep.7277.4016+0x7c>)
 8000ba6:	1c18      	adds	r0, r3, #0
 8000ba8:	2107      	movs	r1, #7
 8000baa:	f000 f8d9 	bl	8000d60 <extChannelEnable>
	extChannelEnable(&EXTD1, 9);
 8000bae:	4b0f      	ldr	r3, [pc, #60]	; (8000bec <sleep.7277.4016+0x7c>)
 8000bb0:	1c18      	adds	r0, r3, #0
 8000bb2:	2109      	movs	r1, #9
 8000bb4:	f000 f8d4 	bl	8000d60 <extChannelEnable>
	extChannelEnable(&EXTD1, 10);
 8000bb8:	4b0c      	ldr	r3, [pc, #48]	; (8000bec <sleep.7277.4016+0x7c>)
 8000bba:	1c18      	adds	r0, r3, #0
 8000bbc:	210a      	movs	r1, #10
 8000bbe:	f000 f8cf 	bl	8000d60 <extChannelEnable>

	PWR->CR |= (PWR_CR_LPDS | PWR_CR_CSBF | PWR_CR_CWUF);
 8000bc2:	4b0b      	ldr	r3, [pc, #44]	; (8000bf0 <sleep.7277.4016+0x80>)
 8000bc4:	4a0a      	ldr	r2, [pc, #40]	; (8000bf0 <sleep.7277.4016+0x80>)
 8000bc6:	6812      	ldr	r2, [r2, #0]
 8000bc8:	210d      	movs	r1, #13
 8000bca:	430a      	orrs	r2, r1
 8000bcc:	601a      	str	r2, [r3, #0]
	PWR->CR &= ~PWR_CR_PDDS;
 8000bce:	4b08      	ldr	r3, [pc, #32]	; (8000bf0 <sleep.7277.4016+0x80>)
 8000bd0:	4a07      	ldr	r2, [pc, #28]	; (8000bf0 <sleep.7277.4016+0x80>)
 8000bd2:	6812      	ldr	r2, [r2, #0]
 8000bd4:	2102      	movs	r1, #2
 8000bd6:	438a      	bics	r2, r1
 8000bd8:	601a      	str	r2, [r3, #0]
	SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 8000bda:	4b06      	ldr	r3, [pc, #24]	; (8000bf4 <sleep.7277.4016+0x84>)
 8000bdc:	4a05      	ldr	r2, [pc, #20]	; (8000bf4 <sleep.7277.4016+0x84>)
 8000bde:	6912      	ldr	r2, [r2, #16]
 8000be0:	2104      	movs	r1, #4
 8000be2:	430a      	orrs	r2, r1
 8000be4:	611a      	str	r2, [r3, #16]
    Wait For Interrupt is a hint instruction that suspends execution
    until one of a number of events occurs.
 */
__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
{
  __ASM volatile ("wfi");
 8000be6:	bf30      	wfi
	__WFI();
}
 8000be8:	bd08      	pop	{r3, pc}
 8000bea:	46c0      	nop			; (mov r8, r8)
 8000bec:	20000450 	.word	0x20000450
 8000bf0:	40007000 	.word	0x40007000
 8000bf4:	e000ed00 	.word	0xe000ed00
 8000bf8:	46c0      	nop			; (mov r8, r8)
 8000bfa:	46c0      	nop			; (mov r8, r8)
 8000bfc:	46c0      	nop			; (mov r8, r8)
 8000bfe:	46c0      	nop			; (mov r8, r8)

08000c00 <main>:

int main(void)
{
 8000c00:	b500      	push	{lr}
 8000c02:	b085      	sub	sp, #20
	halInit();
 8000c04:	f000 ff54 	bl	8001ab0 <halInit>
	chSysInit();
 8000c08:	f001 fcb2 	bl	8002570 <chSysInit>
	
  /*
   * Activates the EXT driver 1.
   */
	extStart(&EXTD1, &extcfg);
 8000c0c:	4a4b      	ldr	r2, [pc, #300]	; (8000d3c <main+0x13c>)
 8000c0e:	4b4c      	ldr	r3, [pc, #304]	; (8000d40 <main+0x140>)
 8000c10:	1c10      	adds	r0, r2, #0
 8000c12:	1c19      	adds	r1, r3, #0
 8000c14:	f001 faec 	bl	80021f0 <extStart>
	uint16_t rawSample = 0;
 8000c18:	ab03      	add	r3, sp, #12
 8000c1a:	2200      	movs	r2, #0
 8000c1c:	801a      	strh	r2, [r3, #0]
	uint8_t portSample;
	uint8_t packet[7];
    palSetGroupMode(GPIOA, A1TO10, 0, PAL_MODE_INPUT_PULLDOWN);
 8000c1e:	2390      	movs	r3, #144	; 0x90
 8000c20:	05da      	lsls	r2, r3, #23
 8000c22:	4b48      	ldr	r3, [pc, #288]	; (8000d44 <main+0x144>)
 8000c24:	1c10      	adds	r0, r2, #0
 8000c26:	1c19      	adds	r1, r3, #0
 8000c28:	2240      	movs	r2, #64	; 0x40
 8000c2a:	f7ff fbe1 	bl	80003f0 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, GPIOA_USART_TX, PAL_MODE_ALTERNATE(1)); // used function : USART1_TX
 8000c2e:	2390      	movs	r3, #144	; 0x90
 8000c30:	05db      	lsls	r3, r3, #23
 8000c32:	1c18      	adds	r0, r3, #0
 8000c34:	2104      	movs	r1, #4
 8000c36:	2282      	movs	r2, #130	; 0x82
 8000c38:	f7ff fbda 	bl	80003f0 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOA, GPIOA_USART_RX, PAL_MODE_ALTERNATE(1)); // used function : USART1_RX
 8000c3c:	2390      	movs	r3, #144	; 0x90
 8000c3e:	05db      	lsls	r3, r3, #23
 8000c40:	1c18      	adds	r0, r3, #0
 8000c42:	2108      	movs	r1, #8
 8000c44:	2282      	movs	r2, #130	; 0x82
 8000c46:	f7ff fbd3 	bl	80003f0 <_pal_lld_setgroupmode>
	sdStart(&SD1, NULL);
 8000c4a:	4b3f      	ldr	r3, [pc, #252]	; (8000d48 <main+0x148>)
 8000c4c:	1c18      	adds	r0, r3, #0
 8000c4e:	2100      	movs	r1, #0
 8000c50:	f000 f9ee 	bl	8001030 <sdStart>

	volatile long j;
	uint8_t i;
	while(!0)
	{
		sdStart(&SD1,NULL);
 8000c54:	4b3c      	ldr	r3, [pc, #240]	; (8000d48 <main+0x148>)
 8000c56:	1c18      	adds	r0, r3, #0
 8000c58:	2100      	movs	r1, #0
 8000c5a:	f000 f9e9 	bl	8001030 <sdStart>
		for(i = 0; i < 50U; i++)/*Send button five times, why five ?*/
 8000c5e:	466b      	mov	r3, sp
 8000c60:	330f      	adds	r3, #15
 8000c62:	2200      	movs	r2, #0
 8000c64:	701a      	strb	r2, [r3, #0]
 8000c66:	e05d      	b.n	8000d24 <main+0x124>
		{
			portSample = 0;
 8000c68:	466b      	mov	r3, sp
 8000c6a:	330b      	adds	r3, #11
 8000c6c:	2200      	movs	r2, #0
 8000c6e:	701a      	strb	r2, [r3, #0]
			rawSample = palReadGroup(GPIOA, A1TO10, 0);
 8000c70:	2390      	movs	r3, #144	; 0x90
 8000c72:	05db      	lsls	r3, r3, #23
 8000c74:	691b      	ldr	r3, [r3, #16]
 8000c76:	b299      	uxth	r1, r3
 8000c78:	ab03      	add	r3, sp, #12
 8000c7a:	4a32      	ldr	r2, [pc, #200]	; (8000d44 <main+0x144>)
 8000c7c:	400a      	ands	r2, r1
 8000c7e:	801a      	strh	r2, [r3, #0]
			portSample |= (MASKA0A1 & rawSample);
 8000c80:	ab03      	add	r3, sp, #12
 8000c82:	881b      	ldrh	r3, [r3, #0]
 8000c84:	b2da      	uxtb	r2, r3
 8000c86:	2303      	movs	r3, #3
 8000c88:	4013      	ands	r3, r2
 8000c8a:	b2d9      	uxtb	r1, r3
 8000c8c:	466b      	mov	r3, sp
 8000c8e:	330b      	adds	r3, #11
 8000c90:	466a      	mov	r2, sp
 8000c92:	320b      	adds	r2, #11
 8000c94:	7812      	ldrb	r2, [r2, #0]
 8000c96:	430a      	orrs	r2, r1
 8000c98:	701a      	strb	r2, [r3, #0]
			portSample |= (MASKA4A7 & rawSample) >> 2;
 8000c9a:	ab03      	add	r3, sp, #12
 8000c9c:	881a      	ldrh	r2, [r3, #0]
 8000c9e:	23f0      	movs	r3, #240	; 0xf0
 8000ca0:	4013      	ands	r3, r2
 8000ca2:	b29b      	uxth	r3, r3
 8000ca4:	089b      	lsrs	r3, r3, #2
 8000ca6:	b29b      	uxth	r3, r3
 8000ca8:	b2d9      	uxtb	r1, r3
 8000caa:	466b      	mov	r3, sp
 8000cac:	330b      	adds	r3, #11
 8000cae:	466a      	mov	r2, sp
 8000cb0:	320b      	adds	r2, #11
 8000cb2:	7812      	ldrb	r2, [r2, #0]
 8000cb4:	430a      	orrs	r2, r1
 8000cb6:	701a      	strb	r2, [r3, #0]
			portSample |= (MASKA9A10 & rawSample) >> 3;
 8000cb8:	ab03      	add	r3, sp, #12
 8000cba:	881a      	ldrh	r2, [r3, #0]
 8000cbc:	23c0      	movs	r3, #192	; 0xc0
 8000cbe:	00db      	lsls	r3, r3, #3
 8000cc0:	4013      	ands	r3, r2
 8000cc2:	b29b      	uxth	r3, r3
 8000cc4:	08db      	lsrs	r3, r3, #3
 8000cc6:	b29b      	uxth	r3, r3
 8000cc8:	b2d9      	uxtb	r1, r3
 8000cca:	466b      	mov	r3, sp
 8000ccc:	330b      	adds	r3, #11
 8000cce:	466a      	mov	r2, sp
 8000cd0:	320b      	adds	r2, #11
 8000cd2:	7812      	ldrb	r2, [r2, #0]
 8000cd4:	430a      	orrs	r2, r1
 8000cd6:	701a      	strb	r2, [r3, #0]
			if(portSample != 0x00)//if its different send
 8000cd8:	466b      	mov	r3, sp
 8000cda:	330b      	adds	r3, #11
 8000cdc:	781b      	ldrb	r3, [r3, #0]
 8000cde:	2b00      	cmp	r3, #0
 8000ce0:	d019      	beq.n	8000d16 <main+0x116>
			{
				prepareForSend(packet, portSample);
 8000ce2:	aa01      	add	r2, sp, #4
 8000ce4:	466b      	mov	r3, sp
 8000ce6:	330b      	adds	r3, #11
 8000ce8:	781b      	ldrb	r3, [r3, #0]
 8000cea:	1c10      	adds	r0, r2, #0
 8000cec:	1c19      	adds	r1, r3, #0
 8000cee:	f7ff ff07 	bl	8000b00 <prepareForSend.7271.4018>
				sdWrite(&SD1, (uint8_t *)packet, 7);
 8000cf2:	4916      	ldr	r1, [pc, #88]	; (8000d4c <main+0x14c>)
 8000cf4:	aa01      	add	r2, sp, #4
 8000cf6:	4b16      	ldr	r3, [pc, #88]	; (8000d50 <main+0x150>)
 8000cf8:	1c08      	adds	r0, r1, #0
 8000cfa:	1c11      	adds	r1, r2, #0
 8000cfc:	2207      	movs	r2, #7
 8000cfe:	f001 f9d7 	bl	80020b0 <oqWriteTimeout>
				//chThdSleepMilliseconds(100);
				for(j = 0; j < 100000; j++)
 8000d02:	2300      	movs	r3, #0
 8000d04:	9300      	str	r3, [sp, #0]
 8000d06:	e002      	b.n	8000d0e <main+0x10e>
 8000d08:	9b00      	ldr	r3, [sp, #0]
 8000d0a:	3301      	adds	r3, #1
 8000d0c:	9300      	str	r3, [sp, #0]
 8000d0e:	9a00      	ldr	r2, [sp, #0]
 8000d10:	4b10      	ldr	r3, [pc, #64]	; (8000d54 <main+0x154>)
 8000d12:	429a      	cmp	r2, r3
 8000d14:	ddf8      	ble.n	8000d08 <main+0x108>
	volatile long j;
	uint8_t i;
	while(!0)
	{
		sdStart(&SD1,NULL);
		for(i = 0; i < 50U; i++)/*Send button five times, why five ?*/
 8000d16:	466b      	mov	r3, sp
 8000d18:	330f      	adds	r3, #15
 8000d1a:	781a      	ldrb	r2, [r3, #0]
 8000d1c:	466b      	mov	r3, sp
 8000d1e:	330f      	adds	r3, #15
 8000d20:	3201      	adds	r2, #1
 8000d22:	701a      	strb	r2, [r3, #0]
 8000d24:	466b      	mov	r3, sp
 8000d26:	330f      	adds	r3, #15
 8000d28:	781b      	ldrb	r3, [r3, #0]
 8000d2a:	2b31      	cmp	r3, #49	; 0x31
 8000d2c:	d99c      	bls.n	8000c68 <main+0x68>
				//chThdSleepMilliseconds(100);
				for(j = 0; j < 100000; j++)
					;
			}
		}
		sdStop(&SD1);
 8000d2e:	4b06      	ldr	r3, [pc, #24]	; (8000d48 <main+0x148>)
 8000d30:	1c18      	adds	r0, r3, #0
 8000d32:	f000 f995 	bl	8001060 <sdStop>
		sleep();
 8000d36:	f7ff ff1b 	bl	8000b70 <sleep.7277.4016>
 8000d3a:	e78b      	b.n	8000c54 <main+0x54>
 8000d3c:	20000450 	.word	0x20000450
 8000d40:	08003100 	.word	0x08003100
 8000d44:	000006f3 	.word	0x000006f3
 8000d48:	20000458 	.word	0x20000458
 8000d4c:	20000488 	.word	0x20000488
 8000d50:	0000ffff 	.word	0x0000ffff
 8000d54:	0001869f 	.word	0x0001869f
 8000d58:	46c0      	nop			; (mov r8, r8)
 8000d5a:	46c0      	nop			; (mov r8, r8)
 8000d5c:	46c0      	nop			; (mov r8, r8)
 8000d5e:	46c0      	nop			; (mov r8, r8)

08000d60 <extChannelEnable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be enabled
 *
 * @api
 */
void extChannelEnable(EXTDriver *extp, expchannel_t channel) {
 8000d60:	b500      	push	{lr}
 8000d62:	b083      	sub	sp, #12
 8000d64:	9001      	str	r0, [sp, #4]
 8000d66:	9100      	str	r1, [sp, #0]

  osalDbgCheck((extp != NULL) && (channel < (expchannel_t)EXT_MAX_CHANNELS));

  osalSysLock();
 8000d68:	f001 fa1a 	bl	80021a0 <osalSysLock.6238>
  osalDbgAssert((extp->state == EXT_ACTIVE) &&
                ((extp->config->channels[channel].mode &
                  EXT_CH_MODE_EDGES_MASK) != EXT_CH_MODE_DISABLED),
                "invalid state");
  extChannelEnableI(extp, channel);
 8000d6c:	9a01      	ldr	r2, [sp, #4]
 8000d6e:	9b00      	ldr	r3, [sp, #0]
 8000d70:	1c10      	adds	r0, r2, #0
 8000d72:	1c19      	adds	r1, r3, #0
 8000d74:	f000 fbac 	bl	80014d0 <ext_lld_channel_enable.4044>
  osalSysUnlock();
 8000d78:	f001 fa1a 	bl	80021b0 <osalSysUnlock.6240>
}
 8000d7c:	b003      	add	sp, #12
 8000d7e:	bd00      	pop	{pc}

08000d80 <port_lock.6410.4319>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d80:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8000d82:	4770      	bx	lr
 8000d84:	46c0      	nop			; (mov r8, r8)
 8000d86:	46c0      	nop			; (mov r8, r8)
 8000d88:	46c0      	nop			; (mov r8, r8)
 8000d8a:	46c0      	nop			; (mov r8, r8)
 8000d8c:	46c0      	nop			; (mov r8, r8)
 8000d8e:	46c0      	nop			; (mov r8, r8)

08000d90 <port_unlock.6413.4317>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d90:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8000d92:	4770      	bx	lr
 8000d94:	46c0      	nop			; (mov r8, r8)
 8000d96:	46c0      	nop			; (mov r8, r8)
 8000d98:	46c0      	nop			; (mov r8, r8)
 8000d9a:	46c0      	nop			; (mov r8, r8)
 8000d9c:	46c0      	nop			; (mov r8, r8)
 8000d9e:	46c0      	nop			; (mov r8, r8)

08000da0 <chSysLock.6415.4315>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8000da0:	b508      	push	{r3, lr}

  port_lock();
 8000da2:	f7ff ffed 	bl	8000d80 <port_lock.6410.4319>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8000da6:	bd08      	pop	{r3, pc}
 8000da8:	46c0      	nop			; (mov r8, r8)
 8000daa:	46c0      	nop			; (mov r8, r8)
 8000dac:	46c0      	nop			; (mov r8, r8)
 8000dae:	46c0      	nop			; (mov r8, r8)

08000db0 <chSysUnlock.6417.4313>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000db0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8000db2:	f7ff ffed 	bl	8000d90 <port_unlock.6413.4317>
}
 8000db6:	bd08      	pop	{r3, pc}
 8000db8:	46c0      	nop			; (mov r8, r8)
 8000dba:	46c0      	nop			; (mov r8, r8)
 8000dbc:	46c0      	nop			; (mov r8, r8)
 8000dbe:	46c0      	nop			; (mov r8, r8)

08000dc0 <osalSysLock.6419.4311>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000dc0:	b508      	push	{r3, lr}

  chSysLock();
 8000dc2:	f7ff ffed 	bl	8000da0 <chSysLock.6415.4315>
}
 8000dc6:	bd08      	pop	{r3, pc}
 8000dc8:	46c0      	nop			; (mov r8, r8)
 8000dca:	46c0      	nop			; (mov r8, r8)
 8000dcc:	46c0      	nop			; (mov r8, r8)
 8000dce:	46c0      	nop			; (mov r8, r8)

08000dd0 <osalSysUnlock.6421.4309>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8000dd0:	b508      	push	{r3, lr}

  chSysUnlock();
 8000dd2:	f7ff ffed 	bl	8000db0 <chSysUnlock.6417.4313>
}
 8000dd6:	bd08      	pop	{r3, pc}
 8000dd8:	46c0      	nop			; (mov r8, r8)
 8000dda:	46c0      	nop			; (mov r8, r8)
 8000ddc:	46c0      	nop			; (mov r8, r8)
 8000dde:	46c0      	nop			; (mov r8, r8)

08000de0 <osalOsRescheduleS.6483.4307>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 8000de0:	b508      	push	{r3, lr}

  chSchRescheduleS();
 8000de2:	f001 ff45 	bl	8002c70 <chSchRescheduleS>
}
 8000de6:	bd08      	pop	{r3, pc}
 8000de8:	46c0      	nop			; (mov r8, r8)
 8000dea:	46c0      	nop			; (mov r8, r8)
 8000dec:	46c0      	nop			; (mov r8, r8)
 8000dee:	46c0      	nop			; (mov r8, r8)

08000df0 <osalEventObjectInit.6423.4304>:
static inline void osalEventObjectInit(event_source_t *esp) {

  chEvtObjectInit(esp);
}
#else
static inline void osalEventObjectInit(event_source_t *esp) {
 8000df0:	b082      	sub	sp, #8
 8000df2:	9001      	str	r0, [sp, #4]

  esp->flags = 0;
 8000df4:	9b01      	ldr	r3, [sp, #4]
 8000df6:	2200      	movs	r2, #0
 8000df8:	601a      	str	r2, [r3, #0]
}
 8000dfa:	b002      	add	sp, #8
 8000dfc:	4770      	bx	lr
 8000dfe:	46c0      	nop			; (mov r8, r8)

08000e00 <osalEventBroadcastFlagsI.6432.4300>:

  chEvtBroadcastFlagsI(esp, flags);
}
#else
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8000e00:	b082      	sub	sp, #8
 8000e02:	9001      	str	r0, [sp, #4]
 8000e04:	9100      	str	r1, [sp, #0]

  esp->flags |= flags;
 8000e06:	9b01      	ldr	r3, [sp, #4]
 8000e08:	681a      	ldr	r2, [r3, #0]
 8000e0a:	9b00      	ldr	r3, [sp, #0]
 8000e0c:	431a      	orrs	r2, r3
 8000e0e:	9b01      	ldr	r3, [sp, #4]
 8000e10:	601a      	str	r2, [r3, #0]
}
 8000e12:	b002      	add	sp, #8
 8000e14:	4770      	bx	lr
 8000e16:	46c0      	nop			; (mov r8, r8)
 8000e18:	46c0      	nop			; (mov r8, r8)
 8000e1a:	46c0      	nop			; (mov r8, r8)
 8000e1c:	46c0      	nop			; (mov r8, r8)
 8000e1e:	46c0      	nop			; (mov r8, r8)

08000e20 <write.6436>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8000e20:	b500      	push	{lr}
 8000e22:	b085      	sub	sp, #20
 8000e24:	9003      	str	r0, [sp, #12]
 8000e26:	9102      	str	r1, [sp, #8]
 8000e28:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000e2a:	9b03      	ldr	r3, [sp, #12]
 8000e2c:	1c18      	adds	r0, r3, #0
 8000e2e:	3030      	adds	r0, #48	; 0x30
 8000e30:	9902      	ldr	r1, [sp, #8]
 8000e32:	9a01      	ldr	r2, [sp, #4]
 8000e34:	4b03      	ldr	r3, [pc, #12]	; (8000e44 <write.6436+0x24>)
 8000e36:	f001 f93b 	bl	80020b0 <oqWriteTimeout>
 8000e3a:	1c03      	adds	r3, r0, #0
                        n, TIME_INFINITE);
}
 8000e3c:	1c18      	adds	r0, r3, #0
 8000e3e:	b005      	add	sp, #20
 8000e40:	bd00      	pop	{pc}
 8000e42:	46c0      	nop			; (mov r8, r8)
 8000e44:	0000ffff 	.word	0x0000ffff
 8000e48:	46c0      	nop			; (mov r8, r8)
 8000e4a:	46c0      	nop			; (mov r8, r8)
 8000e4c:	46c0      	nop			; (mov r8, r8)
 8000e4e:	46c0      	nop			; (mov r8, r8)

08000e50 <read.6453>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8000e50:	b500      	push	{lr}
 8000e52:	b085      	sub	sp, #20
 8000e54:	9003      	str	r0, [sp, #12]
 8000e56:	9102      	str	r1, [sp, #8]
 8000e58:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000e5a:	9b03      	ldr	r3, [sp, #12]
 8000e5c:	1c18      	adds	r0, r3, #0
 8000e5e:	300c      	adds	r0, #12
 8000e60:	9902      	ldr	r1, [sp, #8]
 8000e62:	9a01      	ldr	r2, [sp, #4]
 8000e64:	4b03      	ldr	r3, [pc, #12]	; (8000e74 <read.6453+0x24>)
 8000e66:	f000 fffb 	bl	8001e60 <iqReadTimeout>
 8000e6a:	1c03      	adds	r3, r0, #0
                       n, TIME_INFINITE);
}
 8000e6c:	1c18      	adds	r0, r3, #0
 8000e6e:	b005      	add	sp, #20
 8000e70:	bd00      	pop	{pc}
 8000e72:	46c0      	nop			; (mov r8, r8)
 8000e74:	0000ffff 	.word	0x0000ffff
 8000e78:	46c0      	nop			; (mov r8, r8)
 8000e7a:	46c0      	nop			; (mov r8, r8)
 8000e7c:	46c0      	nop			; (mov r8, r8)
 8000e7e:	46c0      	nop			; (mov r8, r8)

08000e80 <put.6464>:

static msg_t put(void *ip, uint8_t b) {
 8000e80:	b500      	push	{lr}
 8000e82:	b083      	sub	sp, #12
 8000e84:	9001      	str	r0, [sp, #4]
 8000e86:	1c0a      	adds	r2, r1, #0
 8000e88:	466b      	mov	r3, sp
 8000e8a:	3303      	adds	r3, #3
 8000e8c:	701a      	strb	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000e8e:	9b01      	ldr	r3, [sp, #4]
 8000e90:	1c19      	adds	r1, r3, #0
 8000e92:	3130      	adds	r1, #48	; 0x30
 8000e94:	466b      	mov	r3, sp
 8000e96:	3303      	adds	r3, #3
 8000e98:	781a      	ldrb	r2, [r3, #0]
 8000e9a:	4b05      	ldr	r3, [pc, #20]	; (8000eb0 <put.6464+0x30>)
 8000e9c:	1c08      	adds	r0, r1, #0
 8000e9e:	1c11      	adds	r1, r2, #0
 8000ea0:	1c1a      	adds	r2, r3, #0
 8000ea2:	f001 f87d 	bl	8001fa0 <oqPutTimeout>
 8000ea6:	1c03      	adds	r3, r0, #0
}
 8000ea8:	1c18      	adds	r0, r3, #0
 8000eaa:	b003      	add	sp, #12
 8000eac:	bd00      	pop	{pc}
 8000eae:	46c0      	nop			; (mov r8, r8)
 8000eb0:	0000ffff 	.word	0x0000ffff
 8000eb4:	46c0      	nop			; (mov r8, r8)
 8000eb6:	46c0      	nop			; (mov r8, r8)
 8000eb8:	46c0      	nop			; (mov r8, r8)
 8000eba:	46c0      	nop			; (mov r8, r8)
 8000ebc:	46c0      	nop			; (mov r8, r8)
 8000ebe:	46c0      	nop			; (mov r8, r8)

08000ec0 <get.6476>:

static msg_t get(void *ip) {
 8000ec0:	b500      	push	{lr}
 8000ec2:	b083      	sub	sp, #12
 8000ec4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000ec6:	9b01      	ldr	r3, [sp, #4]
 8000ec8:	1c1a      	adds	r2, r3, #0
 8000eca:	320c      	adds	r2, #12
 8000ecc:	4b04      	ldr	r3, [pc, #16]	; (8000ee0 <get.6476+0x20>)
 8000ece:	1c10      	adds	r0, r2, #0
 8000ed0:	1c19      	adds	r1, r3, #0
 8000ed2:	f000 ff7d 	bl	8001dd0 <iqGetTimeout>
 8000ed6:	1c03      	adds	r3, r0, #0
}
 8000ed8:	1c18      	adds	r0, r3, #0
 8000eda:	b003      	add	sp, #12
 8000edc:	bd00      	pop	{pc}
 8000ede:	46c0      	nop			; (mov r8, r8)
 8000ee0:	0000ffff 	.word	0x0000ffff
 8000ee4:	46c0      	nop			; (mov r8, r8)
 8000ee6:	46c0      	nop			; (mov r8, r8)
 8000ee8:	46c0      	nop			; (mov r8, r8)
 8000eea:	46c0      	nop			; (mov r8, r8)
 8000eec:	46c0      	nop			; (mov r8, r8)
 8000eee:	46c0      	nop			; (mov r8, r8)

08000ef0 <putt.6471>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8000ef0:	b500      	push	{lr}
 8000ef2:	b083      	sub	sp, #12
 8000ef4:	9001      	str	r0, [sp, #4]
 8000ef6:	466b      	mov	r3, sp
 8000ef8:	3303      	adds	r3, #3
 8000efa:	7019      	strb	r1, [r3, #0]
 8000efc:	466b      	mov	r3, sp
 8000efe:	801a      	strh	r2, [r3, #0]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000f00:	9b01      	ldr	r3, [sp, #4]
 8000f02:	1c19      	adds	r1, r3, #0
 8000f04:	3130      	adds	r1, #48	; 0x30
 8000f06:	466b      	mov	r3, sp
 8000f08:	3303      	adds	r3, #3
 8000f0a:	781a      	ldrb	r2, [r3, #0]
 8000f0c:	466b      	mov	r3, sp
 8000f0e:	881b      	ldrh	r3, [r3, #0]
 8000f10:	1c08      	adds	r0, r1, #0
 8000f12:	1c11      	adds	r1, r2, #0
 8000f14:	1c1a      	adds	r2, r3, #0
 8000f16:	f001 f843 	bl	8001fa0 <oqPutTimeout>
 8000f1a:	1c03      	adds	r3, r0, #0
}
 8000f1c:	1c18      	adds	r0, r3, #0
 8000f1e:	b003      	add	sp, #12
 8000f20:	bd00      	pop	{pc}
 8000f22:	46c0      	nop			; (mov r8, r8)
 8000f24:	46c0      	nop			; (mov r8, r8)
 8000f26:	46c0      	nop			; (mov r8, r8)
 8000f28:	46c0      	nop			; (mov r8, r8)
 8000f2a:	46c0      	nop			; (mov r8, r8)
 8000f2c:	46c0      	nop			; (mov r8, r8)
 8000f2e:	46c0      	nop			; (mov r8, r8)

08000f30 <gett.6479>:

static msg_t gett(void *ip, systime_t timeout) {
 8000f30:	b500      	push	{lr}
 8000f32:	b083      	sub	sp, #12
 8000f34:	9001      	str	r0, [sp, #4]
 8000f36:	1c0a      	adds	r2, r1, #0
 8000f38:	466b      	mov	r3, sp
 8000f3a:	3302      	adds	r3, #2
 8000f3c:	801a      	strh	r2, [r3, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000f3e:	9b01      	ldr	r3, [sp, #4]
 8000f40:	1c1a      	adds	r2, r3, #0
 8000f42:	320c      	adds	r2, #12
 8000f44:	466b      	mov	r3, sp
 8000f46:	3302      	adds	r3, #2
 8000f48:	881b      	ldrh	r3, [r3, #0]
 8000f4a:	1c10      	adds	r0, r2, #0
 8000f4c:	1c19      	adds	r1, r3, #0
 8000f4e:	f000 ff3f 	bl	8001dd0 <iqGetTimeout>
 8000f52:	1c03      	adds	r3, r0, #0
}
 8000f54:	1c18      	adds	r0, r3, #0
 8000f56:	b003      	add	sp, #12
 8000f58:	bd00      	pop	{pc}
 8000f5a:	46c0      	nop			; (mov r8, r8)
 8000f5c:	46c0      	nop			; (mov r8, r8)
 8000f5e:	46c0      	nop			; (mov r8, r8)

08000f60 <writet.6444>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8000f60:	b500      	push	{lr}
 8000f62:	b085      	sub	sp, #20
 8000f64:	9003      	str	r0, [sp, #12]
 8000f66:	9102      	str	r1, [sp, #8]
 8000f68:	9201      	str	r2, [sp, #4]
 8000f6a:	1c1a      	adds	r2, r3, #0
 8000f6c:	466b      	mov	r3, sp
 8000f6e:	3302      	adds	r3, #2
 8000f70:	801a      	strh	r2, [r3, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000f72:	9b03      	ldr	r3, [sp, #12]
 8000f74:	1c18      	adds	r0, r3, #0
 8000f76:	3030      	adds	r0, #48	; 0x30
 8000f78:	9902      	ldr	r1, [sp, #8]
 8000f7a:	9a01      	ldr	r2, [sp, #4]
 8000f7c:	466b      	mov	r3, sp
 8000f7e:	3302      	adds	r3, #2
 8000f80:	881b      	ldrh	r3, [r3, #0]
 8000f82:	f001 f895 	bl	80020b0 <oqWriteTimeout>
 8000f86:	1c03      	adds	r3, r0, #0
}
 8000f88:	1c18      	adds	r0, r3, #0
 8000f8a:	b005      	add	sp, #20
 8000f8c:	bd00      	pop	{pc}
 8000f8e:	46c0      	nop			; (mov r8, r8)

08000f90 <readt.6458>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8000f90:	b500      	push	{lr}
 8000f92:	b085      	sub	sp, #20
 8000f94:	9003      	str	r0, [sp, #12]
 8000f96:	9102      	str	r1, [sp, #8]
 8000f98:	9201      	str	r2, [sp, #4]
 8000f9a:	1c1a      	adds	r2, r3, #0
 8000f9c:	466b      	mov	r3, sp
 8000f9e:	3302      	adds	r3, #2
 8000fa0:	801a      	strh	r2, [r3, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000fa2:	9b03      	ldr	r3, [sp, #12]
 8000fa4:	1c18      	adds	r0, r3, #0
 8000fa6:	300c      	adds	r0, #12
 8000fa8:	9902      	ldr	r1, [sp, #8]
 8000faa:	9a01      	ldr	r2, [sp, #4]
 8000fac:	466b      	mov	r3, sp
 8000fae:	3302      	adds	r3, #2
 8000fb0:	881b      	ldrh	r3, [r3, #0]
 8000fb2:	f000 ff55 	bl	8001e60 <iqReadTimeout>
 8000fb6:	1c03      	adds	r3, r0, #0
}
 8000fb8:	1c18      	adds	r0, r3, #0
 8000fba:	b005      	add	sp, #20
 8000fbc:	bd00      	pop	{pc}
 8000fbe:	46c0      	nop			; (mov r8, r8)

08000fc0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8000fc0:	b508      	push	{r3, lr}

  sd_lld_init();
 8000fc2:	f7ff fc25 	bl	8000810 <sd_lld_init>
}
 8000fc6:	bd08      	pop	{r3, pc}
 8000fc8:	46c0      	nop			; (mov r8, r8)
 8000fca:	46c0      	nop			; (mov r8, r8)
 8000fcc:	46c0      	nop			; (mov r8, r8)
 8000fce:	46c0      	nop			; (mov r8, r8)

08000fd0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000fd0:	b500      	push	{lr}
 8000fd2:	b087      	sub	sp, #28
 8000fd4:	9005      	str	r0, [sp, #20]
 8000fd6:	9104      	str	r1, [sp, #16]
 8000fd8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 8000fda:	9b05      	ldr	r3, [sp, #20]
 8000fdc:	4a13      	ldr	r2, [pc, #76]	; (800102c <sdObjectInit+0x5c>)
 8000fde:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8000fe0:	9b05      	ldr	r3, [sp, #20]
 8000fe2:	3304      	adds	r3, #4
 8000fe4:	1c18      	adds	r0, r3, #0
 8000fe6:	f7ff ff03 	bl	8000df0 <osalEventObjectInit.6423.4304>
  sdp->state = SD_STOP;
 8000fea:	9b05      	ldr	r3, [sp, #20]
 8000fec:	2201      	movs	r2, #1
 8000fee:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000ff0:	9b05      	ldr	r3, [sp, #20]
 8000ff2:	1c19      	adds	r1, r3, #0
 8000ff4:	310c      	adds	r1, #12
 8000ff6:	9b05      	ldr	r3, [sp, #20]
 8000ff8:	1c1a      	adds	r2, r3, #0
 8000ffa:	3254      	adds	r2, #84	; 0x54
 8000ffc:	9b04      	ldr	r3, [sp, #16]
 8000ffe:	9805      	ldr	r0, [sp, #20]
 8001000:	9000      	str	r0, [sp, #0]
 8001002:	1c08      	adds	r0, r1, #0
 8001004:	1c11      	adds	r1, r2, #0
 8001006:	2210      	movs	r2, #16
 8001008:	f000 fe62 	bl	8001cd0 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 800100c:	9b05      	ldr	r3, [sp, #20]
 800100e:	1c19      	adds	r1, r3, #0
 8001010:	3130      	adds	r1, #48	; 0x30
 8001012:	9b05      	ldr	r3, [sp, #20]
 8001014:	1c1a      	adds	r2, r3, #0
 8001016:	3264      	adds	r2, #100	; 0x64
 8001018:	9b03      	ldr	r3, [sp, #12]
 800101a:	9805      	ldr	r0, [sp, #20]
 800101c:	9000      	str	r0, [sp, #0]
 800101e:	1c08      	adds	r0, r1, #0
 8001020:	1c11      	adds	r1, r2, #0
 8001022:	2210      	movs	r2, #16
 8001024:	f000 ff74 	bl	8001f10 <oqObjectInit>
}
 8001028:	b007      	add	sp, #28
 800102a:	bd00      	pop	{pc}
 800102c:	08003060 	.word	0x08003060

08001030 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8001030:	b500      	push	{lr}
 8001032:	b083      	sub	sp, #12
 8001034:	9001      	str	r0, [sp, #4]
 8001036:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8001038:	f7ff fec2 	bl	8000dc0 <osalSysLock.6419.4311>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800103c:	9a01      	ldr	r2, [sp, #4]
 800103e:	9b00      	ldr	r3, [sp, #0]
 8001040:	1c10      	adds	r0, r2, #0
 8001042:	1c19      	adds	r1, r3, #0
 8001044:	f7ff fc04 	bl	8000850 <sd_lld_start>
  sdp->state = SD_READY;
 8001048:	9b01      	ldr	r3, [sp, #4]
 800104a:	2202      	movs	r2, #2
 800104c:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800104e:	f7ff febf 	bl	8000dd0 <osalSysUnlock.6421.4309>
}
 8001052:	b003      	add	sp, #12
 8001054:	bd00      	pop	{pc}
 8001056:	46c0      	nop			; (mov r8, r8)
 8001058:	46c0      	nop			; (mov r8, r8)
 800105a:	46c0      	nop			; (mov r8, r8)
 800105c:	46c0      	nop			; (mov r8, r8)
 800105e:	46c0      	nop			; (mov r8, r8)

08001060 <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
 8001060:	b500      	push	{lr}
 8001062:	b083      	sub	sp, #12
 8001064:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8001066:	f7ff feab 	bl	8000dc0 <osalSysLock.6419.4311>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_stop(sdp);
 800106a:	9b01      	ldr	r3, [sp, #4]
 800106c:	1c18      	adds	r0, r3, #0
 800106e:	f7ff fc17 	bl	80008a0 <sd_lld_stop>
  sdp->state = SD_STOP;
 8001072:	9b01      	ldr	r3, [sp, #4]
 8001074:	2201      	movs	r2, #1
 8001076:	721a      	strb	r2, [r3, #8]
  oqResetI(&sdp->oqueue);
 8001078:	9b01      	ldr	r3, [sp, #4]
 800107a:	3330      	adds	r3, #48	; 0x30
 800107c:	1c18      	adds	r0, r3, #0
 800107e:	f000 ff6f 	bl	8001f60 <oqResetI>
  iqResetI(&sdp->iqueue);
 8001082:	9b01      	ldr	r3, [sp, #4]
 8001084:	330c      	adds	r3, #12
 8001086:	1c18      	adds	r0, r3, #0
 8001088:	f000 fe4a 	bl	8001d20 <iqResetI>
  osalOsRescheduleS();
 800108c:	f7ff fea8 	bl	8000de0 <osalOsRescheduleS.6483.4307>
  osalSysUnlock();
 8001090:	f7ff fe9e 	bl	8000dd0 <osalSysUnlock.6421.4309>
}
 8001094:	b003      	add	sp, #12
 8001096:	bd00      	pop	{pc}
 8001098:	46c0      	nop			; (mov r8, r8)
 800109a:	46c0      	nop			; (mov r8, r8)
 800109c:	46c0      	nop			; (mov r8, r8)
 800109e:	46c0      	nop			; (mov r8, r8)

080010a0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 80010a0:	b500      	push	{lr}
 80010a2:	b083      	sub	sp, #12
 80010a4:	9001      	str	r0, [sp, #4]
 80010a6:	1c0a      	adds	r2, r1, #0
 80010a8:	466b      	mov	r3, sp
 80010aa:	3303      	adds	r3, #3
 80010ac:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80010ae:	9b01      	ldr	r3, [sp, #4]
 80010b0:	695b      	ldr	r3, [r3, #20]
 80010b2:	2b00      	cmp	r3, #0
 80010b4:	d105      	bne.n	80010c2 <sdIncomingDataI+0x22>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 80010b6:	9b01      	ldr	r3, [sp, #4]
 80010b8:	3304      	adds	r3, #4
 80010ba:	1c18      	adds	r0, r3, #0
 80010bc:	2104      	movs	r1, #4
 80010be:	f7ff fe9f 	bl	8000e00 <osalEventBroadcastFlagsI.6432.4300>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 80010c2:	9b01      	ldr	r3, [sp, #4]
 80010c4:	1c1a      	adds	r2, r3, #0
 80010c6:	320c      	adds	r2, #12
 80010c8:	466b      	mov	r3, sp
 80010ca:	3303      	adds	r3, #3
 80010cc:	781b      	ldrb	r3, [r3, #0]
 80010ce:	1c10      	adds	r0, r2, #0
 80010d0:	1c19      	adds	r1, r3, #0
 80010d2:	f000 fe3d 	bl	8001d50 <iqPutI>
 80010d6:	1c03      	adds	r3, r0, #0
 80010d8:	2b00      	cmp	r3, #0
 80010da:	da05      	bge.n	80010e8 <sdIncomingDataI+0x48>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80010dc:	9b01      	ldr	r3, [sp, #4]
 80010de:	3304      	adds	r3, #4
 80010e0:	1c18      	adds	r0, r3, #0
 80010e2:	2180      	movs	r1, #128	; 0x80
 80010e4:	f7ff fe8c 	bl	8000e00 <osalEventBroadcastFlagsI.6432.4300>
}
 80010e8:	b003      	add	sp, #12
 80010ea:	bd00      	pop	{pc}
 80010ec:	46c0      	nop			; (mov r8, r8)
 80010ee:	46c0      	nop			; (mov r8, r8)

080010f0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 80010f0:	b530      	push	{r4, r5, lr}
 80010f2:	b083      	sub	sp, #12
 80010f4:	9001      	str	r0, [sp, #4]
 80010f6:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 80010f8:	4b1d      	ldr	r3, [pc, #116]	; (8001170 <nvicEnableVector+0x80>)
 80010fa:	9a01      	ldr	r2, [sp, #4]
 80010fc:	0892      	lsrs	r2, r2, #2
 80010fe:	491c      	ldr	r1, [pc, #112]	; (8001170 <nvicEnableVector+0x80>)
 8001100:	9801      	ldr	r0, [sp, #4]
 8001102:	0880      	lsrs	r0, r0, #2
 8001104:	30c0      	adds	r0, #192	; 0xc0
 8001106:	0080      	lsls	r0, r0, #2
 8001108:	5841      	ldr	r1, [r0, r1]
 800110a:	9c01      	ldr	r4, [sp, #4]
 800110c:	2003      	movs	r0, #3
 800110e:	4020      	ands	r0, r4
 8001110:	00c0      	lsls	r0, r0, #3
 8001112:	24ff      	movs	r4, #255	; 0xff
 8001114:	1c25      	adds	r5, r4, #0
 8001116:	4085      	lsls	r5, r0
 8001118:	1c28      	adds	r0, r5, #0
 800111a:	43c0      	mvns	r0, r0
 800111c:	4008      	ands	r0, r1
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 800111e:	9900      	ldr	r1, [sp, #0]
 8001120:	018c      	lsls	r4, r1, #6
 8001122:	9d01      	ldr	r5, [sp, #4]
 8001124:	2103      	movs	r1, #3
 8001126:	4029      	ands	r1, r5
 8001128:	00c9      	lsls	r1, r1, #3
 800112a:	1c25      	adds	r5, r4, #0
 800112c:	408d      	lsls	r5, r1
 800112e:	1c29      	adds	r1, r5, #0
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001130:	4301      	orrs	r1, r0
 8001132:	32c0      	adds	r2, #192	; 0xc0
 8001134:	0092      	lsls	r2, r2, #2
 8001136:	50d1      	str	r1, [r2, r3]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001138:	4b0d      	ldr	r3, [pc, #52]	; (8001170 <nvicEnableVector+0x80>)
 800113a:	9a01      	ldr	r2, [sp, #4]
 800113c:	0952      	lsrs	r2, r2, #5
 800113e:	9801      	ldr	r0, [sp, #4]
 8001140:	211f      	movs	r1, #31
 8001142:	4001      	ands	r1, r0
 8001144:	2001      	movs	r0, #1
 8001146:	1c04      	adds	r4, r0, #0
 8001148:	408c      	lsls	r4, r1
 800114a:	1c21      	adds	r1, r4, #0
 800114c:	3260      	adds	r2, #96	; 0x60
 800114e:	0092      	lsls	r2, r2, #2
 8001150:	50d1      	str	r1, [r2, r3]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001152:	4b07      	ldr	r3, [pc, #28]	; (8001170 <nvicEnableVector+0x80>)
 8001154:	9a01      	ldr	r2, [sp, #4]
 8001156:	0952      	lsrs	r2, r2, #5
 8001158:	9801      	ldr	r0, [sp, #4]
 800115a:	211f      	movs	r1, #31
 800115c:	4001      	ands	r1, r0
 800115e:	2001      	movs	r0, #1
 8001160:	1c05      	adds	r5, r0, #0
 8001162:	408d      	lsls	r5, r1
 8001164:	1c29      	adds	r1, r5, #0
 8001166:	0092      	lsls	r2, r2, #2
 8001168:	50d1      	str	r1, [r2, r3]
}
 800116a:	b003      	add	sp, #12
 800116c:	bd30      	pop	{r4, r5, pc}
 800116e:	46c0      	nop			; (mov r8, r8)
 8001170:	e000e100 	.word	0xe000e100
 8001174:	46c0      	nop			; (mov r8, r8)
 8001176:	46c0      	nop			; (mov r8, r8)
 8001178:	46c0      	nop			; (mov r8, r8)
 800117a:	46c0      	nop			; (mov r8, r8)
 800117c:	46c0      	nop			; (mov r8, r8)
 800117e:	46c0      	nop			; (mov r8, r8)

08001180 <hal_lld_backup_domain_init.6702.4084>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001180:	4b15      	ldr	r3, [pc, #84]	; (80011d8 <hal_lld_backup_domain_init.6702.4084+0x58>)
 8001182:	4a15      	ldr	r2, [pc, #84]	; (80011d8 <hal_lld_backup_domain_init.6702.4084+0x58>)
 8001184:	6812      	ldr	r2, [r2, #0]
 8001186:	2180      	movs	r1, #128	; 0x80
 8001188:	0049      	lsls	r1, r1, #1
 800118a:	430a      	orrs	r2, r1
 800118c:	601a      	str	r2, [r3, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 800118e:	4b13      	ldr	r3, [pc, #76]	; (80011dc <hal_lld_backup_domain_init.6702.4084+0x5c>)
 8001190:	6a1a      	ldr	r2, [r3, #32]
 8001192:	23c0      	movs	r3, #192	; 0xc0
 8001194:	009b      	lsls	r3, r3, #2
 8001196:	401a      	ands	r2, r3
 8001198:	2380      	movs	r3, #128	; 0x80
 800119a:	009b      	lsls	r3, r3, #2
 800119c:	429a      	cmp	r2, r3
 800119e:	d006      	beq.n	80011ae <hal_lld_backup_domain_init.6702.4084+0x2e>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80011a0:	4b0e      	ldr	r3, [pc, #56]	; (80011dc <hal_lld_backup_domain_init.6702.4084+0x5c>)
 80011a2:	2280      	movs	r2, #128	; 0x80
 80011a4:	0252      	lsls	r2, r2, #9
 80011a6:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 80011a8:	4b0c      	ldr	r3, [pc, #48]	; (80011dc <hal_lld_backup_domain_init.6702.4084+0x5c>)
 80011aa:	2200      	movs	r2, #0
 80011ac:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80011ae:	4b0b      	ldr	r3, [pc, #44]	; (80011dc <hal_lld_backup_domain_init.6702.4084+0x5c>)
 80011b0:	6a1a      	ldr	r2, [r3, #32]
 80011b2:	2380      	movs	r3, #128	; 0x80
 80011b4:	021b      	lsls	r3, r3, #8
 80011b6:	4013      	ands	r3, r2
 80011b8:	d10d      	bne.n	80011d6 <hal_lld_backup_domain_init.6702.4084+0x56>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80011ba:	4b08      	ldr	r3, [pc, #32]	; (80011dc <hal_lld_backup_domain_init.6702.4084+0x5c>)
 80011bc:	4a07      	ldr	r2, [pc, #28]	; (80011dc <hal_lld_backup_domain_init.6702.4084+0x5c>)
 80011be:	6a12      	ldr	r2, [r2, #32]
 80011c0:	2180      	movs	r1, #128	; 0x80
 80011c2:	0089      	lsls	r1, r1, #2
 80011c4:	430a      	orrs	r2, r1
 80011c6:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 80011c8:	4b04      	ldr	r3, [pc, #16]	; (80011dc <hal_lld_backup_domain_init.6702.4084+0x5c>)
 80011ca:	4a04      	ldr	r2, [pc, #16]	; (80011dc <hal_lld_backup_domain_init.6702.4084+0x5c>)
 80011cc:	6a12      	ldr	r2, [r2, #32]
 80011ce:	2180      	movs	r1, #128	; 0x80
 80011d0:	0209      	lsls	r1, r1, #8
 80011d2:	430a      	orrs	r2, r1
 80011d4:	621a      	str	r2, [r3, #32]
  }
#endif /* STM32_RTCSEL != STM32_RTCSEL_NOCLOCK */
}
 80011d6:	4770      	bx	lr
 80011d8:	40007000 	.word	0x40007000
 80011dc:	40021000 	.word	0x40021000

080011e0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80011e0:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80011e2:	4b12      	ldr	r3, [pc, #72]	; (800122c <hal_lld_init+0x4c>)
 80011e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80011e6:	4b11      	ldr	r3, [pc, #68]	; (800122c <hal_lld_init+0x4c>)
 80011e8:	2201      	movs	r2, #1
 80011ea:	4252      	negs	r2, r2
 80011ec:	629a      	str	r2, [r3, #40]	; 0x28
 80011ee:	4b0f      	ldr	r3, [pc, #60]	; (800122c <hal_lld_init+0x4c>)
 80011f0:	2200      	movs	r2, #0
 80011f2:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 80011f4:	4b0d      	ldr	r3, [pc, #52]	; (800122c <hal_lld_init+0x4c>)
 80011f6:	691b      	ldr	r3, [r3, #16]
 80011f8:	4b0c      	ldr	r3, [pc, #48]	; (800122c <hal_lld_init+0x4c>)
 80011fa:	2201      	movs	r2, #1
 80011fc:	4252      	negs	r2, r2
 80011fe:	611a      	str	r2, [r3, #16]
 8001200:	4b0a      	ldr	r3, [pc, #40]	; (800122c <hal_lld_init+0x4c>)
 8001202:	2200      	movs	r2, #0
 8001204:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001206:	4b09      	ldr	r3, [pc, #36]	; (800122c <hal_lld_init+0x4c>)
 8001208:	4a08      	ldr	r2, [pc, #32]	; (800122c <hal_lld_init+0x4c>)
 800120a:	68d2      	ldr	r2, [r2, #12]
 800120c:	4908      	ldr	r1, [pc, #32]	; (8001230 <hal_lld_init+0x50>)
 800120e:	430a      	orrs	r2, r1
 8001210:	60da      	str	r2, [r3, #12]
 8001212:	4b06      	ldr	r3, [pc, #24]	; (800122c <hal_lld_init+0x4c>)
 8001214:	2200      	movs	r2, #0
 8001216:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001218:	4b04      	ldr	r3, [pc, #16]	; (800122c <hal_lld_init+0x4c>)
 800121a:	4a04      	ldr	r2, [pc, #16]	; (800122c <hal_lld_init+0x4c>)
 800121c:	69d2      	ldr	r2, [r2, #28]
 800121e:	2180      	movs	r1, #128	; 0x80
 8001220:	0549      	lsls	r1, r1, #21
 8001222:	430a      	orrs	r2, r1
 8001224:	61da      	str	r2, [r3, #28]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8001226:	f7ff ffab 	bl	8001180 <hal_lld_backup_domain_init.6702.4084>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800122a:	bd08      	pop	{r3, pc}
 800122c:	40021000 	.word	0x40021000
 8001230:	ffbfffff 	.word	0xffbfffff
 8001234:	46c0      	nop			; (mov r8, r8)
 8001236:	46c0      	nop			; (mov r8, r8)
 8001238:	46c0      	nop			; (mov r8, r8)
 800123a:	46c0      	nop			; (mov r8, r8)
 800123c:	46c0      	nop			; (mov r8, r8)
 800123e:	46c0      	nop			; (mov r8, r8)

08001240 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001240:	4b32      	ldr	r3, [pc, #200]	; (800130c <stm32_clock_init+0xcc>)
 8001242:	4a32      	ldr	r2, [pc, #200]	; (800130c <stm32_clock_init+0xcc>)
 8001244:	6812      	ldr	r2, [r2, #0]
 8001246:	2101      	movs	r1, #1
 8001248:	430a      	orrs	r2, r1
 800124a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800124c:	4b2f      	ldr	r3, [pc, #188]	; (800130c <stm32_clock_init+0xcc>)
 800124e:	681a      	ldr	r2, [r3, #0]
 8001250:	2302      	movs	r3, #2
 8001252:	4013      	ands	r3, r2
 8001254:	d0fa      	beq.n	800124c <stm32_clock_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001256:	4b2d      	ldr	r3, [pc, #180]	; (800130c <stm32_clock_init+0xcc>)
 8001258:	4a2c      	ldr	r2, [pc, #176]	; (800130c <stm32_clock_init+0xcc>)
 800125a:	6852      	ldr	r2, [r2, #4]
 800125c:	2103      	movs	r1, #3
 800125e:	438a      	bics	r2, r1
 8001260:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001262:	4b2a      	ldr	r3, [pc, #168]	; (800130c <stm32_clock_init+0xcc>)
 8001264:	4a29      	ldr	r2, [pc, #164]	; (800130c <stm32_clock_init+0xcc>)
 8001266:	6852      	ldr	r2, [r2, #4]
 8001268:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800126a:	4b28      	ldr	r3, [pc, #160]	; (800130c <stm32_clock_init+0xcc>)
 800126c:	685a      	ldr	r2, [r3, #4]
 800126e:	230c      	movs	r3, #12
 8001270:	4013      	ands	r3, r2
 8001272:	d1fa      	bne.n	800126a <stm32_clock_init+0x2a>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001274:	4b25      	ldr	r3, [pc, #148]	; (800130c <stm32_clock_init+0xcc>)
 8001276:	4a25      	ldr	r2, [pc, #148]	; (800130c <stm32_clock_init+0xcc>)
 8001278:	6811      	ldr	r1, [r2, #0]
 800127a:	22f9      	movs	r2, #249	; 0xf9
 800127c:	400a      	ands	r2, r1
 800127e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001280:	4b22      	ldr	r3, [pc, #136]	; (800130c <stm32_clock_init+0xcc>)
 8001282:	2200      	movs	r2, #0
 8001284:	605a      	str	r2, [r3, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001286:	4b21      	ldr	r3, [pc, #132]	; (800130c <stm32_clock_init+0xcc>)
 8001288:	4a20      	ldr	r2, [pc, #128]	; (800130c <stm32_clock_init+0xcc>)
 800128a:	6b52      	ldr	r2, [r2, #52]	; 0x34
 800128c:	2101      	movs	r1, #1
 800128e:	430a      	orrs	r2, r1
 8001290:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8001292:	4b1e      	ldr	r3, [pc, #120]	; (800130c <stm32_clock_init+0xcc>)
 8001294:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001296:	2302      	movs	r3, #2
 8001298:	4013      	ands	r3, r2
 800129a:	d0fa      	beq.n	8001292 <stm32_clock_init+0x52>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800129c:	4b1b      	ldr	r3, [pc, #108]	; (800130c <stm32_clock_init+0xcc>)
 800129e:	4a1b      	ldr	r2, [pc, #108]	; (800130c <stm32_clock_init+0xcc>)
 80012a0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80012a2:	2101      	movs	r1, #1
 80012a4:	430a      	orrs	r2, r1
 80012a6:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80012a8:	4b18      	ldr	r3, [pc, #96]	; (800130c <stm32_clock_init+0xcc>)
 80012aa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80012ac:	2302      	movs	r3, #2
 80012ae:	4013      	ands	r3, r2
 80012b0:	d0fa      	beq.n	80012a8 <stm32_clock_init+0x68>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 80012b2:	4b16      	ldr	r3, [pc, #88]	; (800130c <stm32_clock_init+0xcc>)
 80012b4:	22a0      	movs	r2, #160	; 0xa0
 80012b6:	0392      	lsls	r2, r2, #14
 80012b8:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 80012ba:	4b14      	ldr	r3, [pc, #80]	; (800130c <stm32_clock_init+0xcc>)
 80012bc:	2200      	movs	r2, #0
 80012be:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 80012c0:	4b12      	ldr	r3, [pc, #72]	; (800130c <stm32_clock_init+0xcc>)
 80012c2:	2200      	movs	r2, #0
 80012c4:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80012c6:	4b11      	ldr	r3, [pc, #68]	; (800130c <stm32_clock_init+0xcc>)
 80012c8:	4a10      	ldr	r2, [pc, #64]	; (800130c <stm32_clock_init+0xcc>)
 80012ca:	6812      	ldr	r2, [r2, #0]
 80012cc:	2180      	movs	r1, #128	; 0x80
 80012ce:	0449      	lsls	r1, r1, #17
 80012d0:	430a      	orrs	r2, r1
 80012d2:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80012d4:	4b0d      	ldr	r3, [pc, #52]	; (800130c <stm32_clock_init+0xcc>)
 80012d6:	681a      	ldr	r2, [r3, #0]
 80012d8:	2380      	movs	r3, #128	; 0x80
 80012da:	049b      	lsls	r3, r3, #18
 80012dc:	4013      	ands	r3, r2
 80012de:	d0f9      	beq.n	80012d4 <stm32_clock_init+0x94>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80012e0:	4b0b      	ldr	r3, [pc, #44]	; (8001310 <stm32_clock_init+0xd0>)
 80012e2:	2211      	movs	r2, #17
 80012e4:	601a      	str	r2, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80012e6:	4b09      	ldr	r3, [pc, #36]	; (800130c <stm32_clock_init+0xcc>)
 80012e8:	4a08      	ldr	r2, [pc, #32]	; (800130c <stm32_clock_init+0xcc>)
 80012ea:	6852      	ldr	r2, [r2, #4]
 80012ec:	2102      	movs	r1, #2
 80012ee:	430a      	orrs	r2, r1
 80012f0:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80012f2:	4b06      	ldr	r3, [pc, #24]	; (800130c <stm32_clock_init+0xcc>)
 80012f4:	685a      	ldr	r2, [r3, #4]
 80012f6:	230c      	movs	r3, #12
 80012f8:	4013      	ands	r3, r2
 80012fa:	2b08      	cmp	r3, #8
 80012fc:	d1f9      	bne.n	80012f2 <stm32_clock_init+0xb2>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80012fe:	4b03      	ldr	r3, [pc, #12]	; (800130c <stm32_clock_init+0xcc>)
 8001300:	4a02      	ldr	r2, [pc, #8]	; (800130c <stm32_clock_init+0xcc>)
 8001302:	6992      	ldr	r2, [r2, #24]
 8001304:	2101      	movs	r1, #1
 8001306:	430a      	orrs	r2, r1
 8001308:	619a      	str	r2, [r3, #24]
#endif /* !STM32_NO_INIT */
}
 800130a:	4770      	bx	lr
 800130c:	40021000 	.word	0x40021000
 8001310:	40022000 	.word	0x40022000
 8001314:	46c0      	nop			; (mov r8, r8)
 8001316:	46c0      	nop			; (mov r8, r8)
 8001318:	46c0      	nop			; (mov r8, r8)
 800131a:	46c0      	nop			; (mov r8, r8)
 800131c:	46c0      	nop			; (mov r8, r8)
 800131e:	46c0      	nop			; (mov r8, r8)

08001320 <port_lock.6743.4077>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001320:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001322:	4770      	bx	lr
 8001324:	46c0      	nop			; (mov r8, r8)
 8001326:	46c0      	nop			; (mov r8, r8)
 8001328:	46c0      	nop			; (mov r8, r8)
 800132a:	46c0      	nop			; (mov r8, r8)
 800132c:	46c0      	nop			; (mov r8, r8)
 800132e:	46c0      	nop			; (mov r8, r8)

08001330 <port_unlock.6746.4075>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001330:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001332:	4770      	bx	lr
 8001334:	46c0      	nop			; (mov r8, r8)
 8001336:	46c0      	nop			; (mov r8, r8)
 8001338:	46c0      	nop			; (mov r8, r8)
 800133a:	46c0      	nop			; (mov r8, r8)
 800133c:	46c0      	nop			; (mov r8, r8)
 800133e:	46c0      	nop			; (mov r8, r8)

08001340 <port_lock_from_isr.6748.4073>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001340:	b508      	push	{r3, lr}

  port_lock();
 8001342:	f7ff ffed 	bl	8001320 <port_lock.6743.4077>
}
 8001346:	bd08      	pop	{r3, pc}
 8001348:	46c0      	nop			; (mov r8, r8)
 800134a:	46c0      	nop			; (mov r8, r8)
 800134c:	46c0      	nop			; (mov r8, r8)
 800134e:	46c0      	nop			; (mov r8, r8)

08001350 <port_unlock_from_isr.6750.4071>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001350:	b508      	push	{r3, lr}

  port_unlock();
 8001352:	f7ff ffed 	bl	8001330 <port_unlock.6746.4075>
}
 8001356:	bd08      	pop	{r3, pc}
 8001358:	46c0      	nop			; (mov r8, r8)
 800135a:	46c0      	nop			; (mov r8, r8)
 800135c:	46c0      	nop			; (mov r8, r8)
 800135e:	46c0      	nop			; (mov r8, r8)

08001360 <chSysLockFromISR.6752.4069>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001360:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001362:	f7ff ffed 	bl	8001340 <port_lock_from_isr.6748.4073>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8001366:	bd08      	pop	{r3, pc}
 8001368:	46c0      	nop			; (mov r8, r8)
 800136a:	46c0      	nop			; (mov r8, r8)
 800136c:	46c0      	nop			; (mov r8, r8)
 800136e:	46c0      	nop			; (mov r8, r8)

08001370 <chSysUnlockFromISR.6754.4067>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001370:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8001372:	f7ff ffed 	bl	8001350 <port_unlock_from_isr.6750.4071>
}
 8001376:	bd08      	pop	{r3, pc}
 8001378:	46c0      	nop			; (mov r8, r8)
 800137a:	46c0      	nop			; (mov r8, r8)
 800137c:	46c0      	nop			; (mov r8, r8)
 800137e:	46c0      	nop			; (mov r8, r8)

08001380 <osalSysLockFromISR.6756.4065>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8001380:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8001382:	f7ff ffed 	bl	8001360 <chSysLockFromISR.6752.4069>
}
 8001386:	bd08      	pop	{r3, pc}
 8001388:	46c0      	nop			; (mov r8, r8)
 800138a:	46c0      	nop			; (mov r8, r8)
 800138c:	46c0      	nop			; (mov r8, r8)
 800138e:	46c0      	nop			; (mov r8, r8)

08001390 <osalSysUnlockFromISR.6758.4063>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8001390:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8001392:	f7ff ffed 	bl	8001370 <chSysUnlockFromISR.6754.4067>
}
 8001396:	bd08      	pop	{r3, pc}
 8001398:	46c0      	nop			; (mov r8, r8)
 800139a:	46c0      	nop			; (mov r8, r8)
 800139c:	46c0      	nop			; (mov r8, r8)
 800139e:	46c0      	nop			; (mov r8, r8)

080013a0 <osalOsTimerHandlerI.6760.4061>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 80013a0:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 80013a2:	f001 f925 	bl	80025f0 <chSysTimerHandlerI>
}
 80013a6:	bd08      	pop	{r3, pc}
 80013a8:	46c0      	nop			; (mov r8, r8)
 80013aa:	46c0      	nop			; (mov r8, r8)
 80013ac:	46c0      	nop			; (mov r8, r8)
 80013ae:	46c0      	nop			; (mov r8, r8)

080013b0 <Vector80>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80013b0:	b500      	push	{lr}
 80013b2:	b083      	sub	sp, #12
 80013b4:	4673      	mov	r3, lr

  OSAL_IRQ_PROLOGUE();
 80013b6:	9301      	str	r3, [sp, #4]

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80013b8:	4b09      	ldr	r3, [pc, #36]	; (80013e0 <Vector80+0x30>)
 80013ba:	691a      	ldr	r2, [r3, #16]
 80013bc:	2302      	movs	r3, #2
 80013be:	4013      	ands	r3, r2
 80013c0:	d008      	beq.n	80013d4 <Vector80+0x24>
    STM32_ST_TIM->SR = 0U;
 80013c2:	4b07      	ldr	r3, [pc, #28]	; (80013e0 <Vector80+0x30>)
 80013c4:	2200      	movs	r2, #0
 80013c6:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80013c8:	f7ff ffda 	bl	8001380 <osalSysLockFromISR.6756.4065>
    osalOsTimerHandlerI();
 80013cc:	f7ff ffe8 	bl	80013a0 <osalOsTimerHandlerI.6760.4061>
    osalSysUnlockFromISR();
 80013d0:	f7ff ffde 	bl	8001390 <osalSysUnlockFromISR.6758.4063>
  }

  OSAL_IRQ_EPILOGUE();
 80013d4:	9b01      	ldr	r3, [sp, #4]
 80013d6:	1c18      	adds	r0, r3, #0
 80013d8:	f000 fb32 	bl	8001a40 <_port_irq_epilogue>
}
 80013dc:	b003      	add	sp, #12
 80013de:	bd00      	pop	{pc}
 80013e0:	40000400 	.word	0x40000400
 80013e4:	46c0      	nop			; (mov r8, r8)
 80013e6:	46c0      	nop			; (mov r8, r8)
 80013e8:	46c0      	nop			; (mov r8, r8)
 80013ea:	46c0      	nop			; (mov r8, r8)
 80013ec:	46c0      	nop			; (mov r8, r8)
 80013ee:	46c0      	nop			; (mov r8, r8)

080013f0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80013f0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80013f2:	4b14      	ldr	r3, [pc, #80]	; (8001444 <st_lld_init+0x54>)
 80013f4:	4a13      	ldr	r2, [pc, #76]	; (8001444 <st_lld_init+0x54>)
 80013f6:	69d2      	ldr	r2, [r2, #28]
 80013f8:	2102      	movs	r1, #2
 80013fa:	430a      	orrs	r2, r1
 80013fc:	61da      	str	r2, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80013fe:	4b12      	ldr	r3, [pc, #72]	; (8001448 <st_lld_init+0x58>)
 8001400:	4a11      	ldr	r2, [pc, #68]	; (8001448 <st_lld_init+0x58>)
 8001402:	6892      	ldr	r2, [r2, #8]
 8001404:	2102      	movs	r1, #2
 8001406:	430a      	orrs	r2, r1
 8001408:	609a      	str	r2, [r3, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800140a:	4b10      	ldr	r3, [pc, #64]	; (800144c <st_lld_init+0x5c>)
 800140c:	4a10      	ldr	r2, [pc, #64]	; (8001450 <st_lld_init+0x60>)
 800140e:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001410:	4b0e      	ldr	r3, [pc, #56]	; (800144c <st_lld_init+0x5c>)
 8001412:	4a10      	ldr	r2, [pc, #64]	; (8001454 <st_lld_init+0x64>)
 8001414:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001416:	4b0d      	ldr	r3, [pc, #52]	; (800144c <st_lld_init+0x5c>)
 8001418:	2200      	movs	r2, #0
 800141a:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 800141c:	4b0b      	ldr	r3, [pc, #44]	; (800144c <st_lld_init+0x5c>)
 800141e:	2200      	movs	r2, #0
 8001420:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001422:	4b0a      	ldr	r3, [pc, #40]	; (800144c <st_lld_init+0x5c>)
 8001424:	2200      	movs	r2, #0
 8001426:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001428:	4b08      	ldr	r3, [pc, #32]	; (800144c <st_lld_init+0x5c>)
 800142a:	2200      	movs	r2, #0
 800142c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800142e:	4b07      	ldr	r3, [pc, #28]	; (800144c <st_lld_init+0x5c>)
 8001430:	2201      	movs	r2, #1
 8001432:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001434:	4b05      	ldr	r3, [pc, #20]	; (800144c <st_lld_init+0x5c>)
 8001436:	2201      	movs	r2, #1
 8001438:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800143a:	2010      	movs	r0, #16
 800143c:	2102      	movs	r1, #2
 800143e:	f7ff fe57 	bl	80010f0 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8001442:	bd08      	pop	{r3, pc}
 8001444:	40021000 	.word	0x40021000
 8001448:	40015800 	.word	0x40015800
 800144c:	40000400 	.word	0x40000400
 8001450:	000012bf 	.word	0x000012bf
 8001454:	0000ffff 	.word	0x0000ffff
 8001458:	46c0      	nop			; (mov r8, r8)
 800145a:	46c0      	nop			; (mov r8, r8)
 800145c:	46c0      	nop			; (mov r8, r8)
 800145e:	46c0      	nop			; (mov r8, r8)

08001460 <ext_lld_init>:
/**
 * @brief   Low level EXT driver initialization.
 *
 * @notapi
 */
void ext_lld_init(void) {
 8001460:	b508      	push	{r3, lr}

  /* Driver initialization.*/
  extObjectInit(&EXTD1);
 8001462:	4b02      	ldr	r3, [pc, #8]	; (800146c <ext_lld_init+0xc>)
 8001464:	1c18      	adds	r0, r3, #0
 8001466:	f000 feb3 	bl	80021d0 <extObjectInit>
}
 800146a:	bd08      	pop	{r3, pc}
 800146c:	20000450 	.word	0x20000450

08001470 <ext_lld_start>:
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 8001470:	b500      	push	{lr}
 8001472:	b085      	sub	sp, #20
 8001474:	9001      	str	r0, [sp, #4]
  expchannel_t line;

  if (extp->state == EXT_STOP)
 8001476:	9b01      	ldr	r3, [sp, #4]
 8001478:	781b      	ldrb	r3, [r3, #0]
 800147a:	2b01      	cmp	r3, #1
 800147c:	d101      	bne.n	8001482 <ext_lld_start+0x12>
    ext_lld_exti_irq_enable();
 800147e:	f7fe ff47 	bl	8000310 <ext_lld_exti_irq_enable>

  /* Configuration of automatic channels.*/
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
 8001482:	2300      	movs	r3, #0
 8001484:	9303      	str	r3, [sp, #12]
 8001486:	e017      	b.n	80014b8 <ext_lld_start+0x48>
    if (extp->config->channels[line].mode & EXT_CH_MODE_AUTOSTART)
 8001488:	9b01      	ldr	r3, [sp, #4]
 800148a:	685b      	ldr	r3, [r3, #4]
 800148c:	9a03      	ldr	r2, [sp, #12]
 800148e:	00d2      	lsls	r2, r2, #3
 8001490:	58d2      	ldr	r2, [r2, r3]
 8001492:	2304      	movs	r3, #4
 8001494:	4013      	ands	r3, r2
 8001496:	d006      	beq.n	80014a6 <ext_lld_start+0x36>
      ext_lld_channel_enable(extp, line);
 8001498:	9a01      	ldr	r2, [sp, #4]
 800149a:	9b03      	ldr	r3, [sp, #12]
 800149c:	1c10      	adds	r0, r2, #0
 800149e:	1c19      	adds	r1, r3, #0
 80014a0:	f000 f816 	bl	80014d0 <ext_lld_channel_enable.4044>
 80014a4:	e005      	b.n	80014b2 <ext_lld_start+0x42>
    else
      ext_lld_channel_disable(extp, line);
 80014a6:	9a01      	ldr	r2, [sp, #4]
 80014a8:	9b03      	ldr	r3, [sp, #12]
 80014aa:	1c10      	adds	r0, r2, #0
 80014ac:	1c19      	adds	r1, r3, #0
 80014ae:	f000 f8a7 	bl	8001600 <ext_lld_channel_disable>

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (line = 0; line < EXT_MAX_CHANNELS; line++)
 80014b2:	9b03      	ldr	r3, [sp, #12]
 80014b4:	3301      	adds	r3, #1
 80014b6:	9303      	str	r3, [sp, #12]
 80014b8:	9b03      	ldr	r3, [sp, #12]
 80014ba:	2b13      	cmp	r3, #19
 80014bc:	d9e4      	bls.n	8001488 <ext_lld_start+0x18>
    if (extp->config->channels[line].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, line);
    else
      ext_lld_channel_disable(extp, line);
}
 80014be:	b005      	add	sp, #20
 80014c0:	bd00      	pop	{pc}
 80014c2:	46c0      	nop			; (mov r8, r8)
 80014c4:	46c0      	nop			; (mov r8, r8)
 80014c6:	46c0      	nop			; (mov r8, r8)
 80014c8:	46c0      	nop			; (mov r8, r8)
 80014ca:	46c0      	nop			; (mov r8, r8)
 80014cc:	46c0      	nop			; (mov r8, r8)
 80014ce:	46c0      	nop			; (mov r8, r8)

080014d0 <ext_lld_channel_enable.4044>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be enabled
 *
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {
 80014d0:	b086      	sub	sp, #24
 80014d2:	9001      	str	r0, [sp, #4]
 80014d4:	9100      	str	r1, [sp, #0]
  uint32_t cmask = (1 << (channel & 0x1F));
 80014d6:	9a00      	ldr	r2, [sp, #0]
 80014d8:	231f      	movs	r3, #31
 80014da:	4013      	ands	r3, r2
 80014dc:	2201      	movs	r2, #1
 80014de:	1c11      	adds	r1, r2, #0
 80014e0:	4099      	lsls	r1, r3
 80014e2:	1c0b      	adds	r3, r1, #0
 80014e4:	9305      	str	r3, [sp, #20]

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
 80014e6:	9b00      	ldr	r3, [sp, #0]
 80014e8:	2b0f      	cmp	r3, #15
 80014ea:	d82a      	bhi.n	8001542 <ext_lld_channel_enable.4044+0x72>
    uint32_t n = channel >> 2;
 80014ec:	9b00      	ldr	r3, [sp, #0]
 80014ee:	089b      	lsrs	r3, r3, #2
 80014f0:	9304      	str	r3, [sp, #16]
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 80014f2:	9a00      	ldr	r2, [sp, #0]
 80014f4:	2303      	movs	r3, #3
 80014f6:	4013      	ands	r3, r2
 80014f8:	009b      	lsls	r3, r3, #2
 80014fa:	220f      	movs	r2, #15
 80014fc:	1c11      	adds	r1, r2, #0
 80014fe:	4099      	lsls	r1, r3
 8001500:	1c0b      	adds	r3, r1, #0
 8001502:	43db      	mvns	r3, r3
 8001504:	9303      	str	r3, [sp, #12]
    uint32_t port = ((extp->config->channels[channel].mode &
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	685b      	ldr	r3, [r3, #4]
 800150a:	9a00      	ldr	r2, [sp, #0]
 800150c:	00d2      	lsls	r2, r2, #3
 800150e:	58d2      	ldr	r2, [r2, r3]
 8001510:	23f0      	movs	r3, #240	; 0xf0
 8001512:	4013      	ands	r3, r2
                      EXT_MODE_GPIO_MASK) >>
 8001514:	091a      	lsrs	r2, r3, #4
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);
 8001516:	9900      	ldr	r1, [sp, #0]
 8001518:	2303      	movs	r3, #3
 800151a:	400b      	ands	r3, r1
 800151c:	009b      	lsls	r3, r3, #2

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
    uint32_t port = ((extp->config->channels[channel].mode &
 800151e:	1c11      	adds	r1, r2, #0
 8001520:	4099      	lsls	r1, r3
 8001522:	1c0b      	adds	r3, r1, #0
 8001524:	9302      	str	r3, [sp, #8]
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 8001526:	4b31      	ldr	r3, [pc, #196]	; (80015ec <ext_lld_channel_enable.4044+0x11c>)
 8001528:	4a30      	ldr	r2, [pc, #192]	; (80015ec <ext_lld_channel_enable.4044+0x11c>)
 800152a:	9904      	ldr	r1, [sp, #16]
 800152c:	3102      	adds	r1, #2
 800152e:	0089      	lsls	r1, r1, #2
 8001530:	588a      	ldr	r2, [r1, r2]
 8001532:	9903      	ldr	r1, [sp, #12]
 8001534:	4011      	ands	r1, r2
 8001536:	9a02      	ldr	r2, [sp, #8]
 8001538:	4311      	orrs	r1, r2
 800153a:	9a04      	ldr	r2, [sp, #16]
 800153c:	3202      	adds	r2, #2
 800153e:	0092      	lsls	r2, r2, #2
 8001540:	50d1      	str	r1, [r2, r3]

#if STM32_EXTI_NUM_LINES > 32
  if (channel < 32) {
#endif
    /* Masked out lines must not be touched by this driver.*/
    if ((cmask & STM32_EXTI_IMR_MASK) != 0U) {
 8001542:	9a05      	ldr	r2, [sp, #20]
 8001544:	4b2a      	ldr	r3, [pc, #168]	; (80015f0 <ext_lld_channel_enable.4044+0x120>)
 8001546:	4013      	ands	r3, r2
 8001548:	d14e      	bne.n	80015e8 <ext_lld_channel_enable.4044+0x118>
      return;
    }

    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 800154a:	9b01      	ldr	r3, [sp, #4]
 800154c:	685b      	ldr	r3, [r3, #4]
 800154e:	9a00      	ldr	r2, [sp, #0]
 8001550:	00d2      	lsls	r2, r2, #3
 8001552:	58d2      	ldr	r2, [r2, r3]
 8001554:	2301      	movs	r3, #1
 8001556:	4013      	ands	r3, r2
 8001558:	d006      	beq.n	8001568 <ext_lld_channel_enable.4044+0x98>
      EXTI->RTSR |= cmask;
 800155a:	4b26      	ldr	r3, [pc, #152]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 800155c:	4a25      	ldr	r2, [pc, #148]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 800155e:	6891      	ldr	r1, [r2, #8]
 8001560:	9a05      	ldr	r2, [sp, #20]
 8001562:	430a      	orrs	r2, r1
 8001564:	609a      	str	r2, [r3, #8]
 8001566:	e006      	b.n	8001576 <ext_lld_channel_enable.4044+0xa6>
    else
      EXTI->RTSR &= ~cmask;
 8001568:	4b22      	ldr	r3, [pc, #136]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 800156a:	4a22      	ldr	r2, [pc, #136]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 800156c:	6892      	ldr	r2, [r2, #8]
 800156e:	9905      	ldr	r1, [sp, #20]
 8001570:	43c9      	mvns	r1, r1
 8001572:	400a      	ands	r2, r1
 8001574:	609a      	str	r2, [r3, #8]
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
 8001576:	9b01      	ldr	r3, [sp, #4]
 8001578:	685b      	ldr	r3, [r3, #4]
 800157a:	9a00      	ldr	r2, [sp, #0]
 800157c:	00d2      	lsls	r2, r2, #3
 800157e:	58d2      	ldr	r2, [r2, r3]
 8001580:	2302      	movs	r3, #2
 8001582:	4013      	ands	r3, r2
 8001584:	d006      	beq.n	8001594 <ext_lld_channel_enable.4044+0xc4>
      EXTI->FTSR |= cmask;
 8001586:	4b1b      	ldr	r3, [pc, #108]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 8001588:	4a1a      	ldr	r2, [pc, #104]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 800158a:	68d1      	ldr	r1, [r2, #12]
 800158c:	9a05      	ldr	r2, [sp, #20]
 800158e:	430a      	orrs	r2, r1
 8001590:	60da      	str	r2, [r3, #12]
 8001592:	e006      	b.n	80015a2 <ext_lld_channel_enable.4044+0xd2>
    else
      EXTI->FTSR &= ~cmask;
 8001594:	4b17      	ldr	r3, [pc, #92]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 8001596:	4a17      	ldr	r2, [pc, #92]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 8001598:	68d2      	ldr	r2, [r2, #12]
 800159a:	9905      	ldr	r1, [sp, #20]
 800159c:	43c9      	mvns	r1, r1
 800159e:	400a      	ands	r2, r1
 80015a0:	60da      	str	r2, [r3, #12]

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 80015a2:	9b01      	ldr	r3, [sp, #4]
 80015a4:	685a      	ldr	r2, [r3, #4]
 80015a6:	9b00      	ldr	r3, [sp, #0]
 80015a8:	00db      	lsls	r3, r3, #3
 80015aa:	18d3      	adds	r3, r2, r3
 80015ac:	685b      	ldr	r3, [r3, #4]
 80015ae:	2b00      	cmp	r3, #0
 80015b0:	d00d      	beq.n	80015ce <ext_lld_channel_enable.4044+0xfe>
      EXTI->IMR |= cmask;
 80015b2:	4b10      	ldr	r3, [pc, #64]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 80015b4:	4a0f      	ldr	r2, [pc, #60]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 80015b6:	6811      	ldr	r1, [r2, #0]
 80015b8:	9a05      	ldr	r2, [sp, #20]
 80015ba:	430a      	orrs	r2, r1
 80015bc:	601a      	str	r2, [r3, #0]
      EXTI->EMR &= ~cmask;
 80015be:	4b0d      	ldr	r3, [pc, #52]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 80015c0:	4a0c      	ldr	r2, [pc, #48]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 80015c2:	6852      	ldr	r2, [r2, #4]
 80015c4:	9905      	ldr	r1, [sp, #20]
 80015c6:	43c9      	mvns	r1, r1
 80015c8:	400a      	ands	r2, r1
 80015ca:	605a      	str	r2, [r3, #4]
 80015cc:	e00c      	b.n	80015e8 <ext_lld_channel_enable.4044+0x118>
    }
    else {
      EXTI->EMR |= cmask;
 80015ce:	4b09      	ldr	r3, [pc, #36]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 80015d0:	4a08      	ldr	r2, [pc, #32]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 80015d2:	6851      	ldr	r1, [r2, #4]
 80015d4:	9a05      	ldr	r2, [sp, #20]
 80015d6:	430a      	orrs	r2, r1
 80015d8:	605a      	str	r2, [r3, #4]
      EXTI->IMR &= ~cmask;
 80015da:	4b06      	ldr	r3, [pc, #24]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 80015dc:	4a05      	ldr	r2, [pc, #20]	; (80015f4 <ext_lld_channel_enable.4044+0x124>)
 80015de:	6812      	ldr	r2, [r2, #0]
 80015e0:	9905      	ldr	r1, [sp, #20]
 80015e2:	43c9      	mvns	r1, r1
 80015e4:	400a      	ands	r2, r1
 80015e6:	601a      	str	r2, [r3, #0]
      EXTI->EMR2 |= cmask;
      EXTI->IMR2 &= ~cmask;
    }
  }
#endif
}
 80015e8:	b006      	add	sp, #24
 80015ea:	4770      	bx	lr
 80015ec:	40010000 	.word	0x40010000
 80015f0:	fff50000 	.word	0xfff50000
 80015f4:	40010400 	.word	0x40010400
 80015f8:	46c0      	nop			; (mov r8, r8)
 80015fa:	46c0      	nop			; (mov r8, r8)
 80015fc:	46c0      	nop			; (mov r8, r8)
 80015fe:	46c0      	nop			; (mov r8, r8)

08001600 <ext_lld_channel_disable>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] channel   channel to be disabled
 *
 * @notapi
 */
void ext_lld_channel_disable(EXTDriver *extp, expchannel_t channel) {
 8001600:	b084      	sub	sp, #16
 8001602:	9001      	str	r0, [sp, #4]
 8001604:	9100      	str	r1, [sp, #0]
  uint32_t cmask = (1 << (channel & 0x1F));
 8001606:	9a00      	ldr	r2, [sp, #0]
 8001608:	231f      	movs	r3, #31
 800160a:	4013      	ands	r3, r2
 800160c:	2201      	movs	r2, #1
 800160e:	1c11      	adds	r1, r2, #0
 8001610:	4099      	lsls	r1, r3
 8001612:	1c0b      	adds	r3, r1, #0
 8001614:	9303      	str	r3, [sp, #12]
  (void)extp;

#if STM32_EXTI_NUM_LINES > 32
  if (channel < 32) {
#endif
    EXTI->IMR  &= ~cmask;
 8001616:	4b10      	ldr	r3, [pc, #64]	; (8001658 <ext_lld_channel_disable+0x58>)
 8001618:	4a0f      	ldr	r2, [pc, #60]	; (8001658 <ext_lld_channel_disable+0x58>)
 800161a:	6812      	ldr	r2, [r2, #0]
 800161c:	9903      	ldr	r1, [sp, #12]
 800161e:	43c9      	mvns	r1, r1
 8001620:	400a      	ands	r2, r1
 8001622:	601a      	str	r2, [r3, #0]
    EXTI->EMR  &= ~cmask;
 8001624:	4b0c      	ldr	r3, [pc, #48]	; (8001658 <ext_lld_channel_disable+0x58>)
 8001626:	4a0c      	ldr	r2, [pc, #48]	; (8001658 <ext_lld_channel_disable+0x58>)
 8001628:	6852      	ldr	r2, [r2, #4]
 800162a:	9903      	ldr	r1, [sp, #12]
 800162c:	43c9      	mvns	r1, r1
 800162e:	400a      	ands	r2, r1
 8001630:	605a      	str	r2, [r3, #4]
    EXTI->RTSR &= ~cmask;
 8001632:	4b09      	ldr	r3, [pc, #36]	; (8001658 <ext_lld_channel_disable+0x58>)
 8001634:	4a08      	ldr	r2, [pc, #32]	; (8001658 <ext_lld_channel_disable+0x58>)
 8001636:	6892      	ldr	r2, [r2, #8]
 8001638:	9903      	ldr	r1, [sp, #12]
 800163a:	43c9      	mvns	r1, r1
 800163c:	400a      	ands	r2, r1
 800163e:	609a      	str	r2, [r3, #8]
    EXTI->FTSR &= ~cmask;
 8001640:	4b05      	ldr	r3, [pc, #20]	; (8001658 <ext_lld_channel_disable+0x58>)
 8001642:	4a05      	ldr	r2, [pc, #20]	; (8001658 <ext_lld_channel_disable+0x58>)
 8001644:	68d2      	ldr	r2, [r2, #12]
 8001646:	9903      	ldr	r1, [sp, #12]
 8001648:	43c9      	mvns	r1, r1
 800164a:	400a      	ands	r2, r1
 800164c:	60da      	str	r2, [r3, #12]
    EXTI->PR    =  cmask;
 800164e:	4b02      	ldr	r3, [pc, #8]	; (8001658 <ext_lld_channel_disable+0x58>)
 8001650:	9a03      	ldr	r2, [sp, #12]
 8001652:	615a      	str	r2, [r3, #20]
    EXTI->RTSR2 &= ~cmask;
    EXTI->FTSR2 &= ~cmask;
    EXTI->PR2    =  cmask;
  }
#endif
}
 8001654:	b004      	add	sp, #16
 8001656:	4770      	bx	lr
 8001658:	40010400 	.word	0x40010400
 800165c:	46c0      	nop			; (mov r8, r8)
 800165e:	46c0      	nop			; (mov r8, r8)

08001660 <Vector54>:
/**
 * @brief   EXTI[0]...EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector54) {
 8001660:	b500      	push	{lr}
 8001662:	b083      	sub	sp, #12
 8001664:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8001666:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR & ((1 << 0) | (1 << 1));
 8001668:	4b11      	ldr	r3, [pc, #68]	; (80016b0 <Vector54+0x50>)
 800166a:	695a      	ldr	r2, [r3, #20]
 800166c:	2303      	movs	r3, #3
 800166e:	4013      	ands	r3, r2
 8001670:	9300      	str	r3, [sp, #0]
  EXTI->PR = pr;
 8001672:	4b0f      	ldr	r3, [pc, #60]	; (80016b0 <Vector54+0x50>)
 8001674:	9a00      	ldr	r2, [sp, #0]
 8001676:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 0))
 8001678:	9a00      	ldr	r2, [sp, #0]
 800167a:	2301      	movs	r3, #1
 800167c:	4013      	ands	r3, r2
 800167e:	d006      	beq.n	800168e <Vector54+0x2e>
    EXTD1.config->channels[0].cb(&EXTD1, 0);
 8001680:	4b0c      	ldr	r3, [pc, #48]	; (80016b4 <Vector54+0x54>)
 8001682:	685b      	ldr	r3, [r3, #4]
 8001684:	685b      	ldr	r3, [r3, #4]
 8001686:	4a0b      	ldr	r2, [pc, #44]	; (80016b4 <Vector54+0x54>)
 8001688:	1c10      	adds	r0, r2, #0
 800168a:	2100      	movs	r1, #0
 800168c:	4798      	blx	r3
  if (pr & (1 << 1))
 800168e:	9a00      	ldr	r2, [sp, #0]
 8001690:	2302      	movs	r3, #2
 8001692:	4013      	ands	r3, r2
 8001694:	d006      	beq.n	80016a4 <Vector54+0x44>
    EXTD1.config->channels[1].cb(&EXTD1, 1);
 8001696:	4b07      	ldr	r3, [pc, #28]	; (80016b4 <Vector54+0x54>)
 8001698:	685b      	ldr	r3, [r3, #4]
 800169a:	68db      	ldr	r3, [r3, #12]
 800169c:	4a05      	ldr	r2, [pc, #20]	; (80016b4 <Vector54+0x54>)
 800169e:	1c10      	adds	r0, r2, #0
 80016a0:	2101      	movs	r1, #1
 80016a2:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80016a4:	9b01      	ldr	r3, [sp, #4]
 80016a6:	1c18      	adds	r0, r3, #0
 80016a8:	f000 f9ca 	bl	8001a40 <_port_irq_epilogue>
}
 80016ac:	b003      	add	sp, #12
 80016ae:	bd00      	pop	{pc}
 80016b0:	40010400 	.word	0x40010400
 80016b4:	20000450 	.word	0x20000450
 80016b8:	46c0      	nop			; (mov r8, r8)
 80016ba:	46c0      	nop			; (mov r8, r8)
 80016bc:	46c0      	nop			; (mov r8, r8)
 80016be:	46c0      	nop			; (mov r8, r8)

080016c0 <Vector58>:
/**
 * @brief   EXTI[2]...EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 80016c0:	b500      	push	{lr}
 80016c2:	b083      	sub	sp, #12
 80016c4:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 80016c6:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR & ((1 << 2) | (1 << 3));
 80016c8:	4b11      	ldr	r3, [pc, #68]	; (8001710 <Vector58+0x50>)
 80016ca:	695a      	ldr	r2, [r3, #20]
 80016cc:	230c      	movs	r3, #12
 80016ce:	4013      	ands	r3, r2
 80016d0:	9300      	str	r3, [sp, #0]
  EXTI->PR = pr;
 80016d2:	4b0f      	ldr	r3, [pc, #60]	; (8001710 <Vector58+0x50>)
 80016d4:	9a00      	ldr	r2, [sp, #0]
 80016d6:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 2))
 80016d8:	9a00      	ldr	r2, [sp, #0]
 80016da:	2304      	movs	r3, #4
 80016dc:	4013      	ands	r3, r2
 80016de:	d006      	beq.n	80016ee <Vector58+0x2e>
    EXTD1.config->channels[2].cb(&EXTD1, 2);
 80016e0:	4b0c      	ldr	r3, [pc, #48]	; (8001714 <Vector58+0x54>)
 80016e2:	685b      	ldr	r3, [r3, #4]
 80016e4:	695b      	ldr	r3, [r3, #20]
 80016e6:	4a0b      	ldr	r2, [pc, #44]	; (8001714 <Vector58+0x54>)
 80016e8:	1c10      	adds	r0, r2, #0
 80016ea:	2102      	movs	r1, #2
 80016ec:	4798      	blx	r3
  if (pr & (1 << 3))
 80016ee:	9a00      	ldr	r2, [sp, #0]
 80016f0:	2308      	movs	r3, #8
 80016f2:	4013      	ands	r3, r2
 80016f4:	d006      	beq.n	8001704 <Vector58+0x44>
    EXTD1.config->channels[3].cb(&EXTD1, 3);
 80016f6:	4b07      	ldr	r3, [pc, #28]	; (8001714 <Vector58+0x54>)
 80016f8:	685b      	ldr	r3, [r3, #4]
 80016fa:	69db      	ldr	r3, [r3, #28]
 80016fc:	4a05      	ldr	r2, [pc, #20]	; (8001714 <Vector58+0x54>)
 80016fe:	1c10      	adds	r0, r2, #0
 8001700:	2103      	movs	r1, #3
 8001702:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001704:	9b01      	ldr	r3, [sp, #4]
 8001706:	1c18      	adds	r0, r3, #0
 8001708:	f000 f99a 	bl	8001a40 <_port_irq_epilogue>
}
 800170c:	b003      	add	sp, #12
 800170e:	bd00      	pop	{pc}
 8001710:	40010400 	.word	0x40010400
 8001714:	20000450 	.word	0x20000450
 8001718:	46c0      	nop			; (mov r8, r8)
 800171a:	46c0      	nop			; (mov r8, r8)
 800171c:	46c0      	nop			; (mov r8, r8)
 800171e:	46c0      	nop			; (mov r8, r8)

08001720 <Vector5C>:
/**
 * @brief   EXTI[4]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 8001720:	b500      	push	{lr}
 8001722:	b083      	sub	sp, #12
 8001724:	4673      	mov	r3, lr
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();
 8001726:	9301      	str	r3, [sp, #4]

  pr = EXTI->PR & ((1 << 4)  | (1 << 5)  | (1 << 6)  | (1 << 7)  | (1 << 8)  |
 8001728:	4b4c      	ldr	r3, [pc, #304]	; (800185c <Vector5C+0x13c>)
 800172a:	695a      	ldr	r2, [r3, #20]
 800172c:	4b4c      	ldr	r3, [pc, #304]	; (8001860 <Vector5C+0x140>)
 800172e:	4013      	ands	r3, r2
 8001730:	9300      	str	r3, [sp, #0]
                   (1 << 9)  | (1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) |
                   (1 << 14) | (1 << 15));
  EXTI->PR = pr;
 8001732:	4b4a      	ldr	r3, [pc, #296]	; (800185c <Vector5C+0x13c>)
 8001734:	9a00      	ldr	r2, [sp, #0]
 8001736:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 4))
 8001738:	9a00      	ldr	r2, [sp, #0]
 800173a:	2310      	movs	r3, #16
 800173c:	4013      	ands	r3, r2
 800173e:	d006      	beq.n	800174e <Vector5C+0x2e>
    EXTD1.config->channels[4].cb(&EXTD1, 4);
 8001740:	4b48      	ldr	r3, [pc, #288]	; (8001864 <Vector5C+0x144>)
 8001742:	685b      	ldr	r3, [r3, #4]
 8001744:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001746:	4a47      	ldr	r2, [pc, #284]	; (8001864 <Vector5C+0x144>)
 8001748:	1c10      	adds	r0, r2, #0
 800174a:	2104      	movs	r1, #4
 800174c:	4798      	blx	r3
  if (pr & (1 << 5))
 800174e:	9a00      	ldr	r2, [sp, #0]
 8001750:	2320      	movs	r3, #32
 8001752:	4013      	ands	r3, r2
 8001754:	d006      	beq.n	8001764 <Vector5C+0x44>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 8001756:	4b43      	ldr	r3, [pc, #268]	; (8001864 <Vector5C+0x144>)
 8001758:	685b      	ldr	r3, [r3, #4]
 800175a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800175c:	4a41      	ldr	r2, [pc, #260]	; (8001864 <Vector5C+0x144>)
 800175e:	1c10      	adds	r0, r2, #0
 8001760:	2105      	movs	r1, #5
 8001762:	4798      	blx	r3
  if (pr & (1 << 6))
 8001764:	9a00      	ldr	r2, [sp, #0]
 8001766:	2340      	movs	r3, #64	; 0x40
 8001768:	4013      	ands	r3, r2
 800176a:	d006      	beq.n	800177a <Vector5C+0x5a>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 800176c:	4b3d      	ldr	r3, [pc, #244]	; (8001864 <Vector5C+0x144>)
 800176e:	685b      	ldr	r3, [r3, #4]
 8001770:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001772:	4a3c      	ldr	r2, [pc, #240]	; (8001864 <Vector5C+0x144>)
 8001774:	1c10      	adds	r0, r2, #0
 8001776:	2106      	movs	r1, #6
 8001778:	4798      	blx	r3
  if (pr & (1 << 7))
 800177a:	9a00      	ldr	r2, [sp, #0]
 800177c:	2380      	movs	r3, #128	; 0x80
 800177e:	4013      	ands	r3, r2
 8001780:	d006      	beq.n	8001790 <Vector5C+0x70>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 8001782:	4b38      	ldr	r3, [pc, #224]	; (8001864 <Vector5C+0x144>)
 8001784:	685b      	ldr	r3, [r3, #4]
 8001786:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001788:	4a36      	ldr	r2, [pc, #216]	; (8001864 <Vector5C+0x144>)
 800178a:	1c10      	adds	r0, r2, #0
 800178c:	2107      	movs	r1, #7
 800178e:	4798      	blx	r3
  if (pr & (1 << 8))
 8001790:	9a00      	ldr	r2, [sp, #0]
 8001792:	2380      	movs	r3, #128	; 0x80
 8001794:	005b      	lsls	r3, r3, #1
 8001796:	4013      	ands	r3, r2
 8001798:	d006      	beq.n	80017a8 <Vector5C+0x88>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 800179a:	4b32      	ldr	r3, [pc, #200]	; (8001864 <Vector5C+0x144>)
 800179c:	685b      	ldr	r3, [r3, #4]
 800179e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80017a0:	4a30      	ldr	r2, [pc, #192]	; (8001864 <Vector5C+0x144>)
 80017a2:	1c10      	adds	r0, r2, #0
 80017a4:	2108      	movs	r1, #8
 80017a6:	4798      	blx	r3
  if (pr & (1 << 9))
 80017a8:	9a00      	ldr	r2, [sp, #0]
 80017aa:	2380      	movs	r3, #128	; 0x80
 80017ac:	009b      	lsls	r3, r3, #2
 80017ae:	4013      	ands	r3, r2
 80017b0:	d006      	beq.n	80017c0 <Vector5C+0xa0>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 80017b2:	4b2c      	ldr	r3, [pc, #176]	; (8001864 <Vector5C+0x144>)
 80017b4:	685b      	ldr	r3, [r3, #4]
 80017b6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80017b8:	4a2a      	ldr	r2, [pc, #168]	; (8001864 <Vector5C+0x144>)
 80017ba:	1c10      	adds	r0, r2, #0
 80017bc:	2109      	movs	r1, #9
 80017be:	4798      	blx	r3
  if (pr & (1 << 10))
 80017c0:	9a00      	ldr	r2, [sp, #0]
 80017c2:	2380      	movs	r3, #128	; 0x80
 80017c4:	00db      	lsls	r3, r3, #3
 80017c6:	4013      	ands	r3, r2
 80017c8:	d006      	beq.n	80017d8 <Vector5C+0xb8>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 80017ca:	4b26      	ldr	r3, [pc, #152]	; (8001864 <Vector5C+0x144>)
 80017cc:	685b      	ldr	r3, [r3, #4]
 80017ce:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80017d0:	4a24      	ldr	r2, [pc, #144]	; (8001864 <Vector5C+0x144>)
 80017d2:	1c10      	adds	r0, r2, #0
 80017d4:	210a      	movs	r1, #10
 80017d6:	4798      	blx	r3
  if (pr & (1 << 11))
 80017d8:	9a00      	ldr	r2, [sp, #0]
 80017da:	2380      	movs	r3, #128	; 0x80
 80017dc:	011b      	lsls	r3, r3, #4
 80017de:	4013      	ands	r3, r2
 80017e0:	d006      	beq.n	80017f0 <Vector5C+0xd0>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 80017e2:	4b20      	ldr	r3, [pc, #128]	; (8001864 <Vector5C+0x144>)
 80017e4:	685b      	ldr	r3, [r3, #4]
 80017e6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80017e8:	4a1e      	ldr	r2, [pc, #120]	; (8001864 <Vector5C+0x144>)
 80017ea:	1c10      	adds	r0, r2, #0
 80017ec:	210b      	movs	r1, #11
 80017ee:	4798      	blx	r3
  if (pr & (1 << 12))
 80017f0:	9a00      	ldr	r2, [sp, #0]
 80017f2:	2380      	movs	r3, #128	; 0x80
 80017f4:	015b      	lsls	r3, r3, #5
 80017f6:	4013      	ands	r3, r2
 80017f8:	d006      	beq.n	8001808 <Vector5C+0xe8>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 80017fa:	4b1a      	ldr	r3, [pc, #104]	; (8001864 <Vector5C+0x144>)
 80017fc:	685b      	ldr	r3, [r3, #4]
 80017fe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001800:	4a18      	ldr	r2, [pc, #96]	; (8001864 <Vector5C+0x144>)
 8001802:	1c10      	adds	r0, r2, #0
 8001804:	210c      	movs	r1, #12
 8001806:	4798      	blx	r3
  if (pr & (1 << 13))
 8001808:	9a00      	ldr	r2, [sp, #0]
 800180a:	2380      	movs	r3, #128	; 0x80
 800180c:	019b      	lsls	r3, r3, #6
 800180e:	4013      	ands	r3, r2
 8001810:	d006      	beq.n	8001820 <Vector5C+0x100>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 8001812:	4b14      	ldr	r3, [pc, #80]	; (8001864 <Vector5C+0x144>)
 8001814:	685b      	ldr	r3, [r3, #4]
 8001816:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001818:	4a12      	ldr	r2, [pc, #72]	; (8001864 <Vector5C+0x144>)
 800181a:	1c10      	adds	r0, r2, #0
 800181c:	210d      	movs	r1, #13
 800181e:	4798      	blx	r3
  if (pr & (1 << 14))
 8001820:	9a00      	ldr	r2, [sp, #0]
 8001822:	2380      	movs	r3, #128	; 0x80
 8001824:	01db      	lsls	r3, r3, #7
 8001826:	4013      	ands	r3, r2
 8001828:	d006      	beq.n	8001838 <Vector5C+0x118>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 800182a:	4b0e      	ldr	r3, [pc, #56]	; (8001864 <Vector5C+0x144>)
 800182c:	685b      	ldr	r3, [r3, #4]
 800182e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001830:	4a0c      	ldr	r2, [pc, #48]	; (8001864 <Vector5C+0x144>)
 8001832:	1c10      	adds	r0, r2, #0
 8001834:	210e      	movs	r1, #14
 8001836:	4798      	blx	r3
  if (pr & (1 << 15))
 8001838:	9a00      	ldr	r2, [sp, #0]
 800183a:	2380      	movs	r3, #128	; 0x80
 800183c:	021b      	lsls	r3, r3, #8
 800183e:	4013      	ands	r3, r2
 8001840:	d006      	beq.n	8001850 <Vector5C+0x130>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 8001842:	4b08      	ldr	r3, [pc, #32]	; (8001864 <Vector5C+0x144>)
 8001844:	685b      	ldr	r3, [r3, #4]
 8001846:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8001848:	4a06      	ldr	r2, [pc, #24]	; (8001864 <Vector5C+0x144>)
 800184a:	1c10      	adds	r0, r2, #0
 800184c:	210f      	movs	r1, #15
 800184e:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001850:	9b01      	ldr	r3, [sp, #4]
 8001852:	1c18      	adds	r0, r3, #0
 8001854:	f000 f8f4 	bl	8001a40 <_port_irq_epilogue>
}
 8001858:	b003      	add	sp, #12
 800185a:	bd00      	pop	{pc}
 800185c:	40010400 	.word	0x40010400
 8001860:	0000fff0 	.word	0x0000fff0
 8001864:	20000450 	.word	0x20000450
 8001868:	46c0      	nop			; (mov r8, r8)
 800186a:	46c0      	nop			; (mov r8, r8)
 800186c:	46c0      	nop			; (mov r8, r8)
 800186e:	46c0      	nop			; (mov r8, r8)

08001870 <queue_init.5370.4408>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001870:	b082      	sub	sp, #8
 8001872:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001874:	9b01      	ldr	r3, [sp, #4]
 8001876:	9a01      	ldr	r2, [sp, #4]
 8001878:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800187a:	9b01      	ldr	r3, [sp, #4]
 800187c:	9a01      	ldr	r2, [sp, #4]
 800187e:	605a      	str	r2, [r3, #4]
}
 8001880:	b002      	add	sp, #8
 8001882:	4770      	bx	lr
 8001884:	46c0      	nop			; (mov r8, r8)
 8001886:	46c0      	nop			; (mov r8, r8)
 8001888:	46c0      	nop			; (mov r8, r8)
 800188a:	46c0      	nop			; (mov r8, r8)
 800188c:	46c0      	nop			; (mov r8, r8)
 800188e:	46c0      	nop			; (mov r8, r8)

08001890 <chMtxObjectInit.4395>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001890:	b500      	push	{lr}
 8001892:	b083      	sub	sp, #12
 8001894:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8001896:	9b01      	ldr	r3, [sp, #4]
 8001898:	1c18      	adds	r0, r3, #0
 800189a:	f7ff ffe9 	bl	8001870 <queue_init.5370.4408>
  mp->m_owner = NULL;
 800189e:	9b01      	ldr	r3, [sp, #4]
 80018a0:	2200      	movs	r2, #0
 80018a2:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 80018a4:	b003      	add	sp, #12
 80018a6:	bd00      	pop	{pc}
 80018a8:	46c0      	nop			; (mov r8, r8)
 80018aa:	46c0      	nop			; (mov r8, r8)
 80018ac:	46c0      	nop			; (mov r8, r8)
 80018ae:	46c0      	nop			; (mov r8, r8)

080018b0 <port_lock.5714.4318>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80018b0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80018b2:	4770      	bx	lr
 80018b4:	46c0      	nop			; (mov r8, r8)
 80018b6:	46c0      	nop			; (mov r8, r8)
 80018b8:	46c0      	nop			; (mov r8, r8)
 80018ba:	46c0      	nop			; (mov r8, r8)
 80018bc:	46c0      	nop			; (mov r8, r8)
 80018be:	46c0      	nop			; (mov r8, r8)

080018c0 <port_unlock.5717.4316>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80018c0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80018c2:	4770      	bx	lr
 80018c4:	46c0      	nop			; (mov r8, r8)
 80018c6:	46c0      	nop			; (mov r8, r8)
 80018c8:	46c0      	nop			; (mov r8, r8)
 80018ca:	46c0      	nop			; (mov r8, r8)
 80018cc:	46c0      	nop			; (mov r8, r8)
 80018ce:	46c0      	nop			; (mov r8, r8)

080018d0 <chSysLock.5719.4314>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 80018d0:	b508      	push	{r3, lr}

  port_lock();
 80018d2:	f7ff ffed 	bl	80018b0 <port_lock.5714.4318>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80018d6:	bd08      	pop	{r3, pc}
 80018d8:	46c0      	nop			; (mov r8, r8)
 80018da:	46c0      	nop			; (mov r8, r8)
 80018dc:	46c0      	nop			; (mov r8, r8)
 80018de:	46c0      	nop			; (mov r8, r8)

080018e0 <chSysUnlock.5721.4312>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80018e0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80018e2:	f7ff ffed 	bl	80018c0 <port_unlock.5717.4316>
}
 80018e6:	bd08      	pop	{r3, pc}
 80018e8:	46c0      	nop			; (mov r8, r8)
 80018ea:	46c0      	nop			; (mov r8, r8)
 80018ec:	46c0      	nop			; (mov r8, r8)
 80018ee:	46c0      	nop			; (mov r8, r8)

080018f0 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80018f0:	4b06      	ldr	r3, [pc, #24]	; (800190c <_core_init+0x1c>)
 80018f2:	3307      	adds	r3, #7
 80018f4:	2207      	movs	r2, #7
 80018f6:	4393      	bics	r3, r2
 80018f8:	1c1a      	adds	r2, r3, #0
 80018fa:	4b05      	ldr	r3, [pc, #20]	; (8001910 <_core_init+0x20>)
 80018fc:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80018fe:	4b05      	ldr	r3, [pc, #20]	; (8001914 <_core_init+0x24>)
 8001900:	2207      	movs	r2, #7
 8001902:	4393      	bics	r3, r2
 8001904:	1c1a      	adds	r2, r3, #0
 8001906:	4b04      	ldr	r3, [pc, #16]	; (8001918 <_core_init+0x28>)
 8001908:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 800190a:	4770      	bx	lr
 800190c:	200004d8 	.word	0x200004d8
 8001910:	20000428 	.word	0x20000428
 8001914:	20001000 	.word	0x20001000
 8001918:	2000042c 	.word	0x2000042c
 800191c:	46c0      	nop			; (mov r8, r8)
 800191e:	46c0      	nop			; (mov r8, r8)

08001920 <chCoreAlloc.4302>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8001920:	b500      	push	{lr}
 8001922:	b085      	sub	sp, #20
 8001924:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8001926:	f7ff ffd3 	bl	80018d0 <chSysLock.5719.4314>
  p = chCoreAllocI(size);
 800192a:	9b01      	ldr	r3, [sp, #4]
 800192c:	1c18      	adds	r0, r3, #0
 800192e:	f000 f80f 	bl	8001950 <chCoreAllocI.4307>
 8001932:	1c03      	adds	r3, r0, #0
 8001934:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 8001936:	f7ff ffd3 	bl	80018e0 <chSysUnlock.5721.4312>

  return p;
 800193a:	9b03      	ldr	r3, [sp, #12]
}
 800193c:	1c18      	adds	r0, r3, #0
 800193e:	b005      	add	sp, #20
 8001940:	bd00      	pop	{pc}
 8001942:	46c0      	nop			; (mov r8, r8)
 8001944:	46c0      	nop			; (mov r8, r8)
 8001946:	46c0      	nop			; (mov r8, r8)
 8001948:	46c0      	nop			; (mov r8, r8)
 800194a:	46c0      	nop			; (mov r8, r8)
 800194c:	46c0      	nop			; (mov r8, r8)
 800194e:	46c0      	nop			; (mov r8, r8)

08001950 <chCoreAllocI.4307>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8001950:	b084      	sub	sp, #16
 8001952:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001954:	9b01      	ldr	r3, [sp, #4]
 8001956:	3307      	adds	r3, #7
 8001958:	2207      	movs	r2, #7
 800195a:	4393      	bics	r3, r2
 800195c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800195e:	4b0c      	ldr	r3, [pc, #48]	; (8001990 <chCoreAllocI.4307+0x40>)
 8001960:	681b      	ldr	r3, [r3, #0]
 8001962:	1c1a      	adds	r2, r3, #0
 8001964:	4b0b      	ldr	r3, [pc, #44]	; (8001994 <chCoreAllocI.4307+0x44>)
 8001966:	681b      	ldr	r3, [r3, #0]
 8001968:	1ad3      	subs	r3, r2, r3
 800196a:	1c1a      	adds	r2, r3, #0
 800196c:	9b01      	ldr	r3, [sp, #4]
 800196e:	429a      	cmp	r2, r3
 8001970:	d201      	bcs.n	8001976 <chCoreAllocI.4307+0x26>
  /*lint -restore*/
    return NULL;
 8001972:	2300      	movs	r3, #0
 8001974:	e009      	b.n	800198a <chCoreAllocI.4307+0x3a>
  }
  p = nextmem;
 8001976:	4b07      	ldr	r3, [pc, #28]	; (8001994 <chCoreAllocI.4307+0x44>)
 8001978:	681b      	ldr	r3, [r3, #0]
 800197a:	9303      	str	r3, [sp, #12]
  nextmem += size;
 800197c:	4b05      	ldr	r3, [pc, #20]	; (8001994 <chCoreAllocI.4307+0x44>)
 800197e:	681a      	ldr	r2, [r3, #0]
 8001980:	9b01      	ldr	r3, [sp, #4]
 8001982:	18d2      	adds	r2, r2, r3
 8001984:	4b03      	ldr	r3, [pc, #12]	; (8001994 <chCoreAllocI.4307+0x44>)
 8001986:	601a      	str	r2, [r3, #0]

  return p;
 8001988:	9b03      	ldr	r3, [sp, #12]
}
 800198a:	1c18      	adds	r0, r3, #0
 800198c:	b004      	add	sp, #16
 800198e:	4770      	bx	lr
 8001990:	2000042c 	.word	0x2000042c
 8001994:	20000428 	.word	0x20000428
 8001998:	46c0      	nop			; (mov r8, r8)
 800199a:	46c0      	nop			; (mov r8, r8)
 800199c:	46c0      	nop			; (mov r8, r8)
 800199e:	46c0      	nop			; (mov r8, r8)

080019a0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80019a0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 80019a2:	4b07      	ldr	r3, [pc, #28]	; (80019c0 <_heap_init+0x20>)
 80019a4:	4a07      	ldr	r2, [pc, #28]	; (80019c4 <_heap_init+0x24>)
 80019a6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 80019a8:	4b05      	ldr	r3, [pc, #20]	; (80019c0 <_heap_init+0x20>)
 80019aa:	2200      	movs	r2, #0
 80019ac:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80019ae:	4b04      	ldr	r3, [pc, #16]	; (80019c0 <_heap_init+0x20>)
 80019b0:	2200      	movs	r2, #0
 80019b2:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 80019b4:	4b04      	ldr	r3, [pc, #16]	; (80019c8 <_heap_init+0x28>)
 80019b6:	1c18      	adds	r0, r3, #0
 80019b8:	f7ff ff6a 	bl	8001890 <chMtxObjectInit.4395>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 80019bc:	bd08      	pop	{r3, pc}
 80019be:	46c0      	nop			; (mov r8, r8)
 80019c0:	20000430 	.word	0x20000430
 80019c4:	08001921 	.word	0x08001921
 80019c8:	20000440 	.word	0x20000440
 80019cc:	46c0      	nop			; (mov r8, r8)
 80019ce:	46c0      	nop			; (mov r8, r8)

080019d0 <port_lock.5920.4262>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80019d0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80019d2:	4770      	bx	lr
 80019d4:	46c0      	nop			; (mov r8, r8)
 80019d6:	46c0      	nop			; (mov r8, r8)
 80019d8:	46c0      	nop			; (mov r8, r8)
 80019da:	46c0      	nop			; (mov r8, r8)
 80019dc:	46c0      	nop			; (mov r8, r8)
 80019de:	46c0      	nop			; (mov r8, r8)

080019e0 <port_unlock.5923.4260>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80019e0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80019e2:	4770      	bx	lr
 80019e4:	46c0      	nop			; (mov r8, r8)
 80019e6:	46c0      	nop			; (mov r8, r8)
 80019e8:	46c0      	nop			; (mov r8, r8)
 80019ea:	46c0      	nop			; (mov r8, r8)
 80019ec:	46c0      	nop			; (mov r8, r8)
 80019ee:	46c0      	nop			; (mov r8, r8)

080019f0 <port_lock_from_isr.5925.4258>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80019f0:	b508      	push	{r3, lr}

  port_lock();
 80019f2:	f7ff ffed 	bl	80019d0 <port_lock.5920.4262>
}
 80019f6:	bd08      	pop	{r3, pc}
 80019f8:	46c0      	nop			; (mov r8, r8)
 80019fa:	46c0      	nop			; (mov r8, r8)
 80019fc:	46c0      	nop			; (mov r8, r8)
 80019fe:	46c0      	nop			; (mov r8, r8)

08001a00 <port_unlock_from_isr.5927.4256>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001a00:	b508      	push	{r3, lr}

  port_unlock();
 8001a02:	f7ff ffed 	bl	80019e0 <port_unlock.5923.4260>
}
 8001a06:	bd08      	pop	{r3, pc}
 8001a08:	46c0      	nop			; (mov r8, r8)
 8001a0a:	46c0      	nop			; (mov r8, r8)
 8001a0c:	46c0      	nop			; (mov r8, r8)
 8001a0e:	46c0      	nop			; (mov r8, r8)

08001a10 <NMI_Handler>:
 * @brief   NMI vector.
 * @details The NMI vector is used for exception mode re-entering after a
 *          context switch.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void NMI_Handler(void) {
 8001a10:	b510      	push	{r4, lr}
 8001a12:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001a14:	f3ef 8309 	mrs	r3, PSP
 8001a18:	1c1c      	adds	r4, r3, #0
  return(result);
 8001a1a:	1c23      	adds	r3, r4, #0
/*lint -restore*/

  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();
 8001a1c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8001a1e:	9b01      	ldr	r3, [sp, #4]
 8001a20:	3320      	adds	r3, #32
 8001a22:	9301      	str	r3, [sp, #4]

  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);
 8001a24:	9b01      	ldr	r3, [sp, #4]
 8001a26:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001a28:	9b00      	ldr	r3, [sp, #0]
 8001a2a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8001a2e:	f7ff ffe7 	bl	8001a00 <port_unlock_from_isr.5927.4256>
}
 8001a32:	b002      	add	sp, #8
 8001a34:	bd10      	pop	{r4, pc}
 8001a36:	46c0      	nop			; (mov r8, r8)
 8001a38:	46c0      	nop			; (mov r8, r8)
 8001a3a:	46c0      	nop			; (mov r8, r8)
 8001a3c:	46c0      	nop			; (mov r8, r8)
 8001a3e:	46c0      	nop			; (mov r8, r8)

08001a40 <_port_irq_epilogue>:
/**
 * @brief   IRQ epilogue code.
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {
 8001a40:	b510      	push	{r4, lr}
 8001a42:	b084      	sub	sp, #16
 8001a44:	9001      	str	r0, [sp, #4]

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8001a46:	9b01      	ldr	r3, [sp, #4]
 8001a48:	1c1a      	adds	r2, r3, #0
 8001a4a:	320f      	adds	r2, #15
 8001a4c:	d01e      	beq.n	8001a8c <_port_irq_epilogue+0x4c>
    struct port_extctx *ctxp;

    port_lock_from_isr();
 8001a4e:	f7ff ffcf 	bl	80019f0 <port_lock_from_isr.5925.4258>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001a52:	f3ef 8309 	mrs	r3, PSP
 8001a56:	1c1c      	adds	r4, r3, #0
  return(result);
 8001a58:	1c23      	adds	r3, r4, #0

    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8001a5a:	9303      	str	r3, [sp, #12]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001a5c:	9b03      	ldr	r3, [sp, #12]
 8001a5e:	3b20      	subs	r3, #32
 8001a60:	9303      	str	r3, [sp, #12]

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8001a62:	9b03      	ldr	r3, [sp, #12]
 8001a64:	9302      	str	r3, [sp, #8]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001a66:	9b02      	ldr	r3, [sp, #8]
 8001a68:	f383 8809 	msr	PSP, r3

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001a6c:	9b03      	ldr	r3, [sp, #12]
 8001a6e:	2280      	movs	r2, #128	; 0x80
 8001a70:	0452      	lsls	r2, r2, #17
 8001a72:	61da      	str	r2, [r3, #28]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001a74:	f001 f90c 	bl	8002c90 <chSchIsPreemptionRequired>
 8001a78:	1c03      	adds	r3, r0, #0
 8001a7a:	2b00      	cmp	r3, #0
 8001a7c:	d003      	beq.n	8001a86 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001a7e:	9b03      	ldr	r3, [sp, #12]
 8001a80:	4a03      	ldr	r2, [pc, #12]	; (8001a90 <_port_irq_epilogue+0x50>)
 8001a82:	619a      	str	r2, [r3, #24]
 8001a84:	e002      	b.n	8001a8c <_port_irq_epilogue+0x4c>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001a86:	9b03      	ldr	r3, [sp, #12]
 8001a88:	4a02      	ldr	r2, [pc, #8]	; (8001a94 <_port_irq_epilogue+0x54>)
 8001a8a:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8001a8c:	b004      	add	sp, #16
 8001a8e:	bd10      	pop	{r4, pc}
 8001a90:	080001bd 	.word	0x080001bd
 8001a94:	080001c0 	.word	0x080001c0
 8001a98:	46c0      	nop			; (mov r8, r8)
 8001a9a:	46c0      	nop			; (mov r8, r8)
 8001a9c:	46c0      	nop			; (mov r8, r8)
 8001a9e:	46c0      	nop			; (mov r8, r8)

08001aa0 <osalInit.5962.4246>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8001aa0:	4770      	bx	lr
 8001aa2:	46c0      	nop			; (mov r8, r8)
 8001aa4:	46c0      	nop			; (mov r8, r8)
 8001aa6:	46c0      	nop			; (mov r8, r8)
 8001aa8:	46c0      	nop			; (mov r8, r8)
 8001aaa:	46c0      	nop			; (mov r8, r8)
 8001aac:	46c0      	nop			; (mov r8, r8)
 8001aae:	46c0      	nop			; (mov r8, r8)

08001ab0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001ab0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8001ab2:	f7ff fff5 	bl	8001aa0 <osalInit.5962.4246>

  /* Platform low level initializations.*/
  hal_lld_init();
 8001ab6:	f7ff fb93 	bl	80011e0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001aba:	4b06      	ldr	r3, [pc, #24]	; (8001ad4 <halInit+0x24>)
 8001abc:	1c18      	adds	r0, r3, #0
 8001abe:	f7fe fc67 	bl	8000390 <_pal_lld_init>
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
#endif
#if (HAL_USE_EXT == TRUE) || defined(__DOXYGEN__)
  extInit();
 8001ac2:	f000 fb7d 	bl	80021c0 <extInit.4042>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8001ac6:	f7ff fa7b 	bl	8000fc0 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8001aca:	f7fe ff11 	bl	80008f0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001ace:	f000 f837 	bl	8001b40 <stInit.4231>
#endif
}
 8001ad2:	bd08      	pop	{r3, pc}
 8001ad4:	08003090 	.word	0x08003090
 8001ad8:	46c0      	nop			; (mov r8, r8)
 8001ada:	46c0      	nop			; (mov r8, r8)
 8001adc:	46c0      	nop			; (mov r8, r8)
 8001ade:	46c0      	nop			; (mov r8, r8)

08001ae0 <st_lld_start_alarm.5991.4240>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8001ae0:	b082      	sub	sp, #8
 8001ae2:	1c02      	adds	r2, r0, #0
 8001ae4:	466b      	mov	r3, sp
 8001ae6:	3306      	adds	r3, #6
 8001ae8:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001aea:	4b06      	ldr	r3, [pc, #24]	; (8001b04 <st_lld_start_alarm.5991.4240+0x24>)
 8001aec:	466a      	mov	r2, sp
 8001aee:	3206      	adds	r2, #6
 8001af0:	8812      	ldrh	r2, [r2, #0]
 8001af2:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001af4:	4b03      	ldr	r3, [pc, #12]	; (8001b04 <st_lld_start_alarm.5991.4240+0x24>)
 8001af6:	2200      	movs	r2, #0
 8001af8:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001afa:	4b02      	ldr	r3, [pc, #8]	; (8001b04 <st_lld_start_alarm.5991.4240+0x24>)
 8001afc:	2202      	movs	r2, #2
 8001afe:	60da      	str	r2, [r3, #12]
}
 8001b00:	b002      	add	sp, #8
 8001b02:	4770      	bx	lr
 8001b04:	40000400 	.word	0x40000400
 8001b08:	46c0      	nop			; (mov r8, r8)
 8001b0a:	46c0      	nop			; (mov r8, r8)
 8001b0c:	46c0      	nop			; (mov r8, r8)
 8001b0e:	46c0      	nop			; (mov r8, r8)

08001b10 <st_lld_stop_alarm.5998.4238>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001b10:	4b01      	ldr	r3, [pc, #4]	; (8001b18 <st_lld_stop_alarm.5998.4238+0x8>)
 8001b12:	2200      	movs	r2, #0
 8001b14:	60da      	str	r2, [r3, #12]
}
 8001b16:	4770      	bx	lr
 8001b18:	40000400 	.word	0x40000400
 8001b1c:	46c0      	nop			; (mov r8, r8)
 8001b1e:	46c0      	nop			; (mov r8, r8)

08001b20 <st_lld_set_alarm.6000.4235>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8001b20:	b082      	sub	sp, #8
 8001b22:	1c02      	adds	r2, r0, #0
 8001b24:	466b      	mov	r3, sp
 8001b26:	3306      	adds	r3, #6
 8001b28:	801a      	strh	r2, [r3, #0]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001b2a:	4b03      	ldr	r3, [pc, #12]	; (8001b38 <st_lld_set_alarm.6000.4235+0x18>)
 8001b2c:	466a      	mov	r2, sp
 8001b2e:	3206      	adds	r2, #6
 8001b30:	8812      	ldrh	r2, [r2, #0]
 8001b32:	635a      	str	r2, [r3, #52]	; 0x34
}
 8001b34:	b002      	add	sp, #8
 8001b36:	4770      	bx	lr
 8001b38:	40000400 	.word	0x40000400
 8001b3c:	46c0      	nop			; (mov r8, r8)
 8001b3e:	46c0      	nop			; (mov r8, r8)

08001b40 <stInit.4231>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8001b40:	b508      	push	{r3, lr}

  st_lld_init();
 8001b42:	f7ff fc55 	bl	80013f0 <st_lld_init>
}
 8001b46:	bd08      	pop	{r3, pc}
 8001b48:	46c0      	nop			; (mov r8, r8)
 8001b4a:	46c0      	nop			; (mov r8, r8)
 8001b4c:	46c0      	nop			; (mov r8, r8)
 8001b4e:	46c0      	nop			; (mov r8, r8)

08001b50 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8001b50:	b500      	push	{lr}
 8001b52:	b083      	sub	sp, #12
 8001b54:	1c02      	adds	r2, r0, #0
 8001b56:	466b      	mov	r3, sp
 8001b58:	3306      	adds	r3, #6
 8001b5a:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8001b5c:	466b      	mov	r3, sp
 8001b5e:	3306      	adds	r3, #6
 8001b60:	881b      	ldrh	r3, [r3, #0]
 8001b62:	1c18      	adds	r0, r3, #0
 8001b64:	f7ff ffbc 	bl	8001ae0 <st_lld_start_alarm.5991.4240>
}
 8001b68:	b003      	add	sp, #12
 8001b6a:	bd00      	pop	{pc}
 8001b6c:	46c0      	nop			; (mov r8, r8)
 8001b6e:	46c0      	nop			; (mov r8, r8)

08001b70 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8001b70:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8001b72:	f7ff ffcd 	bl	8001b10 <st_lld_stop_alarm.5998.4238>
}
 8001b76:	bd08      	pop	{r3, pc}
 8001b78:	46c0      	nop			; (mov r8, r8)
 8001b7a:	46c0      	nop			; (mov r8, r8)
 8001b7c:	46c0      	nop			; (mov r8, r8)
 8001b7e:	46c0      	nop			; (mov r8, r8)

08001b80 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8001b80:	b500      	push	{lr}
 8001b82:	b083      	sub	sp, #12
 8001b84:	1c02      	adds	r2, r0, #0
 8001b86:	466b      	mov	r3, sp
 8001b88:	3306      	adds	r3, #6
 8001b8a:	801a      	strh	r2, [r3, #0]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8001b8c:	466b      	mov	r3, sp
 8001b8e:	3306      	adds	r3, #6
 8001b90:	881b      	ldrh	r3, [r3, #0]
 8001b92:	1c18      	adds	r0, r3, #0
 8001b94:	f7ff ffc4 	bl	8001b20 <st_lld_set_alarm.6000.4235>
}
 8001b98:	b003      	add	sp, #12
 8001b9a:	bd00      	pop	{pc}
 8001b9c:	46c0      	nop			; (mov r8, r8)
 8001b9e:	46c0      	nop			; (mov r8, r8)

08001ba0 <port_lock.6049.4218>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001ba0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8001ba2:	4770      	bx	lr
 8001ba4:	46c0      	nop			; (mov r8, r8)
 8001ba6:	46c0      	nop			; (mov r8, r8)
 8001ba8:	46c0      	nop			; (mov r8, r8)
 8001baa:	46c0      	nop			; (mov r8, r8)
 8001bac:	46c0      	nop			; (mov r8, r8)
 8001bae:	46c0      	nop			; (mov r8, r8)

08001bb0 <port_unlock.6052.4216>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001bb0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8001bb2:	4770      	bx	lr
 8001bb4:	46c0      	nop			; (mov r8, r8)
 8001bb6:	46c0      	nop			; (mov r8, r8)
 8001bb8:	46c0      	nop			; (mov r8, r8)
 8001bba:	46c0      	nop			; (mov r8, r8)
 8001bbc:	46c0      	nop			; (mov r8, r8)
 8001bbe:	46c0      	nop			; (mov r8, r8)

08001bc0 <queue_init.6054.4213>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001bc0:	b082      	sub	sp, #8
 8001bc2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001bc4:	9b01      	ldr	r3, [sp, #4]
 8001bc6:	9a01      	ldr	r2, [sp, #4]
 8001bc8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001bca:	9b01      	ldr	r3, [sp, #4]
 8001bcc:	9a01      	ldr	r2, [sp, #4]
 8001bce:	605a      	str	r2, [r3, #4]
}
 8001bd0:	b002      	add	sp, #8
 8001bd2:	4770      	bx	lr
 8001bd4:	46c0      	nop			; (mov r8, r8)
 8001bd6:	46c0      	nop			; (mov r8, r8)
 8001bd8:	46c0      	nop			; (mov r8, r8)
 8001bda:	46c0      	nop			; (mov r8, r8)
 8001bdc:	46c0      	nop			; (mov r8, r8)
 8001bde:	46c0      	nop			; (mov r8, r8)

08001be0 <chSysLock.6120.4211>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8001be0:	b508      	push	{r3, lr}

  port_lock();
 8001be2:	f7ff ffdd 	bl	8001ba0 <port_lock.6049.4218>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001be6:	bd08      	pop	{r3, pc}
 8001be8:	46c0      	nop			; (mov r8, r8)
 8001bea:	46c0      	nop			; (mov r8, r8)
 8001bec:	46c0      	nop			; (mov r8, r8)
 8001bee:	46c0      	nop			; (mov r8, r8)

08001bf0 <chSysUnlock.6122.4209>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001bf0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001bf2:	f7ff ffdd 	bl	8001bb0 <port_unlock.6052.4216>
}
 8001bf6:	bd08      	pop	{r3, pc}
 8001bf8:	46c0      	nop			; (mov r8, r8)
 8001bfa:	46c0      	nop			; (mov r8, r8)
 8001bfc:	46c0      	nop			; (mov r8, r8)
 8001bfe:	46c0      	nop			; (mov r8, r8)

08001c00 <chThdQueueObjectInit.6124.4206>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8001c00:	b500      	push	{lr}
 8001c02:	b083      	sub	sp, #12
 8001c04:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8001c06:	9b01      	ldr	r3, [sp, #4]
 8001c08:	1c18      	adds	r0, r3, #0
 8001c0a:	f7ff ffd9 	bl	8001bc0 <queue_init.6054.4213>
}
 8001c0e:	b003      	add	sp, #12
 8001c10:	bd00      	pop	{pc}
 8001c12:	46c0      	nop			; (mov r8, r8)
 8001c14:	46c0      	nop			; (mov r8, r8)
 8001c16:	46c0      	nop			; (mov r8, r8)
 8001c18:	46c0      	nop			; (mov r8, r8)
 8001c1a:	46c0      	nop			; (mov r8, r8)
 8001c1c:	46c0      	nop			; (mov r8, r8)
 8001c1e:	46c0      	nop			; (mov r8, r8)

08001c20 <osalSysLock.6127.4204>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8001c20:	b508      	push	{r3, lr}

  chSysLock();
 8001c22:	f7ff ffdd 	bl	8001be0 <chSysLock.6120.4211>
}
 8001c26:	bd08      	pop	{r3, pc}
 8001c28:	46c0      	nop			; (mov r8, r8)
 8001c2a:	46c0      	nop			; (mov r8, r8)
 8001c2c:	46c0      	nop			; (mov r8, r8)
 8001c2e:	46c0      	nop			; (mov r8, r8)

08001c30 <osalSysUnlock.6129.4202>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8001c30:	b508      	push	{r3, lr}

  chSysUnlock();
 8001c32:	f7ff ffdd 	bl	8001bf0 <chSysUnlock.6122.4209>
}
 8001c36:	bd08      	pop	{r3, pc}
 8001c38:	46c0      	nop			; (mov r8, r8)
 8001c3a:	46c0      	nop			; (mov r8, r8)
 8001c3c:	46c0      	nop			; (mov r8, r8)
 8001c3e:	46c0      	nop			; (mov r8, r8)

08001c40 <osalThreadQueueObjectInit.6131.4199>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8001c40:	b500      	push	{lr}
 8001c42:	b083      	sub	sp, #12
 8001c44:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8001c46:	9b01      	ldr	r3, [sp, #4]
 8001c48:	1c18      	adds	r0, r3, #0
 8001c4a:	f7ff ffd9 	bl	8001c00 <chThdQueueObjectInit.6124.4206>
}
 8001c4e:	b003      	add	sp, #12
 8001c50:	bd00      	pop	{pc}
 8001c52:	46c0      	nop			; (mov r8, r8)
 8001c54:	46c0      	nop			; (mov r8, r8)
 8001c56:	46c0      	nop			; (mov r8, r8)
 8001c58:	46c0      	nop			; (mov r8, r8)
 8001c5a:	46c0      	nop			; (mov r8, r8)
 8001c5c:	46c0      	nop			; (mov r8, r8)
 8001c5e:	46c0      	nop			; (mov r8, r8)

08001c60 <osalThreadEnqueueTimeoutS.6142.4195>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8001c60:	b500      	push	{lr}
 8001c62:	b083      	sub	sp, #12
 8001c64:	9001      	str	r0, [sp, #4]
 8001c66:	1c0a      	adds	r2, r1, #0
 8001c68:	466b      	mov	r3, sp
 8001c6a:	3302      	adds	r3, #2
 8001c6c:	801a      	strh	r2, [r3, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8001c6e:	9a01      	ldr	r2, [sp, #4]
 8001c70:	466b      	mov	r3, sp
 8001c72:	3302      	adds	r3, #2
 8001c74:	881b      	ldrh	r3, [r3, #0]
 8001c76:	1c10      	adds	r0, r2, #0
 8001c78:	1c19      	adds	r1, r3, #0
 8001c7a:	f001 f981 	bl	8002f80 <chThdEnqueueTimeoutS>
 8001c7e:	1c03      	adds	r3, r0, #0
}
 8001c80:	1c18      	adds	r0, r3, #0
 8001c82:	b003      	add	sp, #12
 8001c84:	bd00      	pop	{pc}
 8001c86:	46c0      	nop			; (mov r8, r8)
 8001c88:	46c0      	nop			; (mov r8, r8)
 8001c8a:	46c0      	nop			; (mov r8, r8)
 8001c8c:	46c0      	nop			; (mov r8, r8)
 8001c8e:	46c0      	nop			; (mov r8, r8)

08001c90 <osalThreadDequeueNextI.6138.4191>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001c90:	b500      	push	{lr}
 8001c92:	b083      	sub	sp, #12
 8001c94:	9001      	str	r0, [sp, #4]
 8001c96:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8001c98:	9a01      	ldr	r2, [sp, #4]
 8001c9a:	9b00      	ldr	r3, [sp, #0]
 8001c9c:	1c10      	adds	r0, r2, #0
 8001c9e:	1c19      	adds	r1, r3, #0
 8001ca0:	f001 f996 	bl	8002fd0 <chThdDequeueNextI>
}
 8001ca4:	b003      	add	sp, #12
 8001ca6:	bd00      	pop	{pc}
 8001ca8:	46c0      	nop			; (mov r8, r8)
 8001caa:	46c0      	nop			; (mov r8, r8)
 8001cac:	46c0      	nop			; (mov r8, r8)
 8001cae:	46c0      	nop			; (mov r8, r8)

08001cb0 <osalThreadDequeueAllI.6134.4187>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001cb0:	b500      	push	{lr}
 8001cb2:	b083      	sub	sp, #12
 8001cb4:	9001      	str	r0, [sp, #4]
 8001cb6:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8001cb8:	9a01      	ldr	r2, [sp, #4]
 8001cba:	9b00      	ldr	r3, [sp, #0]
 8001cbc:	1c10      	adds	r0, r2, #0
 8001cbe:	1c19      	adds	r1, r3, #0
 8001cc0:	f001 f99e 	bl	8003000 <chThdDequeueAllI>
}
 8001cc4:	b003      	add	sp, #12
 8001cc6:	bd00      	pop	{pc}
 8001cc8:	46c0      	nop			; (mov r8, r8)
 8001cca:	46c0      	nop			; (mov r8, r8)
 8001ccc:	46c0      	nop			; (mov r8, r8)
 8001cce:	46c0      	nop			; (mov r8, r8)

08001cd0 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8001cd0:	b500      	push	{lr}
 8001cd2:	b085      	sub	sp, #20
 8001cd4:	9003      	str	r0, [sp, #12]
 8001cd6:	9102      	str	r1, [sp, #8]
 8001cd8:	9201      	str	r2, [sp, #4]
 8001cda:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&iqp->q_waiting);
 8001cdc:	9b03      	ldr	r3, [sp, #12]
 8001cde:	1c18      	adds	r0, r3, #0
 8001ce0:	f7ff ffae 	bl	8001c40 <osalThreadQueueObjectInit.6131.4199>
  iqp->q_counter = 0;
 8001ce4:	9b03      	ldr	r3, [sp, #12]
 8001ce6:	2200      	movs	r2, #0
 8001ce8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 8001cea:	9b03      	ldr	r3, [sp, #12]
 8001cec:	9a02      	ldr	r2, [sp, #8]
 8001cee:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 8001cf0:	9b03      	ldr	r3, [sp, #12]
 8001cf2:	9a02      	ldr	r2, [sp, #8]
 8001cf4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 8001cf6:	9b03      	ldr	r3, [sp, #12]
 8001cf8:	9a02      	ldr	r2, [sp, #8]
 8001cfa:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 8001cfc:	9a02      	ldr	r2, [sp, #8]
 8001cfe:	9b01      	ldr	r3, [sp, #4]
 8001d00:	18d2      	adds	r2, r2, r3
 8001d02:	9b03      	ldr	r3, [sp, #12]
 8001d04:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8001d06:	9b03      	ldr	r3, [sp, #12]
 8001d08:	9a00      	ldr	r2, [sp, #0]
 8001d0a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 8001d0c:	9b03      	ldr	r3, [sp, #12]
 8001d0e:	9a06      	ldr	r2, [sp, #24]
 8001d10:	621a      	str	r2, [r3, #32]
}
 8001d12:	b005      	add	sp, #20
 8001d14:	bd00      	pop	{pc}
 8001d16:	46c0      	nop			; (mov r8, r8)
 8001d18:	46c0      	nop			; (mov r8, r8)
 8001d1a:	46c0      	nop			; (mov r8, r8)
 8001d1c:	46c0      	nop			; (mov r8, r8)
 8001d1e:	46c0      	nop			; (mov r8, r8)

08001d20 <iqResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void iqResetI(input_queue_t *iqp) {
 8001d20:	b500      	push	{lr}
 8001d22:	b083      	sub	sp, #12
 8001d24:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 8001d26:	9b01      	ldr	r3, [sp, #4]
 8001d28:	68da      	ldr	r2, [r3, #12]
 8001d2a:	9b01      	ldr	r3, [sp, #4]
 8001d2c:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr = iqp->q_buffer;
 8001d2e:	9b01      	ldr	r3, [sp, #4]
 8001d30:	68da      	ldr	r2, [r3, #12]
 8001d32:	9b01      	ldr	r3, [sp, #4]
 8001d34:	615a      	str	r2, [r3, #20]
  iqp->q_counter = 0;
 8001d36:	9b01      	ldr	r3, [sp, #4]
 8001d38:	2200      	movs	r2, #0
 8001d3a:	609a      	str	r2, [r3, #8]
  osalThreadDequeueAllI(&iqp->q_waiting, Q_RESET);
 8001d3c:	9a01      	ldr	r2, [sp, #4]
 8001d3e:	2302      	movs	r3, #2
 8001d40:	425b      	negs	r3, r3
 8001d42:	1c10      	adds	r0, r2, #0
 8001d44:	1c19      	adds	r1, r3, #0
 8001d46:	f7ff ffb3 	bl	8001cb0 <osalThreadDequeueAllI.6134.4187>
}
 8001d4a:	b003      	add	sp, #12
 8001d4c:	bd00      	pop	{pc}
 8001d4e:	46c0      	nop			; (mov r8, r8)

08001d50 <iqPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8001d50:	b500      	push	{lr}
 8001d52:	b083      	sub	sp, #12
 8001d54:	9001      	str	r0, [sp, #4]
 8001d56:	1c0a      	adds	r2, r1, #0
 8001d58:	466b      	mov	r3, sp
 8001d5a:	3303      	adds	r3, #3
 8001d5c:	701a      	strb	r2, [r3, #0]

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8001d5e:	9b01      	ldr	r3, [sp, #4]
 8001d60:	695a      	ldr	r2, [r3, #20]
 8001d62:	9b01      	ldr	r3, [sp, #4]
 8001d64:	699b      	ldr	r3, [r3, #24]
 8001d66:	429a      	cmp	r2, r3
 8001d68:	d105      	bne.n	8001d76 <iqPutI+0x26>
 8001d6a:	9b01      	ldr	r3, [sp, #4]
 8001d6c:	689b      	ldr	r3, [r3, #8]
 8001d6e:	2b00      	cmp	r3, #0
 8001d70:	d001      	beq.n	8001d76 <iqPutI+0x26>
 8001d72:	2301      	movs	r3, #1
 8001d74:	e000      	b.n	8001d78 <iqPutI+0x28>
 8001d76:	2300      	movs	r3, #0
 8001d78:	1c1a      	adds	r2, r3, #0
 8001d7a:	2301      	movs	r3, #1
 8001d7c:	4013      	ands	r3, r2
 8001d7e:	b2db      	uxtb	r3, r3
 8001d80:	2b00      	cmp	r3, #0
 8001d82:	d002      	beq.n	8001d8a <iqPutI+0x3a>
    return Q_FULL;
 8001d84:	2304      	movs	r3, #4
 8001d86:	425b      	negs	r3, r3
 8001d88:	e01d      	b.n	8001dc6 <iqPutI+0x76>
  }

  iqp->q_counter++;
 8001d8a:	9b01      	ldr	r3, [sp, #4]
 8001d8c:	689b      	ldr	r3, [r3, #8]
 8001d8e:	1c5a      	adds	r2, r3, #1
 8001d90:	9b01      	ldr	r3, [sp, #4]
 8001d92:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8001d94:	9b01      	ldr	r3, [sp, #4]
 8001d96:	695b      	ldr	r3, [r3, #20]
 8001d98:	1c59      	adds	r1, r3, #1
 8001d9a:	9a01      	ldr	r2, [sp, #4]
 8001d9c:	6151      	str	r1, [r2, #20]
 8001d9e:	466a      	mov	r2, sp
 8001da0:	3203      	adds	r2, #3
 8001da2:	7812      	ldrb	r2, [r2, #0]
 8001da4:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8001da6:	9b01      	ldr	r3, [sp, #4]
 8001da8:	695a      	ldr	r2, [r3, #20]
 8001daa:	9b01      	ldr	r3, [sp, #4]
 8001dac:	691b      	ldr	r3, [r3, #16]
 8001dae:	429a      	cmp	r2, r3
 8001db0:	d303      	bcc.n	8001dba <iqPutI+0x6a>
    iqp->q_wrptr = iqp->q_buffer;
 8001db2:	9b01      	ldr	r3, [sp, #4]
 8001db4:	68da      	ldr	r2, [r3, #12]
 8001db6:	9b01      	ldr	r3, [sp, #4]
 8001db8:	615a      	str	r2, [r3, #20]
  }

  osalThreadDequeueNextI(&iqp->q_waiting, Q_OK);
 8001dba:	9b01      	ldr	r3, [sp, #4]
 8001dbc:	1c18      	adds	r0, r3, #0
 8001dbe:	2100      	movs	r1, #0
 8001dc0:	f7ff ff66 	bl	8001c90 <osalThreadDequeueNextI.6138.4191>

  return Q_OK;
 8001dc4:	2300      	movs	r3, #0
}
 8001dc6:	1c18      	adds	r0, r3, #0
 8001dc8:	b003      	add	sp, #12
 8001dca:	bd00      	pop	{pc}
 8001dcc:	46c0      	nop			; (mov r8, r8)
 8001dce:	46c0      	nop			; (mov r8, r8)

08001dd0 <iqGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8001dd0:	b500      	push	{lr}
 8001dd2:	b085      	sub	sp, #20
 8001dd4:	9001      	str	r0, [sp, #4]
 8001dd6:	1c0a      	adds	r2, r1, #0
 8001dd8:	466b      	mov	r3, sp
 8001dda:	3302      	adds	r3, #2
 8001ddc:	801a      	strh	r2, [r3, #0]
  uint8_t b;

  osalSysLock();
 8001dde:	f7ff ff1f 	bl	8001c20 <osalSysLock.6127.4204>
  if (iqp->q_notify != NULL) {
 8001de2:	9b01      	ldr	r3, [sp, #4]
 8001de4:	69db      	ldr	r3, [r3, #28]
 8001de6:	2b00      	cmp	r3, #0
 8001de8:	d016      	beq.n	8001e18 <iqGetTimeout+0x48>
    iqp->q_notify(iqp);
 8001dea:	9b01      	ldr	r3, [sp, #4]
 8001dec:	69db      	ldr	r3, [r3, #28]
 8001dee:	9a01      	ldr	r2, [sp, #4]
 8001df0:	1c10      	adds	r0, r2, #0
 8001df2:	4798      	blx	r3
 8001df4:	e010      	b.n	8001e18 <iqGetTimeout+0x48>
  }

  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8001df6:	9a01      	ldr	r2, [sp, #4]
 8001df8:	466b      	mov	r3, sp
 8001dfa:	3302      	adds	r3, #2
 8001dfc:	881b      	ldrh	r3, [r3, #0]
 8001dfe:	1c10      	adds	r0, r2, #0
 8001e00:	1c19      	adds	r1, r3, #0
 8001e02:	f7ff ff2d 	bl	8001c60 <osalThreadEnqueueTimeoutS.6142.4195>
 8001e06:	1c03      	adds	r3, r0, #0
 8001e08:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 8001e0a:	9b03      	ldr	r3, [sp, #12]
 8001e0c:	2b00      	cmp	r3, #0
 8001e0e:	da03      	bge.n	8001e18 <iqGetTimeout+0x48>
      osalSysUnlock();
 8001e10:	f7ff ff0e 	bl	8001c30 <osalSysUnlock.6129.4202>
      return msg;
 8001e14:	9b03      	ldr	r3, [sp, #12]
 8001e16:	e020      	b.n	8001e5a <iqGetTimeout+0x8a>
  osalSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (iqIsEmptyI(iqp)) {
 8001e18:	9b01      	ldr	r3, [sp, #4]
 8001e1a:	689b      	ldr	r3, [r3, #8]
 8001e1c:	2b00      	cmp	r3, #0
 8001e1e:	d0ea      	beq.n	8001df6 <iqGetTimeout+0x26>
      osalSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001e20:	9b01      	ldr	r3, [sp, #4]
 8001e22:	689b      	ldr	r3, [r3, #8]
 8001e24:	1e5a      	subs	r2, r3, #1
 8001e26:	9b01      	ldr	r3, [sp, #4]
 8001e28:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 8001e2a:	9b01      	ldr	r3, [sp, #4]
 8001e2c:	699b      	ldr	r3, [r3, #24]
 8001e2e:	1c59      	adds	r1, r3, #1
 8001e30:	9a01      	ldr	r2, [sp, #4]
 8001e32:	6191      	str	r1, [r2, #24]
 8001e34:	466a      	mov	r2, sp
 8001e36:	320b      	adds	r2, #11
 8001e38:	781b      	ldrb	r3, [r3, #0]
 8001e3a:	7013      	strb	r3, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001e3c:	9b01      	ldr	r3, [sp, #4]
 8001e3e:	699a      	ldr	r2, [r3, #24]
 8001e40:	9b01      	ldr	r3, [sp, #4]
 8001e42:	691b      	ldr	r3, [r3, #16]
 8001e44:	429a      	cmp	r2, r3
 8001e46:	d303      	bcc.n	8001e50 <iqGetTimeout+0x80>
    iqp->q_rdptr = iqp->q_buffer;
 8001e48:	9b01      	ldr	r3, [sp, #4]
 8001e4a:	68da      	ldr	r2, [r3, #12]
 8001e4c:	9b01      	ldr	r3, [sp, #4]
 8001e4e:	619a      	str	r2, [r3, #24]
  }
  osalSysUnlock();
 8001e50:	f7ff feee 	bl	8001c30 <osalSysUnlock.6129.4202>

  return (msg_t)b;
 8001e54:	466b      	mov	r3, sp
 8001e56:	330b      	adds	r3, #11
 8001e58:	781b      	ldrb	r3, [r3, #0]
}
 8001e5a:	1c18      	adds	r0, r3, #0
 8001e5c:	b005      	add	sp, #20
 8001e5e:	bd00      	pop	{pc}

08001e60 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8001e60:	b500      	push	{lr}
 8001e62:	b087      	sub	sp, #28
 8001e64:	9003      	str	r0, [sp, #12]
 8001e66:	9102      	str	r1, [sp, #8]
 8001e68:	9201      	str	r2, [sp, #4]
 8001e6a:	1c1a      	adds	r2, r3, #0
 8001e6c:	466b      	mov	r3, sp
 8001e6e:	3302      	adds	r3, #2
 8001e70:	801a      	strh	r2, [r3, #0]
  qnotify_t nfy = iqp->q_notify;
 8001e72:	9b03      	ldr	r3, [sp, #12]
 8001e74:	69db      	ldr	r3, [r3, #28]
 8001e76:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8001e78:	2300      	movs	r3, #0
 8001e7a:	9305      	str	r3, [sp, #20]

  osalDbgCheck(n > 0U);

  osalSysLock();
 8001e7c:	f7ff fed0 	bl	8001c20 <osalSysLock.6127.4204>
  while (true) {
    if (nfy != NULL) {
 8001e80:	9b04      	ldr	r3, [sp, #16]
 8001e82:	2b00      	cmp	r3, #0
 8001e84:	d013      	beq.n	8001eae <iqReadTimeout+0x4e>
      nfy(iqp);
 8001e86:	9a03      	ldr	r2, [sp, #12]
 8001e88:	9b04      	ldr	r3, [sp, #16]
 8001e8a:	1c10      	adds	r0, r2, #0
 8001e8c:	4798      	blx	r3
 8001e8e:	e00e      	b.n	8001eae <iqReadTimeout+0x4e>
    }

    while (iqIsEmptyI(iqp)) {
      if (osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8001e90:	9a03      	ldr	r2, [sp, #12]
 8001e92:	466b      	mov	r3, sp
 8001e94:	3302      	adds	r3, #2
 8001e96:	881b      	ldrh	r3, [r3, #0]
 8001e98:	1c10      	adds	r0, r2, #0
 8001e9a:	1c19      	adds	r1, r3, #0
 8001e9c:	f7ff fee0 	bl	8001c60 <osalThreadEnqueueTimeoutS.6142.4195>
 8001ea0:	1c03      	adds	r3, r0, #0
 8001ea2:	2b00      	cmp	r3, #0
 8001ea4:	d003      	beq.n	8001eae <iqReadTimeout+0x4e>
        osalSysUnlock();
 8001ea6:	f7ff fec3 	bl	8001c30 <osalSysUnlock.6129.4202>
        return r;
 8001eaa:	9b05      	ldr	r3, [sp, #20]
 8001eac:	e02c      	b.n	8001f08 <iqReadTimeout+0xa8>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (iqIsEmptyI(iqp)) {
 8001eae:	9b03      	ldr	r3, [sp, #12]
 8001eb0:	689b      	ldr	r3, [r3, #8]
 8001eb2:	2b00      	cmp	r3, #0
 8001eb4:	d0ec      	beq.n	8001e90 <iqReadTimeout+0x30>
        osalSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001eb6:	9b03      	ldr	r3, [sp, #12]
 8001eb8:	689b      	ldr	r3, [r3, #8]
 8001eba:	1e5a      	subs	r2, r3, #1
 8001ebc:	9b03      	ldr	r3, [sp, #12]
 8001ebe:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8001ec0:	9b02      	ldr	r3, [sp, #8]
 8001ec2:	1c5a      	adds	r2, r3, #1
 8001ec4:	9202      	str	r2, [sp, #8]
 8001ec6:	9a03      	ldr	r2, [sp, #12]
 8001ec8:	6992      	ldr	r2, [r2, #24]
 8001eca:	1c50      	adds	r0, r2, #1
 8001ecc:	9903      	ldr	r1, [sp, #12]
 8001ece:	6188      	str	r0, [r1, #24]
 8001ed0:	7812      	ldrb	r2, [r2, #0]
 8001ed2:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 8001ed4:	9b03      	ldr	r3, [sp, #12]
 8001ed6:	699a      	ldr	r2, [r3, #24]
 8001ed8:	9b03      	ldr	r3, [sp, #12]
 8001eda:	691b      	ldr	r3, [r3, #16]
 8001edc:	429a      	cmp	r2, r3
 8001ede:	d303      	bcc.n	8001ee8 <iqReadTimeout+0x88>
      iqp->q_rdptr = iqp->q_buffer;
 8001ee0:	9b03      	ldr	r3, [sp, #12]
 8001ee2:	68da      	ldr	r2, [r3, #12]
 8001ee4:	9b03      	ldr	r3, [sp, #12]
 8001ee6:	619a      	str	r2, [r3, #24]
    }
    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8001ee8:	f7ff fea2 	bl	8001c30 <osalSysUnlock.6129.4202>

    r++;
 8001eec:	9b05      	ldr	r3, [sp, #20]
 8001eee:	3301      	adds	r3, #1
 8001ef0:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8001ef2:	9b01      	ldr	r3, [sp, #4]
 8001ef4:	3b01      	subs	r3, #1
 8001ef6:	9301      	str	r3, [sp, #4]
 8001ef8:	9b01      	ldr	r3, [sp, #4]
 8001efa:	2b00      	cmp	r3, #0
 8001efc:	d101      	bne.n	8001f02 <iqReadTimeout+0xa2>
      return r;
 8001efe:	9b05      	ldr	r3, [sp, #20]
 8001f00:	e002      	b.n	8001f08 <iqReadTimeout+0xa8>
    }

    osalSysLock();
 8001f02:	f7ff fe8d 	bl	8001c20 <osalSysLock.6127.4204>
 8001f06:	e7bb      	b.n	8001e80 <iqReadTimeout+0x20>
  }
}
 8001f08:	1c18      	adds	r0, r3, #0
 8001f0a:	b007      	add	sp, #28
 8001f0c:	bd00      	pop	{pc}
 8001f0e:	46c0      	nop			; (mov r8, r8)

08001f10 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8001f10:	b500      	push	{lr}
 8001f12:	b085      	sub	sp, #20
 8001f14:	9003      	str	r0, [sp, #12]
 8001f16:	9102      	str	r1, [sp, #8]
 8001f18:	9201      	str	r2, [sp, #4]
 8001f1a:	9300      	str	r3, [sp, #0]

  osalThreadQueueObjectInit(&oqp->q_waiting);
 8001f1c:	9b03      	ldr	r3, [sp, #12]
 8001f1e:	1c18      	adds	r0, r3, #0
 8001f20:	f7ff fe8e 	bl	8001c40 <osalThreadQueueObjectInit.6131.4199>
  oqp->q_counter = size;
 8001f24:	9b03      	ldr	r3, [sp, #12]
 8001f26:	9a01      	ldr	r2, [sp, #4]
 8001f28:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8001f2a:	9b03      	ldr	r3, [sp, #12]
 8001f2c:	9a02      	ldr	r2, [sp, #8]
 8001f2e:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 8001f30:	9b03      	ldr	r3, [sp, #12]
 8001f32:	9a02      	ldr	r2, [sp, #8]
 8001f34:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 8001f36:	9b03      	ldr	r3, [sp, #12]
 8001f38:	9a02      	ldr	r2, [sp, #8]
 8001f3a:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8001f3c:	9a02      	ldr	r2, [sp, #8]
 8001f3e:	9b01      	ldr	r3, [sp, #4]
 8001f40:	18d2      	adds	r2, r2, r3
 8001f42:	9b03      	ldr	r3, [sp, #12]
 8001f44:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8001f46:	9b03      	ldr	r3, [sp, #12]
 8001f48:	9a00      	ldr	r2, [sp, #0]
 8001f4a:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 8001f4c:	9b03      	ldr	r3, [sp, #12]
 8001f4e:	9a06      	ldr	r2, [sp, #24]
 8001f50:	621a      	str	r2, [r3, #32]
}
 8001f52:	b005      	add	sp, #20
 8001f54:	bd00      	pop	{pc}
 8001f56:	46c0      	nop			; (mov r8, r8)
 8001f58:	46c0      	nop			; (mov r8, r8)
 8001f5a:	46c0      	nop			; (mov r8, r8)
 8001f5c:	46c0      	nop			; (mov r8, r8)
 8001f5e:	46c0      	nop			; (mov r8, r8)

08001f60 <oqResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void oqResetI(output_queue_t *oqp) {
 8001f60:	b500      	push	{lr}
 8001f62:	b083      	sub	sp, #12
 8001f64:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8001f66:	9b01      	ldr	r3, [sp, #4]
 8001f68:	68da      	ldr	r2, [r3, #12]
 8001f6a:	9b01      	ldr	r3, [sp, #4]
 8001f6c:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr = oqp->q_buffer;
 8001f6e:	9b01      	ldr	r3, [sp, #4]
 8001f70:	68da      	ldr	r2, [r3, #12]
 8001f72:	9b01      	ldr	r3, [sp, #4]
 8001f74:	615a      	str	r2, [r3, #20]
  oqp->q_counter = qSizeX(oqp);
 8001f76:	9b01      	ldr	r3, [sp, #4]
 8001f78:	691b      	ldr	r3, [r3, #16]
 8001f7a:	1c1a      	adds	r2, r3, #0
 8001f7c:	9b01      	ldr	r3, [sp, #4]
 8001f7e:	68db      	ldr	r3, [r3, #12]
 8001f80:	1ad3      	subs	r3, r2, r3
 8001f82:	1c1a      	adds	r2, r3, #0
 8001f84:	9b01      	ldr	r3, [sp, #4]
 8001f86:	609a      	str	r2, [r3, #8]
  osalThreadDequeueAllI(&oqp->q_waiting, Q_RESET);
 8001f88:	9a01      	ldr	r2, [sp, #4]
 8001f8a:	2302      	movs	r3, #2
 8001f8c:	425b      	negs	r3, r3
 8001f8e:	1c10      	adds	r0, r2, #0
 8001f90:	1c19      	adds	r1, r3, #0
 8001f92:	f7ff fe8d 	bl	8001cb0 <osalThreadDequeueAllI.6134.4187>
}
 8001f96:	b003      	add	sp, #12
 8001f98:	bd00      	pop	{pc}
 8001f9a:	46c0      	nop			; (mov r8, r8)
 8001f9c:	46c0      	nop			; (mov r8, r8)
 8001f9e:	46c0      	nop			; (mov r8, r8)

08001fa0 <oqPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8001fa0:	b500      	push	{lr}
 8001fa2:	b085      	sub	sp, #20
 8001fa4:	9001      	str	r0, [sp, #4]
 8001fa6:	466b      	mov	r3, sp
 8001fa8:	3303      	adds	r3, #3
 8001faa:	7019      	strb	r1, [r3, #0]
 8001fac:	466b      	mov	r3, sp
 8001fae:	801a      	strh	r2, [r3, #0]

  osalSysLock();
 8001fb0:	f7ff fe36 	bl	8001c20 <osalSysLock.6127.4204>
 8001fb4:	e00f      	b.n	8001fd6 <oqPutTimeout+0x36>
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8001fb6:	9a01      	ldr	r2, [sp, #4]
 8001fb8:	466b      	mov	r3, sp
 8001fba:	881b      	ldrh	r3, [r3, #0]
 8001fbc:	1c10      	adds	r0, r2, #0
 8001fbe:	1c19      	adds	r1, r3, #0
 8001fc0:	f7ff fe4e 	bl	8001c60 <osalThreadEnqueueTimeoutS.6142.4195>
 8001fc4:	1c03      	adds	r3, r0, #0
 8001fc6:	9303      	str	r3, [sp, #12]
    if (msg < Q_OK) {
 8001fc8:	9b03      	ldr	r3, [sp, #12]
 8001fca:	2b00      	cmp	r3, #0
 8001fcc:	da03      	bge.n	8001fd6 <oqPutTimeout+0x36>
      osalSysUnlock();
 8001fce:	f7ff fe2f 	bl	8001c30 <osalSysUnlock.6129.4202>
      return msg;
 8001fd2:	9b03      	ldr	r3, [sp, #12]
 8001fd4:	e027      	b.n	8002026 <oqPutTimeout+0x86>
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();
  while (oqIsFullI(oqp)) {
 8001fd6:	9b01      	ldr	r3, [sp, #4]
 8001fd8:	689b      	ldr	r3, [r3, #8]
 8001fda:	2b00      	cmp	r3, #0
 8001fdc:	d0eb      	beq.n	8001fb6 <oqPutTimeout+0x16>
      osalSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001fde:	9b01      	ldr	r3, [sp, #4]
 8001fe0:	689b      	ldr	r3, [r3, #8]
 8001fe2:	1e5a      	subs	r2, r3, #1
 8001fe4:	9b01      	ldr	r3, [sp, #4]
 8001fe6:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8001fe8:	9b01      	ldr	r3, [sp, #4]
 8001fea:	695b      	ldr	r3, [r3, #20]
 8001fec:	1c59      	adds	r1, r3, #1
 8001fee:	9a01      	ldr	r2, [sp, #4]
 8001ff0:	6151      	str	r1, [r2, #20]
 8001ff2:	466a      	mov	r2, sp
 8001ff4:	3203      	adds	r2, #3
 8001ff6:	7812      	ldrb	r2, [r2, #0]
 8001ff8:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001ffa:	9b01      	ldr	r3, [sp, #4]
 8001ffc:	695a      	ldr	r2, [r3, #20]
 8001ffe:	9b01      	ldr	r3, [sp, #4]
 8002000:	691b      	ldr	r3, [r3, #16]
 8002002:	429a      	cmp	r2, r3
 8002004:	d303      	bcc.n	800200e <oqPutTimeout+0x6e>
    oqp->q_wrptr = oqp->q_buffer;
 8002006:	9b01      	ldr	r3, [sp, #4]
 8002008:	68da      	ldr	r2, [r3, #12]
 800200a:	9b01      	ldr	r3, [sp, #4]
 800200c:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 800200e:	9b01      	ldr	r3, [sp, #4]
 8002010:	69db      	ldr	r3, [r3, #28]
 8002012:	2b00      	cmp	r3, #0
 8002014:	d004      	beq.n	8002020 <oqPutTimeout+0x80>
    oqp->q_notify(oqp);
 8002016:	9b01      	ldr	r3, [sp, #4]
 8002018:	69db      	ldr	r3, [r3, #28]
 800201a:	9a01      	ldr	r2, [sp, #4]
 800201c:	1c10      	adds	r0, r2, #0
 800201e:	4798      	blx	r3
  }
  osalSysUnlock();
 8002020:	f7ff fe06 	bl	8001c30 <osalSysUnlock.6129.4202>

  return Q_OK;
 8002024:	2300      	movs	r3, #0
}
 8002026:	1c18      	adds	r0, r3, #0
 8002028:	b005      	add	sp, #20
 800202a:	bd00      	pop	{pc}
 800202c:	46c0      	nop			; (mov r8, r8)
 800202e:	46c0      	nop			; (mov r8, r8)

08002030 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8002030:	b500      	push	{lr}
 8002032:	b085      	sub	sp, #20
 8002034:	9001      	str	r0, [sp, #4]
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8002036:	9b01      	ldr	r3, [sp, #4]
 8002038:	695a      	ldr	r2, [r3, #20]
 800203a:	9b01      	ldr	r3, [sp, #4]
 800203c:	699b      	ldr	r3, [r3, #24]
 800203e:	429a      	cmp	r2, r3
 8002040:	d105      	bne.n	800204e <oqGetI+0x1e>
 8002042:	9b01      	ldr	r3, [sp, #4]
 8002044:	689b      	ldr	r3, [r3, #8]
 8002046:	2b00      	cmp	r3, #0
 8002048:	d001      	beq.n	800204e <oqGetI+0x1e>
 800204a:	2301      	movs	r3, #1
 800204c:	e000      	b.n	8002050 <oqGetI+0x20>
 800204e:	2300      	movs	r3, #0
 8002050:	1c1a      	adds	r2, r3, #0
 8002052:	2301      	movs	r3, #1
 8002054:	4013      	ands	r3, r2
 8002056:	b2db      	uxtb	r3, r3
 8002058:	2b00      	cmp	r3, #0
 800205a:	d002      	beq.n	8002062 <oqGetI+0x32>
    return Q_EMPTY;
 800205c:	2303      	movs	r3, #3
 800205e:	425b      	negs	r3, r3
 8002060:	e01f      	b.n	80020a2 <oqGetI+0x72>
  }

  oqp->q_counter++;
 8002062:	9b01      	ldr	r3, [sp, #4]
 8002064:	689b      	ldr	r3, [r3, #8]
 8002066:	1c5a      	adds	r2, r3, #1
 8002068:	9b01      	ldr	r3, [sp, #4]
 800206a:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 800206c:	9b01      	ldr	r3, [sp, #4]
 800206e:	699b      	ldr	r3, [r3, #24]
 8002070:	1c59      	adds	r1, r3, #1
 8002072:	9a01      	ldr	r2, [sp, #4]
 8002074:	6191      	str	r1, [r2, #24]
 8002076:	466a      	mov	r2, sp
 8002078:	320f      	adds	r2, #15
 800207a:	781b      	ldrb	r3, [r3, #0]
 800207c:	7013      	strb	r3, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 800207e:	9b01      	ldr	r3, [sp, #4]
 8002080:	699a      	ldr	r2, [r3, #24]
 8002082:	9b01      	ldr	r3, [sp, #4]
 8002084:	691b      	ldr	r3, [r3, #16]
 8002086:	429a      	cmp	r2, r3
 8002088:	d303      	bcc.n	8002092 <oqGetI+0x62>
    oqp->q_rdptr = oqp->q_buffer;
 800208a:	9b01      	ldr	r3, [sp, #4]
 800208c:	68da      	ldr	r2, [r3, #12]
 800208e:	9b01      	ldr	r3, [sp, #4]
 8002090:	619a      	str	r2, [r3, #24]
  }

  osalThreadDequeueNextI(&oqp->q_waiting, Q_OK);
 8002092:	9b01      	ldr	r3, [sp, #4]
 8002094:	1c18      	adds	r0, r3, #0
 8002096:	2100      	movs	r1, #0
 8002098:	f7ff fdfa 	bl	8001c90 <osalThreadDequeueNextI.6138.4191>

  return (msg_t)b;
 800209c:	466b      	mov	r3, sp
 800209e:	330f      	adds	r3, #15
 80020a0:	781b      	ldrb	r3, [r3, #0]
}
 80020a2:	1c18      	adds	r0, r3, #0
 80020a4:	b005      	add	sp, #20
 80020a6:	bd00      	pop	{pc}
 80020a8:	46c0      	nop			; (mov r8, r8)
 80020aa:	46c0      	nop			; (mov r8, r8)
 80020ac:	46c0      	nop			; (mov r8, r8)
 80020ae:	46c0      	nop			; (mov r8, r8)

080020b0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 80020b0:	b500      	push	{lr}
 80020b2:	b087      	sub	sp, #28
 80020b4:	9003      	str	r0, [sp, #12]
 80020b6:	9102      	str	r1, [sp, #8]
 80020b8:	9201      	str	r2, [sp, #4]
 80020ba:	1c1a      	adds	r2, r3, #0
 80020bc:	466b      	mov	r3, sp
 80020be:	3302      	adds	r3, #2
 80020c0:	801a      	strh	r2, [r3, #0]
  qnotify_t nfy = oqp->q_notify;
 80020c2:	9b03      	ldr	r3, [sp, #12]
 80020c4:	69db      	ldr	r3, [r3, #28]
 80020c6:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 80020c8:	2300      	movs	r3, #0
 80020ca:	9305      	str	r3, [sp, #20]

  osalDbgCheck(n > 0U);

  osalSysLock();
 80020cc:	f7ff fda8 	bl	8001c20 <osalSysLock.6127.4204>
 80020d0:	e00e      	b.n	80020f0 <oqWriteTimeout+0x40>
  while (true) {
    while (oqIsFullI(oqp)) {
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80020d2:	9a03      	ldr	r2, [sp, #12]
 80020d4:	466b      	mov	r3, sp
 80020d6:	3302      	adds	r3, #2
 80020d8:	881b      	ldrh	r3, [r3, #0]
 80020da:	1c10      	adds	r0, r2, #0
 80020dc:	1c19      	adds	r1, r3, #0
 80020de:	f7ff fdbf 	bl	8001c60 <osalThreadEnqueueTimeoutS.6142.4195>
 80020e2:	1c03      	adds	r3, r0, #0
 80020e4:	2b00      	cmp	r3, #0
 80020e6:	d003      	beq.n	80020f0 <oqWriteTimeout+0x40>
        osalSysUnlock();
 80020e8:	f7ff fda2 	bl	8001c30 <osalSysUnlock.6129.4202>
        return w;
 80020ec:	9b05      	ldr	r3, [sp, #20]
 80020ee:	e033      	b.n	8002158 <oqWriteTimeout+0xa8>

  osalDbgCheck(n > 0U);

  osalSysLock();
  while (true) {
    while (oqIsFullI(oqp)) {
 80020f0:	9b03      	ldr	r3, [sp, #12]
 80020f2:	689b      	ldr	r3, [r3, #8]
 80020f4:	2b00      	cmp	r3, #0
 80020f6:	d0ec      	beq.n	80020d2 <oqWriteTimeout+0x22>
      if (osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
        osalSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 80020f8:	9b03      	ldr	r3, [sp, #12]
 80020fa:	689b      	ldr	r3, [r3, #8]
 80020fc:	1e5a      	subs	r2, r3, #1
 80020fe:	9b03      	ldr	r3, [sp, #12]
 8002100:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 8002102:	9b03      	ldr	r3, [sp, #12]
 8002104:	695b      	ldr	r3, [r3, #20]
 8002106:	1c59      	adds	r1, r3, #1
 8002108:	9a03      	ldr	r2, [sp, #12]
 800210a:	6151      	str	r1, [r2, #20]
 800210c:	9a02      	ldr	r2, [sp, #8]
 800210e:	1c51      	adds	r1, r2, #1
 8002110:	9102      	str	r1, [sp, #8]
 8002112:	7812      	ldrb	r2, [r2, #0]
 8002114:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8002116:	9b03      	ldr	r3, [sp, #12]
 8002118:	695a      	ldr	r2, [r3, #20]
 800211a:	9b03      	ldr	r3, [sp, #12]
 800211c:	691b      	ldr	r3, [r3, #16]
 800211e:	429a      	cmp	r2, r3
 8002120:	d303      	bcc.n	800212a <oqWriteTimeout+0x7a>
      oqp->q_wrptr = oqp->q_buffer;
 8002122:	9b03      	ldr	r3, [sp, #12]
 8002124:	68da      	ldr	r2, [r3, #12]
 8002126:	9b03      	ldr	r3, [sp, #12]
 8002128:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 800212a:	9b04      	ldr	r3, [sp, #16]
 800212c:	2b00      	cmp	r3, #0
 800212e:	d003      	beq.n	8002138 <oqWriteTimeout+0x88>
      nfy(oqp);
 8002130:	9a03      	ldr	r2, [sp, #12]
 8002132:	9b04      	ldr	r3, [sp, #16]
 8002134:	1c10      	adds	r0, r2, #0
 8002136:	4798      	blx	r3
    }
    osalSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8002138:	f7ff fd7a 	bl	8001c30 <osalSysUnlock.6129.4202>

    w++;
 800213c:	9b05      	ldr	r3, [sp, #20]
 800213e:	3301      	adds	r3, #1
 8002140:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 8002142:	9b01      	ldr	r3, [sp, #4]
 8002144:	3b01      	subs	r3, #1
 8002146:	9301      	str	r3, [sp, #4]
 8002148:	9b01      	ldr	r3, [sp, #4]
 800214a:	2b00      	cmp	r3, #0
 800214c:	d101      	bne.n	8002152 <oqWriteTimeout+0xa2>
      return w;
 800214e:	9b05      	ldr	r3, [sp, #20]
 8002150:	e002      	b.n	8002158 <oqWriteTimeout+0xa8>
    }

    osalSysLock();
 8002152:	f7ff fd65 	bl	8001c20 <osalSysLock.6127.4204>
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);

  osalSysLock();
 8002156:	e7cb      	b.n	80020f0 <oqWriteTimeout+0x40>
      return w;
    }

    osalSysLock();
  }
}
 8002158:	1c18      	adds	r0, r3, #0
 800215a:	b007      	add	sp, #28
 800215c:	bd00      	pop	{pc}
 800215e:	46c0      	nop			; (mov r8, r8)

08002160 <port_lock.6229.4054>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002160:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8002162:	4770      	bx	lr
 8002164:	46c0      	nop			; (mov r8, r8)
 8002166:	46c0      	nop			; (mov r8, r8)
 8002168:	46c0      	nop			; (mov r8, r8)
 800216a:	46c0      	nop			; (mov r8, r8)
 800216c:	46c0      	nop			; (mov r8, r8)
 800216e:	46c0      	nop			; (mov r8, r8)

08002170 <port_unlock.6232.4052>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002170:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8002172:	4770      	bx	lr
 8002174:	46c0      	nop			; (mov r8, r8)
 8002176:	46c0      	nop			; (mov r8, r8)
 8002178:	46c0      	nop			; (mov r8, r8)
 800217a:	46c0      	nop			; (mov r8, r8)
 800217c:	46c0      	nop			; (mov r8, r8)
 800217e:	46c0      	nop			; (mov r8, r8)

08002180 <chSysLock.6234.4050>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8002180:	b508      	push	{r3, lr}

  port_lock();
 8002182:	f7ff ffed 	bl	8002160 <port_lock.6229.4054>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002186:	bd08      	pop	{r3, pc}
 8002188:	46c0      	nop			; (mov r8, r8)
 800218a:	46c0      	nop			; (mov r8, r8)
 800218c:	46c0      	nop			; (mov r8, r8)
 800218e:	46c0      	nop			; (mov r8, r8)

08002190 <chSysUnlock.6236.4048>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002190:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002192:	f7ff ffed 	bl	8002170 <port_unlock.6232.4052>
}
 8002196:	bd08      	pop	{r3, pc}
 8002198:	46c0      	nop			; (mov r8, r8)
 800219a:	46c0      	nop			; (mov r8, r8)
 800219c:	46c0      	nop			; (mov r8, r8)
 800219e:	46c0      	nop			; (mov r8, r8)

080021a0 <osalSysLock.6238>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80021a0:	b508      	push	{r3, lr}

  chSysLock();
 80021a2:	f7ff ffed 	bl	8002180 <chSysLock.6234.4050>
}
 80021a6:	bd08      	pop	{r3, pc}
 80021a8:	46c0      	nop			; (mov r8, r8)
 80021aa:	46c0      	nop			; (mov r8, r8)
 80021ac:	46c0      	nop			; (mov r8, r8)
 80021ae:	46c0      	nop			; (mov r8, r8)

080021b0 <osalSysUnlock.6240>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80021b0:	b508      	push	{r3, lr}

  chSysUnlock();
 80021b2:	f7ff ffed 	bl	8002190 <chSysUnlock.6236.4048>
}
 80021b6:	bd08      	pop	{r3, pc}
 80021b8:	46c0      	nop			; (mov r8, r8)
 80021ba:	46c0      	nop			; (mov r8, r8)
 80021bc:	46c0      	nop			; (mov r8, r8)
 80021be:	46c0      	nop			; (mov r8, r8)

080021c0 <extInit.4042>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void extInit(void) {
 80021c0:	b508      	push	{r3, lr}

  ext_lld_init();
 80021c2:	f7ff f94d 	bl	8001460 <ext_lld_init>
}
 80021c6:	bd08      	pop	{r3, pc}
 80021c8:	46c0      	nop			; (mov r8, r8)
 80021ca:	46c0      	nop			; (mov r8, r8)
 80021cc:	46c0      	nop			; (mov r8, r8)
 80021ce:	46c0      	nop			; (mov r8, r8)

080021d0 <extObjectInit>:
 *
 * @param[out] extp     pointer to the @p EXTDriver object
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {
 80021d0:	b082      	sub	sp, #8
 80021d2:	9001      	str	r0, [sp, #4]

  extp->state  = EXT_STOP;
 80021d4:	9b01      	ldr	r3, [sp, #4]
 80021d6:	2201      	movs	r2, #1
 80021d8:	701a      	strb	r2, [r3, #0]
  extp->config = NULL;
 80021da:	9b01      	ldr	r3, [sp, #4]
 80021dc:	2200      	movs	r2, #0
 80021de:	605a      	str	r2, [r3, #4]
}
 80021e0:	b002      	add	sp, #8
 80021e2:	4770      	bx	lr
 80021e4:	46c0      	nop			; (mov r8, r8)
 80021e6:	46c0      	nop			; (mov r8, r8)
 80021e8:	46c0      	nop			; (mov r8, r8)
 80021ea:	46c0      	nop			; (mov r8, r8)
 80021ec:	46c0      	nop			; (mov r8, r8)
 80021ee:	46c0      	nop			; (mov r8, r8)

080021f0 <extStart>:
 * @param[in] extp      pointer to the @p EXTDriver object
 * @param[in] config    pointer to the @p EXTConfig object
 *
 * @api
 */
void extStart(EXTDriver *extp, const EXTConfig *config) {
 80021f0:	b500      	push	{lr}
 80021f2:	b083      	sub	sp, #12
 80021f4:	9001      	str	r0, [sp, #4]
 80021f6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
 80021f8:	f7ff ffd2 	bl	80021a0 <osalSysLock.6238>
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
 80021fc:	9b01      	ldr	r3, [sp, #4]
 80021fe:	9a00      	ldr	r2, [sp, #0]
 8002200:	605a      	str	r2, [r3, #4]
  ext_lld_start(extp);
 8002202:	9b01      	ldr	r3, [sp, #4]
 8002204:	1c18      	adds	r0, r3, #0
 8002206:	f7ff f933 	bl	8001470 <ext_lld_start>
  extp->state = EXT_ACTIVE;
 800220a:	9b01      	ldr	r3, [sp, #4]
 800220c:	2202      	movs	r2, #2
 800220e:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8002210:	f7ff ffce 	bl	80021b0 <osalSysUnlock.6240>
}
 8002214:	b003      	add	sp, #12
 8002216:	bd00      	pop	{pc}
 8002218:	46c0      	nop			; (mov r8, r8)
 800221a:	46c0      	nop			; (mov r8, r8)
 800221c:	46c0      	nop			; (mov r8, r8)
 800221e:	46c0      	nop			; (mov r8, r8)

08002220 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8002220:	4770      	bx	lr
 8002222:	46c0      	nop			; (mov r8, r8)
 8002224:	46c0      	nop			; (mov r8, r8)
 8002226:	46c0      	nop			; (mov r8, r8)
 8002228:	46c0      	nop			; (mov r8, r8)
 800222a:	46c0      	nop			; (mov r8, r8)
 800222c:	46c0      	nop			; (mov r8, r8)
 800222e:	46c0      	nop			; (mov r8, r8)

08002230 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8002230:	4770      	bx	lr
 8002232:	46c0      	nop			; (mov r8, r8)
 8002234:	46c0      	nop			; (mov r8, r8)
 8002236:	46c0      	nop			; (mov r8, r8)
 8002238:	46c0      	nop			; (mov r8, r8)
 800223a:	46c0      	nop			; (mov r8, r8)
 800223c:	46c0      	nop			; (mov r8, r8)
 800223e:	46c0      	nop			; (mov r8, r8)

08002240 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8002240:	e7fe      	b.n	8002240 <__default_exit>
 8002242:	46c0      	nop			; (mov r8, r8)
 8002244:	46c0      	nop			; (mov r8, r8)
 8002246:	46c0      	nop			; (mov r8, r8)
 8002248:	46c0      	nop			; (mov r8, r8)
 800224a:	46c0      	nop			; (mov r8, r8)
 800224c:	46c0      	nop			; (mov r8, r8)
 800224e:	46c0      	nop			; (mov r8, r8)

08002250 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8002250:	e7fe      	b.n	8002250 <BusFault_Handler>
 8002252:	46c0      	nop			; (mov r8, r8)
 8002254:	46c0      	nop			; (mov r8, r8)
 8002256:	46c0      	nop			; (mov r8, r8)
 8002258:	46c0      	nop			; (mov r8, r8)
 800225a:	46c0      	nop			; (mov r8, r8)
 800225c:	46c0      	nop			; (mov r8, r8)
 800225e:	46c0      	nop			; (mov r8, r8)

08002260 <NVIC_SetPriority.4097.4422>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8002260:	b530      	push	{r4, r5, lr}
 8002262:	b083      	sub	sp, #12
 8002264:	1c02      	adds	r2, r0, #0
 8002266:	9100      	str	r1, [sp, #0]
 8002268:	466b      	mov	r3, sp
 800226a:	3307      	adds	r3, #7
 800226c:	701a      	strb	r2, [r3, #0]
  if((int32_t)(IRQn) < 0) {
 800226e:	466b      	mov	r3, sp
 8002270:	3307      	adds	r3, #7
 8002272:	781b      	ldrb	r3, [r3, #0]
 8002274:	2b7f      	cmp	r3, #127	; 0x7f
 8002276:	d936      	bls.n	80022e6 <NVIC_SetPriority.4097.4422+0x86>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002278:	4933      	ldr	r1, [pc, #204]	; (8002348 <NVIC_SetPriority.4097.4422+0xe8>)
 800227a:	466b      	mov	r3, sp
 800227c:	3307      	adds	r3, #7
 800227e:	781b      	ldrb	r3, [r3, #0]
 8002280:	1c1a      	adds	r2, r3, #0
 8002282:	230f      	movs	r3, #15
 8002284:	4013      	ands	r3, r2
 8002286:	3b08      	subs	r3, #8
 8002288:	0898      	lsrs	r0, r3, #2
 800228a:	4a2f      	ldr	r2, [pc, #188]	; (8002348 <NVIC_SetPriority.4097.4422+0xe8>)
 800228c:	466b      	mov	r3, sp
 800228e:	3307      	adds	r3, #7
 8002290:	781b      	ldrb	r3, [r3, #0]
 8002292:	1c1c      	adds	r4, r3, #0
 8002294:	230f      	movs	r3, #15
 8002296:	4023      	ands	r3, r4
 8002298:	3b08      	subs	r3, #8
 800229a:	089b      	lsrs	r3, r3, #2
 800229c:	3306      	adds	r3, #6
 800229e:	009b      	lsls	r3, r3, #2
 80022a0:	18d3      	adds	r3, r2, r3
 80022a2:	685b      	ldr	r3, [r3, #4]
 80022a4:	466a      	mov	r2, sp
 80022a6:	3207      	adds	r2, #7
 80022a8:	7812      	ldrb	r2, [r2, #0]
 80022aa:	1c14      	adds	r4, r2, #0
 80022ac:	2203      	movs	r2, #3
 80022ae:	4022      	ands	r2, r4
 80022b0:	00d2      	lsls	r2, r2, #3
 80022b2:	24ff      	movs	r4, #255	; 0xff
 80022b4:	1c25      	adds	r5, r4, #0
 80022b6:	4095      	lsls	r5, r2
 80022b8:	1c2a      	adds	r2, r5, #0
 80022ba:	43d2      	mvns	r2, r2
 80022bc:	401a      	ands	r2, r3
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80022be:	9b00      	ldr	r3, [sp, #0]
 80022c0:	019c      	lsls	r4, r3, #6
 80022c2:	23ff      	movs	r3, #255	; 0xff
 80022c4:	401c      	ands	r4, r3
 80022c6:	466b      	mov	r3, sp
 80022c8:	3307      	adds	r3, #7
 80022ca:	781b      	ldrb	r3, [r3, #0]
 80022cc:	1c1d      	adds	r5, r3, #0
 80022ce:	2303      	movs	r3, #3
 80022d0:	402b      	ands	r3, r5
 80022d2:	00db      	lsls	r3, r3, #3
 80022d4:	1c25      	adds	r5, r4, #0
 80022d6:	409d      	lsls	r5, r3
 80022d8:	1c2b      	adds	r3, r5, #0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80022da:	431a      	orrs	r2, r3
 80022dc:	1d83      	adds	r3, r0, #6
 80022de:	009b      	lsls	r3, r3, #2
 80022e0:	18cb      	adds	r3, r1, r3
 80022e2:	605a      	str	r2, [r3, #4]
 80022e4:	e02d      	b.n	8002342 <NVIC_SetPriority.4097.4422+0xe2>
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80022e6:	4b19      	ldr	r3, [pc, #100]	; (800234c <NVIC_SetPriority.4097.4422+0xec>)
 80022e8:	466a      	mov	r2, sp
 80022ea:	3207      	adds	r2, #7
 80022ec:	7812      	ldrb	r2, [r2, #0]
 80022ee:	b252      	sxtb	r2, r2
 80022f0:	0892      	lsrs	r2, r2, #2
 80022f2:	4916      	ldr	r1, [pc, #88]	; (800234c <NVIC_SetPriority.4097.4422+0xec>)
 80022f4:	4668      	mov	r0, sp
 80022f6:	3007      	adds	r0, #7
 80022f8:	7800      	ldrb	r0, [r0, #0]
 80022fa:	b240      	sxtb	r0, r0
 80022fc:	0880      	lsrs	r0, r0, #2
 80022fe:	30c0      	adds	r0, #192	; 0xc0
 8002300:	0080      	lsls	r0, r0, #2
 8002302:	5841      	ldr	r1, [r0, r1]
 8002304:	4668      	mov	r0, sp
 8002306:	3007      	adds	r0, #7
 8002308:	7800      	ldrb	r0, [r0, #0]
 800230a:	1c04      	adds	r4, r0, #0
 800230c:	2003      	movs	r0, #3
 800230e:	4020      	ands	r0, r4
 8002310:	00c0      	lsls	r0, r0, #3
 8002312:	24ff      	movs	r4, #255	; 0xff
 8002314:	1c25      	adds	r5, r4, #0
 8002316:	4085      	lsls	r5, r0
 8002318:	1c28      	adds	r0, r5, #0
 800231a:	43c0      	mvns	r0, r0
 800231c:	4008      	ands	r0, r1
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800231e:	9900      	ldr	r1, [sp, #0]
 8002320:	018c      	lsls	r4, r1, #6
 8002322:	21ff      	movs	r1, #255	; 0xff
 8002324:	400c      	ands	r4, r1
 8002326:	4669      	mov	r1, sp
 8002328:	3107      	adds	r1, #7
 800232a:	7809      	ldrb	r1, [r1, #0]
 800232c:	1c0d      	adds	r5, r1, #0
 800232e:	2103      	movs	r1, #3
 8002330:	4029      	ands	r1, r5
 8002332:	00c9      	lsls	r1, r1, #3
 8002334:	1c25      	adds	r5, r4, #0
 8002336:	408d      	lsls	r5, r1
 8002338:	1c29      	adds	r1, r5, #0
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800233a:	4301      	orrs	r1, r0
 800233c:	32c0      	adds	r2, #192	; 0xc0
 800233e:	0092      	lsls	r2, r2, #2
 8002340:	50d1      	str	r1, [r2, r3]
       (((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
 8002342:	b003      	add	sp, #12
 8002344:	bd30      	pop	{r4, r5, pc}
 8002346:	46c0      	nop			; (mov r8, r8)
 8002348:	e000ed00 	.word	0xe000ed00
 800234c:	e000e100 	.word	0xe000e100

08002350 <port_init.4106.4420>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8002350:	b508      	push	{r3, lr}

  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8002352:	2302      	movs	r3, #2
 8002354:	425b      	negs	r3, r3
 8002356:	1c18      	adds	r0, r3, #0
 8002358:	2100      	movs	r1, #0
 800235a:	f7ff ff81 	bl	8002260 <NVIC_SetPriority.4097.4422>
}
 800235e:	bd08      	pop	{r3, pc}

08002360 <port_lock.4117.4411>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002360:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8002362:	4770      	bx	lr
 8002364:	46c0      	nop			; (mov r8, r8)
 8002366:	46c0      	nop			; (mov r8, r8)
 8002368:	46c0      	nop			; (mov r8, r8)
 800236a:	46c0      	nop			; (mov r8, r8)
 800236c:	46c0      	nop			; (mov r8, r8)
 800236e:	46c0      	nop			; (mov r8, r8)

08002370 <port_unlock.4119.4409>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002370:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8002372:	4770      	bx	lr
 8002374:	46c0      	nop			; (mov r8, r8)
 8002376:	46c0      	nop			; (mov r8, r8)
 8002378:	46c0      	nop			; (mov r8, r8)
 800237a:	46c0      	nop			; (mov r8, r8)
 800237c:	46c0      	nop			; (mov r8, r8)
 800237e:	46c0      	nop			; (mov r8, r8)

08002380 <port_lock_from_isr.4121.4407>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002380:	b508      	push	{r3, lr}

  port_lock();
 8002382:	f7ff ffed 	bl	8002360 <port_lock.4117.4411>
}
 8002386:	bd08      	pop	{r3, pc}
 8002388:	46c0      	nop			; (mov r8, r8)
 800238a:	46c0      	nop			; (mov r8, r8)
 800238c:	46c0      	nop			; (mov r8, r8)
 800238e:	46c0      	nop			; (mov r8, r8)

08002390 <port_unlock_from_isr.4123.4405>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002390:	b508      	push	{r3, lr}

  port_unlock();
 8002392:	f7ff ffed 	bl	8002370 <port_unlock.4119.4409>
}
 8002396:	bd08      	pop	{r3, pc}
 8002398:	46c0      	nop			; (mov r8, r8)
 800239a:	46c0      	nop			; (mov r8, r8)
 800239c:	46c0      	nop			; (mov r8, r8)
 800239e:	46c0      	nop			; (mov r8, r8)

080023a0 <port_enable.4127.4401>:
 80023a0:	b662      	cpsie	i
 * @brief   Enables all the interrupt sources.
 */
static inline void port_enable(void) {

  __enable_irq();
}
 80023a2:	4770      	bx	lr
 80023a4:	46c0      	nop			; (mov r8, r8)
 80023a6:	46c0      	nop			; (mov r8, r8)
 80023a8:	46c0      	nop			; (mov r8, r8)
 80023aa:	46c0      	nop			; (mov r8, r8)
 80023ac:	46c0      	nop			; (mov r8, r8)
 80023ae:	46c0      	nop			; (mov r8, r8)

080023b0 <port_wait_for_interrupt.4129.4399>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 80023b0:	4770      	bx	lr
 80023b2:	46c0      	nop			; (mov r8, r8)
 80023b4:	46c0      	nop			; (mov r8, r8)
 80023b6:	46c0      	nop			; (mov r8, r8)
 80023b8:	46c0      	nop			; (mov r8, r8)
 80023ba:	46c0      	nop			; (mov r8, r8)
 80023bc:	46c0      	nop			; (mov r8, r8)
 80023be:	46c0      	nop			; (mov r8, r8)

080023c0 <st_lld_get_counter.4131.4397>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80023c0:	4b02      	ldr	r3, [pc, #8]	; (80023cc <st_lld_get_counter.4131.4397+0xc>)
 80023c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80023c4:	b29b      	uxth	r3, r3
}
 80023c6:	1c18      	adds	r0, r3, #0
 80023c8:	4770      	bx	lr
 80023ca:	46c0      	nop			; (mov r8, r8)
 80023cc:	40000400 	.word	0x40000400

080023d0 <port_timer_stop_alarm.4221.4395>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 80023d0:	b508      	push	{r3, lr}

  stStopAlarm();
 80023d2:	f7ff fbcd 	bl	8001b70 <stStopAlarm>
}
 80023d6:	bd08      	pop	{r3, pc}
 80023d8:	46c0      	nop			; (mov r8, r8)
 80023da:	46c0      	nop			; (mov r8, r8)
 80023dc:	46c0      	nop			; (mov r8, r8)
 80023de:	46c0      	nop			; (mov r8, r8)

080023e0 <port_timer_set_alarm.4223.4392>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 80023e0:	b500      	push	{lr}
 80023e2:	b083      	sub	sp, #12
 80023e4:	1c02      	adds	r2, r0, #0
 80023e6:	466b      	mov	r3, sp
 80023e8:	3306      	adds	r3, #6
 80023ea:	801a      	strh	r2, [r3, #0]

  stSetAlarm(time);
 80023ec:	466b      	mov	r3, sp
 80023ee:	3306      	adds	r3, #6
 80023f0:	881b      	ldrh	r3, [r3, #0]
 80023f2:	1c18      	adds	r0, r3, #0
 80023f4:	f7ff fbc4 	bl	8001b80 <stSetAlarm>
}
 80023f8:	b003      	add	sp, #12
 80023fa:	bd00      	pop	{pc}
 80023fc:	46c0      	nop			; (mov r8, r8)
 80023fe:	46c0      	nop			; (mov r8, r8)

08002400 <port_timer_get_time.4136.4390>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002400:	b508      	push	{r3, lr}

  return stGetCounter();
 8002402:	f7ff ffdd 	bl	80023c0 <st_lld_get_counter.4131.4397>
 8002406:	1c03      	adds	r3, r0, #0
}
 8002408:	1c18      	adds	r0, r3, #0
 800240a:	bd08      	pop	{r3, pc}
 800240c:	46c0      	nop			; (mov r8, r8)
 800240e:	46c0      	nop			; (mov r8, r8)

08002410 <chSysEnable.4138.4388>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 8002410:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 8002412:	f7ff ffc5 	bl	80023a0 <port_enable.4127.4401>
}
 8002416:	bd08      	pop	{r3, pc}
 8002418:	46c0      	nop			; (mov r8, r8)
 800241a:	46c0      	nop			; (mov r8, r8)
 800241c:	46c0      	nop			; (mov r8, r8)
 800241e:	46c0      	nop			; (mov r8, r8)

08002420 <chSysLockFromISR.4144.4382>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002420:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002422:	f7ff ffad 	bl	8002380 <port_lock_from_isr.4121.4407>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002426:	bd08      	pop	{r3, pc}
 8002428:	46c0      	nop			; (mov r8, r8)
 800242a:	46c0      	nop			; (mov r8, r8)
 800242c:	46c0      	nop			; (mov r8, r8)
 800242e:	46c0      	nop			; (mov r8, r8)

08002430 <chSysUnlockFromISR.4146.4380>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002430:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002432:	f7ff ffad 	bl	8002390 <port_unlock_from_isr.4123.4405>
}
 8002436:	bd08      	pop	{r3, pc}
 8002438:	46c0      	nop			; (mov r8, r8)
 800243a:	46c0      	nop			; (mov r8, r8)
 800243c:	46c0      	nop			; (mov r8, r8)
 800243e:	46c0      	nop			; (mov r8, r8)

08002440 <chVTGetSystemTimeX.4148.4378>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002440:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002442:	f7ff ffdd 	bl	8002400 <port_timer_get_time.4136.4390>
 8002446:	1c03      	adds	r3, r0, #0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002448:	1c18      	adds	r0, r3, #0
 800244a:	bd08      	pop	{r3, pc}
 800244c:	46c0      	nop			; (mov r8, r8)
 800244e:	46c0      	nop			; (mov r8, r8)

08002450 <chVTDoTickI.4226.4376>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 8002450:	b510      	push	{r4, lr}
 8002452:	b084      	sub	sp, #16
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8002454:	4b33      	ldr	r3, [pc, #204]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 8002456:	69db      	ldr	r3, [r3, #28]
 8002458:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 800245a:	466c      	mov	r4, sp
 800245c:	340a      	adds	r4, #10
 800245e:	f7ff ffef 	bl	8002440 <chVTGetSystemTimeX.4148.4378>
 8002462:	1c03      	adds	r3, r0, #0
 8002464:	8023      	strh	r3, [r4, #0]
 8002466:	e02e      	b.n	80024c6 <chVTDoTickI.4226.4376+0x76>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8002468:	4b2e      	ldr	r3, [pc, #184]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 800246a:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 800246c:	9b03      	ldr	r3, [sp, #12]
 800246e:	891b      	ldrh	r3, [r3, #8]
 8002470:	18d3      	adds	r3, r2, r3
 8002472:	b29a      	uxth	r2, r3
 8002474:	4b2b      	ldr	r3, [pc, #172]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 8002476:	84da      	strh	r2, [r3, #38]	; 0x26

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8002478:	9b03      	ldr	r3, [sp, #12]
 800247a:	681b      	ldr	r3, [r3, #0]
 800247c:	4a2a      	ldr	r2, [pc, #168]	; (8002528 <chVTDoTickI.4226.4376+0xd8>)
 800247e:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 8002480:	9b03      	ldr	r3, [sp, #12]
 8002482:	681a      	ldr	r2, [r3, #0]
 8002484:	4b27      	ldr	r3, [pc, #156]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 8002486:	61da      	str	r2, [r3, #28]
    fn = vtp->vt_func;
 8002488:	9b03      	ldr	r3, [sp, #12]
 800248a:	68db      	ldr	r3, [r3, #12]
 800248c:	9301      	str	r3, [sp, #4]
    vtp->vt_func = NULL;
 800248e:	9b03      	ldr	r3, [sp, #12]
 8002490:	2200      	movs	r2, #0
 8002492:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8002494:	4b23      	ldr	r3, [pc, #140]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 8002496:	69da      	ldr	r2, [r3, #28]
 8002498:	4b23      	ldr	r3, [pc, #140]	; (8002528 <chVTDoTickI.4226.4376+0xd8>)
 800249a:	429a      	cmp	r2, r3
 800249c:	d101      	bne.n	80024a2 <chVTDoTickI.4226.4376+0x52>
      port_timer_stop_alarm();
 800249e:	f7ff ff97 	bl	80023d0 <port_timer_stop_alarm.4221.4395>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 80024a2:	f7ff ffc5 	bl	8002430 <chSysUnlockFromISR.4146.4380>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 80024a6:	9b03      	ldr	r3, [sp, #12]
 80024a8:	691a      	ldr	r2, [r3, #16]
 80024aa:	9b01      	ldr	r3, [sp, #4]
 80024ac:	1c10      	adds	r0, r2, #0
 80024ae:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 80024b0:	f7ff ffb6 	bl	8002420 <chSysLockFromISR.4144.4382>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 80024b4:	4b1b      	ldr	r3, [pc, #108]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 80024b6:	69db      	ldr	r3, [r3, #28]
 80024b8:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 80024ba:	466c      	mov	r4, sp
 80024bc:	340a      	adds	r4, #10
 80024be:	f7ff ffbf 	bl	8002440 <chVTGetSystemTimeX.4148.4378>
 80024c2:	1c03      	adds	r3, r0, #0
 80024c4:	8023      	strh	r3, [r4, #0]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80024c6:	9b03      	ldr	r3, [sp, #12]
 80024c8:	891a      	ldrh	r2, [r3, #8]
 80024ca:	4b16      	ldr	r3, [pc, #88]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 80024cc:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 80024ce:	4669      	mov	r1, sp
 80024d0:	310a      	adds	r1, #10
 80024d2:	8809      	ldrh	r1, [r1, #0]
 80024d4:	1acb      	subs	r3, r1, r3
 80024d6:	b29b      	uxth	r3, r3
 80024d8:	429a      	cmp	r2, r3
 80024da:	d9c5      	bls.n	8002468 <chVTDoTickI.4226.4376+0x18>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80024dc:	4b11      	ldr	r3, [pc, #68]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 80024de:	69da      	ldr	r2, [r3, #28]
 80024e0:	4b11      	ldr	r3, [pc, #68]	; (8002528 <chVTDoTickI.4226.4376+0xd8>)
 80024e2:	429a      	cmp	r2, r3
 80024e4:	d01c      	beq.n	8002520 <chVTDoTickI.4226.4376+0xd0>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 80024e6:	4b0f      	ldr	r3, [pc, #60]	; (8002524 <chVTDoTickI.4226.4376+0xd4>)
 80024e8:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 80024ea:	9b03      	ldr	r3, [sp, #12]
 80024ec:	891b      	ldrh	r3, [r3, #8]
 80024ee:	18d3      	adds	r3, r2, r3
 80024f0:	b299      	uxth	r1, r3
 80024f2:	ab02      	add	r3, sp, #8
 80024f4:	466a      	mov	r2, sp
 80024f6:	320a      	adds	r2, #10
 80024f8:	8812      	ldrh	r2, [r2, #0]
 80024fa:	1a8a      	subs	r2, r1, r2
 80024fc:	801a      	strh	r2, [r3, #0]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80024fe:	ab02      	add	r3, sp, #8
 8002500:	881b      	ldrh	r3, [r3, #0]
 8002502:	2b04      	cmp	r3, #4
 8002504:	d802      	bhi.n	800250c <chVTDoTickI.4226.4376+0xbc>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002506:	ab02      	add	r3, sp, #8
 8002508:	2205      	movs	r2, #5
 800250a:	801a      	strh	r2, [r3, #0]
  }
  port_timer_set_alarm(now + delta);
 800250c:	466a      	mov	r2, sp
 800250e:	320a      	adds	r2, #10
 8002510:	ab02      	add	r3, sp, #8
 8002512:	8812      	ldrh	r2, [r2, #0]
 8002514:	881b      	ldrh	r3, [r3, #0]
 8002516:	18d3      	adds	r3, r2, r3
 8002518:	b29b      	uxth	r3, r3
 800251a:	1c18      	adds	r0, r3, #0
 800251c:	f7ff ff60 	bl	80023e0 <port_timer_set_alarm.4223.4392>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002520:	b004      	add	sp, #16
 8002522:	bd10      	pop	{r4, pc}
 8002524:	20000300 	.word	0x20000300
 8002528:	2000031c 	.word	0x2000031c
 800252c:	46c0      	nop			; (mov r8, r8)
 800252e:	46c0      	nop			; (mov r8, r8)

08002530 <chRegSetThreadName.4150.4373>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8002530:	b082      	sub	sp, #8
 8002532:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8002534:	4b02      	ldr	r3, [pc, #8]	; (8002540 <chRegSetThreadName.4150.4373+0x10>)
 8002536:	699b      	ldr	r3, [r3, #24]
 8002538:	9a01      	ldr	r2, [sp, #4]
 800253a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800253c:	b002      	add	sp, #8
 800253e:	4770      	bx	lr
 8002540:	20000300 	.word	0x20000300
 8002544:	46c0      	nop			; (mov r8, r8)
 8002546:	46c0      	nop			; (mov r8, r8)
 8002548:	46c0      	nop			; (mov r8, r8)
 800254a:	46c0      	nop			; (mov r8, r8)
 800254c:	46c0      	nop			; (mov r8, r8)
 800254e:	46c0      	nop			; (mov r8, r8)

08002550 <chRegSetThreadNameX.4154.4369>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8002550:	b082      	sub	sp, #8
 8002552:	9001      	str	r0, [sp, #4]
 8002554:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8002556:	9b01      	ldr	r3, [sp, #4]
 8002558:	9a00      	ldr	r2, [sp, #0]
 800255a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800255c:	b002      	add	sp, #8
 800255e:	4770      	bx	lr

08002560 <_idle_thread.4218.4366>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8002560:	b500      	push	{lr}
 8002562:	b083      	sub	sp, #12
 8002564:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8002566:	f7ff ff23 	bl	80023b0 <port_wait_for_interrupt.4129.4399>
 800256a:	e7fc      	b.n	8002566 <_idle_thread.4218.4366+0x6>
 800256c:	46c0      	nop			; (mov r8, r8)
 800256e:	46c0      	nop			; (mov r8, r8)

08002570 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8002570:	b500      	push	{lr}
 8002572:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 8002574:	f7ff feec 	bl	8002350 <port_init.4106.4420>
  _scheduler_init();
 8002578:	f000 fa22 	bl	80029c0 <_scheduler_init.4289>
  _vt_init();
 800257c:	f000 f880 	bl	8002680 <_vt_init.4334>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 8002580:	f7ff f9b6 	bl	80018f0 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 8002584:	f7ff fa0c 	bl	80019a0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8002588:	4b12      	ldr	r3, [pc, #72]	; (80025d4 <chSysInit+0x64>)
 800258a:	1c18      	adds	r0, r3, #0
 800258c:	2140      	movs	r1, #64	; 0x40
 800258e:	f000 fc37 	bl	8002e00 <_thread_init.4187>
 8002592:	1c02      	adds	r2, r0, #0
 8002594:	4b10      	ldr	r3, [pc, #64]	; (80025d8 <chSysInit+0x68>)
 8002596:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8002598:	4b0f      	ldr	r3, [pc, #60]	; (80025d8 <chSysInit+0x68>)
 800259a:	699b      	ldr	r3, [r3, #24]
 800259c:	2201      	movs	r2, #1
 800259e:	771a      	strb	r2, [r3, #28]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
#endif
  chSysEnable();
 80025a0:	f7ff ff36 	bl	8002410 <chSysEnable.4138.4388>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80025a4:	4b0d      	ldr	r3, [pc, #52]	; (80025dc <chSysInit+0x6c>)
 80025a6:	1c18      	adds	r0, r3, #0
 80025a8:	f7ff ffc2 	bl	8002530 <chRegSetThreadName.4150.4373>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80025ac:	4a0c      	ldr	r2, [pc, #48]	; (80025e0 <chSysInit+0x70>)
 80025ae:	4b0d      	ldr	r3, [pc, #52]	; (80025e4 <chSysInit+0x74>)
 80025b0:	2100      	movs	r1, #0
 80025b2:	9100      	str	r1, [sp, #0]
 80025b4:	1c10      	adds	r0, r2, #0
 80025b6:	21c8      	movs	r1, #200	; 0xc8
 80025b8:	2201      	movs	r2, #1
 80025ba:	f000 fc79 	bl	8002eb0 <chThdCreateStatic.4170>
 80025be:	1c03      	adds	r3, r0, #0
 80025c0:	9303      	str	r3, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 80025c2:	9a03      	ldr	r2, [sp, #12]
 80025c4:	4b08      	ldr	r3, [pc, #32]	; (80025e8 <chSysInit+0x78>)
 80025c6:	1c10      	adds	r0, r2, #0
 80025c8:	1c19      	adds	r1, r3, #0
 80025ca:	f7ff ffc1 	bl	8002550 <chRegSetThreadNameX.4154.4369>
  }
#endif
}
 80025ce:	b005      	add	sp, #20
 80025d0:	bd00      	pop	{pc}
 80025d2:	46c0      	nop			; (mov r8, r8)
 80025d4:	2000032c 	.word	0x2000032c
 80025d8:	20000300 	.word	0x20000300
 80025dc:	08003040 	.word	0x08003040
 80025e0:	20000360 	.word	0x20000360
 80025e4:	08002561 	.word	0x08002561
 80025e8:	08003030 	.word	0x08003030
 80025ec:	46c0      	nop			; (mov r8, r8)
 80025ee:	46c0      	nop			; (mov r8, r8)

080025f0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80025f0:	b508      	push	{r3, lr}
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 80025f2:	f7ff ff2d 	bl	8002450 <chVTDoTickI.4226.4376>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 80025f6:	bd08      	pop	{r3, pc}
 80025f8:	46c0      	nop			; (mov r8, r8)
 80025fa:	46c0      	nop			; (mov r8, r8)
 80025fc:	46c0      	nop			; (mov r8, r8)
 80025fe:	46c0      	nop			; (mov r8, r8)

08002600 <st_lld_get_counter.4377.4348>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8002600:	4b02      	ldr	r3, [pc, #8]	; (800260c <st_lld_get_counter.4377.4348+0xc>)
 8002602:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002604:	b29b      	uxth	r3, r3
}
 8002606:	1c18      	adds	r0, r3, #0
 8002608:	4770      	bx	lr
 800260a:	46c0      	nop			; (mov r8, r8)
 800260c:	40000400 	.word	0x40000400

08002610 <port_timer_start_alarm.4387.4345>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 8002610:	b500      	push	{lr}
 8002612:	b083      	sub	sp, #12
 8002614:	1c02      	adds	r2, r0, #0
 8002616:	466b      	mov	r3, sp
 8002618:	3306      	adds	r3, #6
 800261a:	801a      	strh	r2, [r3, #0]

  stStartAlarm(time);
 800261c:	466b      	mov	r3, sp
 800261e:	3306      	adds	r3, #6
 8002620:	881b      	ldrh	r3, [r3, #0]
 8002622:	1c18      	adds	r0, r3, #0
 8002624:	f7ff fa94 	bl	8001b50 <stStartAlarm>
}
 8002628:	b003      	add	sp, #12
 800262a:	bd00      	pop	{pc}
 800262c:	46c0      	nop			; (mov r8, r8)
 800262e:	46c0      	nop			; (mov r8, r8)

08002630 <port_timer_stop_alarm.4393.4343>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 8002630:	b508      	push	{r3, lr}

  stStopAlarm();
 8002632:	f7ff fa9d 	bl	8001b70 <stStopAlarm>
}
 8002636:	bd08      	pop	{r3, pc}
 8002638:	46c0      	nop			; (mov r8, r8)
 800263a:	46c0      	nop			; (mov r8, r8)
 800263c:	46c0      	nop			; (mov r8, r8)
 800263e:	46c0      	nop			; (mov r8, r8)

08002640 <port_timer_set_alarm.4390.4340>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
 8002644:	1c02      	adds	r2, r0, #0
 8002646:	466b      	mov	r3, sp
 8002648:	3306      	adds	r3, #6
 800264a:	801a      	strh	r2, [r3, #0]

  stSetAlarm(time);
 800264c:	466b      	mov	r3, sp
 800264e:	3306      	adds	r3, #6
 8002650:	881b      	ldrh	r3, [r3, #0]
 8002652:	1c18      	adds	r0, r3, #0
 8002654:	f7ff fa94 	bl	8001b80 <stSetAlarm>
}
 8002658:	b003      	add	sp, #12
 800265a:	bd00      	pop	{pc}
 800265c:	46c0      	nop			; (mov r8, r8)
 800265e:	46c0      	nop			; (mov r8, r8)

08002660 <port_timer_get_time.4383.4338>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002660:	b508      	push	{r3, lr}

  return stGetCounter();
 8002662:	f7ff ffcd 	bl	8002600 <st_lld_get_counter.4377.4348>
 8002666:	1c03      	adds	r3, r0, #0
}
 8002668:	1c18      	adds	r0, r3, #0
 800266a:	bd08      	pop	{r3, pc}
 800266c:	46c0      	nop			; (mov r8, r8)
 800266e:	46c0      	nop			; (mov r8, r8)

08002670 <chVTGetSystemTimeX.4385.4336>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002670:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002672:	f7ff fff5 	bl	8002660 <port_timer_get_time.4383.4338>
 8002676:	1c03      	adds	r3, r0, #0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002678:	1c18      	adds	r0, r3, #0
 800267a:	bd08      	pop	{r3, pc}
 800267c:	46c0      	nop			; (mov r8, r8)
 800267e:	46c0      	nop			; (mov r8, r8)

08002680 <_vt_init.4334>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8002680:	4b06      	ldr	r3, [pc, #24]	; (800269c <_vt_init.4334+0x1c>)
 8002682:	4a07      	ldr	r2, [pc, #28]	; (80026a0 <_vt_init.4334+0x20>)
 8002684:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8002686:	4b05      	ldr	r3, [pc, #20]	; (800269c <_vt_init.4334+0x1c>)
 8002688:	4a05      	ldr	r2, [pc, #20]	; (80026a0 <_vt_init.4334+0x20>)
 800268a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800268c:	4b03      	ldr	r3, [pc, #12]	; (800269c <_vt_init.4334+0x1c>)
 800268e:	2201      	movs	r2, #1
 8002690:	4252      	negs	r2, r2
 8002692:	849a      	strh	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8002694:	4b01      	ldr	r3, [pc, #4]	; (800269c <_vt_init.4334+0x1c>)
 8002696:	2200      	movs	r2, #0
 8002698:	84da      	strh	r2, [r3, #38]	; 0x26
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800269a:	4770      	bx	lr
 800269c:	20000300 	.word	0x20000300
 80026a0:	2000031c 	.word	0x2000031c
 80026a4:	46c0      	nop			; (mov r8, r8)
 80026a6:	46c0      	nop			; (mov r8, r8)
 80026a8:	46c0      	nop			; (mov r8, r8)
 80026aa:	46c0      	nop			; (mov r8, r8)
 80026ac:	46c0      	nop			; (mov r8, r8)
 80026ae:	46c0      	nop			; (mov r8, r8)

080026b0 <chVTDoSetI.4328>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80026b0:	b510      	push	{r4, lr}
 80026b2:	b086      	sub	sp, #24
 80026b4:	9003      	str	r0, [sp, #12]
 80026b6:	9201      	str	r2, [sp, #4]
 80026b8:	9300      	str	r3, [sp, #0]
 80026ba:	466b      	mov	r3, sp
 80026bc:	330a      	adds	r3, #10
 80026be:	1c0a      	adds	r2, r1, #0
 80026c0:	801a      	strh	r2, [r3, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80026c2:	9b03      	ldr	r3, [sp, #12]
 80026c4:	9a00      	ldr	r2, [sp, #0]
 80026c6:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 80026c8:	9b03      	ldr	r3, [sp, #12]
 80026ca:	9a01      	ldr	r2, [sp, #4]
 80026cc:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 80026ce:	ac04      	add	r4, sp, #16
 80026d0:	f7ff ffce 	bl	8002670 <chVTGetSystemTimeX.4385.4336>
 80026d4:	1c03      	adds	r3, r0, #0
 80026d6:	8023      	strh	r3, [r4, #0]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80026d8:	466b      	mov	r3, sp
 80026da:	330a      	adds	r3, #10
 80026dc:	881b      	ldrh	r3, [r3, #0]
 80026de:	2b04      	cmp	r3, #4
 80026e0:	d803      	bhi.n	80026ea <chVTDoSetI.4328+0x3a>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 80026e2:	466b      	mov	r3, sp
 80026e4:	330a      	adds	r3, #10
 80026e6:	2205      	movs	r2, #5
 80026e8:	801a      	strh	r2, [r3, #0]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80026ea:	4b3f      	ldr	r3, [pc, #252]	; (80027e8 <chVTDoSetI.4328+0x138>)
 80026ec:	69da      	ldr	r2, [r3, #28]
 80026ee:	4b3f      	ldr	r3, [pc, #252]	; (80027ec <chVTDoSetI.4328+0x13c>)
 80026f0:	429a      	cmp	r2, r3
 80026f2:	d11f      	bne.n	8002734 <chVTDoSetI.4328+0x84>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 80026f4:	4b3c      	ldr	r3, [pc, #240]	; (80027e8 <chVTDoSetI.4328+0x138>)
 80026f6:	aa04      	add	r2, sp, #16
 80026f8:	8812      	ldrh	r2, [r2, #0]
 80026fa:	84da      	strh	r2, [r3, #38]	; 0x26
      ch.vtlist.vt_next = vtp;
 80026fc:	4b3a      	ldr	r3, [pc, #232]	; (80027e8 <chVTDoSetI.4328+0x138>)
 80026fe:	9a03      	ldr	r2, [sp, #12]
 8002700:	61da      	str	r2, [r3, #28]
      ch.vtlist.vt_prev = vtp;
 8002702:	4b39      	ldr	r3, [pc, #228]	; (80027e8 <chVTDoSetI.4328+0x138>)
 8002704:	9a03      	ldr	r2, [sp, #12]
 8002706:	621a      	str	r2, [r3, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8002708:	9b03      	ldr	r3, [sp, #12]
 800270a:	4a38      	ldr	r2, [pc, #224]	; (80027ec <chVTDoSetI.4328+0x13c>)
 800270c:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800270e:	9b03      	ldr	r3, [sp, #12]
 8002710:	4a36      	ldr	r2, [pc, #216]	; (80027ec <chVTDoSetI.4328+0x13c>)
 8002712:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 8002714:	9b03      	ldr	r3, [sp, #12]
 8002716:	466a      	mov	r2, sp
 8002718:	320a      	adds	r2, #10
 800271a:	8812      	ldrh	r2, [r2, #0]
 800271c:	811a      	strh	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 800271e:	4b32      	ldr	r3, [pc, #200]	; (80027e8 <chVTDoSetI.4328+0x138>)
 8002720:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8002722:	466b      	mov	r3, sp
 8002724:	330a      	adds	r3, #10
 8002726:	881b      	ldrh	r3, [r3, #0]
 8002728:	18d3      	adds	r3, r2, r3
 800272a:	b29b      	uxth	r3, r3
 800272c:	1c18      	adds	r0, r3, #0
 800272e:	f7ff ff6f 	bl	8002610 <port_timer_start_alarm.4387.4345>
 8002732:	e056      	b.n	80027e2 <chVTDoSetI.4328+0x132>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8002734:	aa04      	add	r2, sp, #16
 8002736:	466b      	mov	r3, sp
 8002738:	330a      	adds	r3, #10
 800273a:	8812      	ldrh	r2, [r2, #0]
 800273c:	881b      	ldrh	r3, [r3, #0]
 800273e:	18d3      	adds	r3, r2, r3
 8002740:	b299      	uxth	r1, r3
 8002742:	4b29      	ldr	r3, [pc, #164]	; (80027e8 <chVTDoSetI.4328+0x138>)
 8002744:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8002746:	466b      	mov	r3, sp
 8002748:	3312      	adds	r3, #18
 800274a:	1a8a      	subs	r2, r1, r2
 800274c:	801a      	strh	r2, [r3, #0]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800274e:	4b26      	ldr	r3, [pc, #152]	; (80027e8 <chVTDoSetI.4328+0x138>)
 8002750:	69db      	ldr	r3, [r3, #28]
 8002752:	891b      	ldrh	r3, [r3, #8]
 8002754:	466a      	mov	r2, sp
 8002756:	3212      	adds	r2, #18
 8002758:	8812      	ldrh	r2, [r2, #0]
 800275a:	429a      	cmp	r2, r3
 800275c:	d209      	bcs.n	8002772 <chVTDoSetI.4328+0xc2>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 800275e:	4b22      	ldr	r3, [pc, #136]	; (80027e8 <chVTDoSetI.4328+0x138>)
 8002760:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8002762:	466b      	mov	r3, sp
 8002764:	3312      	adds	r3, #18
 8002766:	881b      	ldrh	r3, [r3, #0]
 8002768:	18d3      	adds	r3, r2, r3
 800276a:	b29b      	uxth	r3, r3
 800276c:	1c18      	adds	r0, r3, #0
 800276e:	f7ff ff67 	bl	8002640 <port_timer_set_alarm.4390.4340>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8002772:	4b1d      	ldr	r3, [pc, #116]	; (80027e8 <chVTDoSetI.4328+0x138>)
 8002774:	69db      	ldr	r3, [r3, #28]
 8002776:	9305      	str	r3, [sp, #20]
 8002778:	e00b      	b.n	8002792 <chVTDoSetI.4328+0xe2>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800277a:	9b05      	ldr	r3, [sp, #20]
 800277c:	891a      	ldrh	r2, [r3, #8]
 800277e:	466b      	mov	r3, sp
 8002780:	3312      	adds	r3, #18
 8002782:	4669      	mov	r1, sp
 8002784:	3112      	adds	r1, #18
 8002786:	8809      	ldrh	r1, [r1, #0]
 8002788:	1a8a      	subs	r2, r1, r2
 800278a:	801a      	strh	r2, [r3, #0]
    p = p->vt_next;
 800278c:	9b05      	ldr	r3, [sp, #20]
 800278e:	681b      	ldr	r3, [r3, #0]
 8002790:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8002792:	9b05      	ldr	r3, [sp, #20]
 8002794:	891b      	ldrh	r3, [r3, #8]
 8002796:	466a      	mov	r2, sp
 8002798:	3212      	adds	r2, #18
 800279a:	8812      	ldrh	r2, [r2, #0]
 800279c:	429a      	cmp	r2, r3
 800279e:	d8ec      	bhi.n	800277a <chVTDoSetI.4328+0xca>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80027a0:	9b03      	ldr	r3, [sp, #12]
 80027a2:	9a05      	ldr	r2, [sp, #20]
 80027a4:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80027a6:	9b03      	ldr	r3, [sp, #12]
 80027a8:	681b      	ldr	r3, [r3, #0]
 80027aa:	685a      	ldr	r2, [r3, #4]
 80027ac:	9b03      	ldr	r3, [sp, #12]
 80027ae:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80027b0:	9b03      	ldr	r3, [sp, #12]
 80027b2:	685b      	ldr	r3, [r3, #4]
 80027b4:	9a03      	ldr	r2, [sp, #12]
 80027b6:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 80027b8:	9b05      	ldr	r3, [sp, #20]
 80027ba:	9a03      	ldr	r2, [sp, #12]
 80027bc:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 80027be:	9b03      	ldr	r3, [sp, #12]
 80027c0:	466a      	mov	r2, sp
 80027c2:	3212      	adds	r2, #18
 80027c4:	8812      	ldrh	r2, [r2, #0]
 80027c6:	811a      	strh	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80027c8:	9b05      	ldr	r3, [sp, #20]
 80027ca:	891a      	ldrh	r2, [r3, #8]
 80027cc:	466b      	mov	r3, sp
 80027ce:	3312      	adds	r3, #18
 80027d0:	881b      	ldrh	r3, [r3, #0]
 80027d2:	1ad3      	subs	r3, r2, r3
 80027d4:	b29a      	uxth	r2, r3
 80027d6:	9b05      	ldr	r3, [sp, #20]
 80027d8:	811a      	strh	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80027da:	4b03      	ldr	r3, [pc, #12]	; (80027e8 <chVTDoSetI.4328+0x138>)
 80027dc:	2201      	movs	r2, #1
 80027de:	4252      	negs	r2, r2
 80027e0:	849a      	strh	r2, [r3, #36]	; 0x24
}
 80027e2:	b006      	add	sp, #24
 80027e4:	bd10      	pop	{r4, pc}
 80027e6:	46c0      	nop			; (mov r8, r8)
 80027e8:	20000300 	.word	0x20000300
 80027ec:	2000031c 	.word	0x2000031c

080027f0 <chVTDoResetI.4324>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80027f0:	b500      	push	{lr}
 80027f2:	b085      	sub	sp, #20
 80027f4:	9001      	str	r0, [sp, #4]
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 80027f6:	4b38      	ldr	r3, [pc, #224]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 80027f8:	69da      	ldr	r2, [r3, #28]
 80027fa:	9b01      	ldr	r3, [sp, #4]
 80027fc:	429a      	cmp	r2, r3
 80027fe:	d01c      	beq.n	800283a <chVTDoResetI.4324+0x4a>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8002800:	9b01      	ldr	r3, [sp, #4]
 8002802:	685b      	ldr	r3, [r3, #4]
 8002804:	9a01      	ldr	r2, [sp, #4]
 8002806:	6812      	ldr	r2, [r2, #0]
 8002808:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800280a:	9b01      	ldr	r3, [sp, #4]
 800280c:	681b      	ldr	r3, [r3, #0]
 800280e:	9a01      	ldr	r2, [sp, #4]
 8002810:	6852      	ldr	r2, [r2, #4]
 8002812:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 8002814:	9b01      	ldr	r3, [sp, #4]
 8002816:	2200      	movs	r2, #0
 8002818:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800281a:	9b01      	ldr	r3, [sp, #4]
 800281c:	681a      	ldr	r2, [r3, #0]
 800281e:	4b2f      	ldr	r3, [pc, #188]	; (80028dc <chVTDoResetI.4324+0xec>)
 8002820:	429a      	cmp	r2, r3
 8002822:	d057      	beq.n	80028d4 <chVTDoResetI.4324+0xe4>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8002824:	9b01      	ldr	r3, [sp, #4]
 8002826:	681a      	ldr	r2, [r3, #0]
 8002828:	9b01      	ldr	r3, [sp, #4]
 800282a:	681b      	ldr	r3, [r3, #0]
 800282c:	8919      	ldrh	r1, [r3, #8]
 800282e:	9b01      	ldr	r3, [sp, #4]
 8002830:	891b      	ldrh	r3, [r3, #8]
 8002832:	18cb      	adds	r3, r1, r3
 8002834:	b29b      	uxth	r3, r3
 8002836:	8113      	strh	r3, [r2, #8]
 8002838:	e04c      	b.n	80028d4 <chVTDoResetI.4324+0xe4>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 800283a:	9b01      	ldr	r3, [sp, #4]
 800283c:	681a      	ldr	r2, [r3, #0]
 800283e:	4b26      	ldr	r3, [pc, #152]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 8002840:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8002842:	4b25      	ldr	r3, [pc, #148]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 8002844:	69db      	ldr	r3, [r3, #28]
 8002846:	4a25      	ldr	r2, [pc, #148]	; (80028dc <chVTDoResetI.4324+0xec>)
 8002848:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 800284a:	9b01      	ldr	r3, [sp, #4]
 800284c:	2200      	movs	r2, #0
 800284e:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8002850:	4b21      	ldr	r3, [pc, #132]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 8002852:	69da      	ldr	r2, [r3, #28]
 8002854:	4b21      	ldr	r3, [pc, #132]	; (80028dc <chVTDoResetI.4324+0xec>)
 8002856:	429a      	cmp	r2, r3
 8002858:	d102      	bne.n	8002860 <chVTDoResetI.4324+0x70>
    port_timer_stop_alarm();
 800285a:	f7ff fee9 	bl	8002630 <port_timer_stop_alarm.4393.4343>
 800285e:	e039      	b.n	80028d4 <chVTDoResetI.4324+0xe4>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8002860:	4b1d      	ldr	r3, [pc, #116]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 8002862:	69da      	ldr	r2, [r3, #28]
 8002864:	4b1c      	ldr	r3, [pc, #112]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 8002866:	69db      	ldr	r3, [r3, #28]
 8002868:	8919      	ldrh	r1, [r3, #8]
 800286a:	9b01      	ldr	r3, [sp, #4]
 800286c:	891b      	ldrh	r3, [r3, #8]
 800286e:	18cb      	adds	r3, r1, r3
 8002870:	b29b      	uxth	r3, r3
 8002872:	8113      	strh	r3, [r2, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8002874:	f7ff fefc 	bl	8002670 <chVTGetSystemTimeX.4385.4336>
 8002878:	1c03      	adds	r3, r0, #0
 800287a:	1c19      	adds	r1, r3, #0
 800287c:	4b16      	ldr	r3, [pc, #88]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 800287e:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 8002880:	ab03      	add	r3, sp, #12
 8002882:	1a8a      	subs	r2, r1, r2
 8002884:	801a      	strh	r2, [r3, #0]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8002886:	4b14      	ldr	r3, [pc, #80]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 8002888:	69db      	ldr	r3, [r3, #28]
 800288a:	891b      	ldrh	r3, [r3, #8]
 800288c:	aa03      	add	r2, sp, #12
 800288e:	8812      	ldrh	r2, [r2, #0]
 8002890:	429a      	cmp	r2, r3
 8002892:	d21f      	bcs.n	80028d4 <chVTDoResetI.4324+0xe4>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8002894:	4b10      	ldr	r3, [pc, #64]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 8002896:	69db      	ldr	r3, [r3, #28]
 8002898:	8919      	ldrh	r1, [r3, #8]
 800289a:	466b      	mov	r3, sp
 800289c:	330e      	adds	r3, #14
 800289e:	aa03      	add	r2, sp, #12
 80028a0:	8812      	ldrh	r2, [r2, #0]
 80028a2:	1a8a      	subs	r2, r1, r2
 80028a4:	801a      	strh	r2, [r3, #0]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80028a6:	466b      	mov	r3, sp
 80028a8:	330e      	adds	r3, #14
 80028aa:	881b      	ldrh	r3, [r3, #0]
 80028ac:	2b04      	cmp	r3, #4
 80028ae:	d803      	bhi.n	80028b8 <chVTDoResetI.4324+0xc8>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80028b0:	466b      	mov	r3, sp
 80028b2:	330e      	adds	r3, #14
 80028b4:	2205      	movs	r2, #5
 80028b6:	801a      	strh	r2, [r3, #0]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 80028b8:	4b07      	ldr	r3, [pc, #28]	; (80028d8 <chVTDoResetI.4324+0xe8>)
 80028ba:	8cda      	ldrh	r2, [r3, #38]	; 0x26
 80028bc:	ab03      	add	r3, sp, #12
 80028be:	881b      	ldrh	r3, [r3, #0]
 80028c0:	18d3      	adds	r3, r2, r3
 80028c2:	b29a      	uxth	r2, r3
 80028c4:	466b      	mov	r3, sp
 80028c6:	330e      	adds	r3, #14
 80028c8:	881b      	ldrh	r3, [r3, #0]
 80028ca:	18d3      	adds	r3, r2, r3
 80028cc:	b29b      	uxth	r3, r3
 80028ce:	1c18      	adds	r0, r3, #0
 80028d0:	f7ff feb6 	bl	8002640 <port_timer_set_alarm.4390.4340>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80028d4:	b005      	add	sp, #20
 80028d6:	bd00      	pop	{pc}
 80028d8:	20000300 	.word	0x20000300
 80028dc:	2000031c 	.word	0x2000031c

080028e0 <port_lock.4537.4322>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80028e0:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 80028e2:	4770      	bx	lr
 80028e4:	46c0      	nop			; (mov r8, r8)
 80028e6:	46c0      	nop			; (mov r8, r8)
 80028e8:	46c0      	nop			; (mov r8, r8)
 80028ea:	46c0      	nop			; (mov r8, r8)
 80028ec:	46c0      	nop			; (mov r8, r8)
 80028ee:	46c0      	nop			; (mov r8, r8)

080028f0 <port_unlock.4540.4320>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80028f0:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 80028f2:	4770      	bx	lr
 80028f4:	46c0      	nop			; (mov r8, r8)
 80028f6:	46c0      	nop			; (mov r8, r8)
 80028f8:	46c0      	nop			; (mov r8, r8)
 80028fa:	46c0      	nop			; (mov r8, r8)
 80028fc:	46c0      	nop			; (mov r8, r8)
 80028fe:	46c0      	nop			; (mov r8, r8)

08002900 <port_lock_from_isr.4542.4318>:
/**
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function disables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8002900:	b508      	push	{r3, lr}

  port_lock();
 8002902:	f7ff ffed 	bl	80028e0 <port_lock.4537.4322>
}
 8002906:	bd08      	pop	{r3, pc}
 8002908:	46c0      	nop			; (mov r8, r8)
 800290a:	46c0      	nop			; (mov r8, r8)
 800290c:	46c0      	nop			; (mov r8, r8)
 800290e:	46c0      	nop			; (mov r8, r8)

08002910 <port_unlock_from_isr.4544.4316>:
/**
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function enables interrupts globally.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8002910:	b508      	push	{r3, lr}

  port_unlock();
 8002912:	f7ff ffed 	bl	80028f0 <port_unlock.4540.4320>
}
 8002916:	bd08      	pop	{r3, pc}
 8002918:	46c0      	nop			; (mov r8, r8)
 800291a:	46c0      	nop			; (mov r8, r8)
 800291c:	46c0      	nop			; (mov r8, r8)
 800291e:	46c0      	nop			; (mov r8, r8)

08002920 <queue_init.4546.4313>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002920:	b082      	sub	sp, #8
 8002922:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002924:	9b01      	ldr	r3, [sp, #4]
 8002926:	9a01      	ldr	r2, [sp, #4]
 8002928:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800292a:	9b01      	ldr	r3, [sp, #4]
 800292c:	9a01      	ldr	r2, [sp, #4]
 800292e:	605a      	str	r2, [r3, #4]
}
 8002930:	b002      	add	sp, #8
 8002932:	4770      	bx	lr
 8002934:	46c0      	nop			; (mov r8, r8)
 8002936:	46c0      	nop			; (mov r8, r8)
 8002938:	46c0      	nop			; (mov r8, r8)
 800293a:	46c0      	nop			; (mov r8, r8)
 800293c:	46c0      	nop			; (mov r8, r8)
 800293e:	46c0      	nop			; (mov r8, r8)

08002940 <chSchIsRescRequiredI.4612.4311>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8002940:	4b05      	ldr	r3, [pc, #20]	; (8002958 <chSchIsRescRequiredI.4612.4311+0x18>)
 8002942:	681b      	ldr	r3, [r3, #0]
 8002944:	689a      	ldr	r2, [r3, #8]
 8002946:	4b04      	ldr	r3, [pc, #16]	; (8002958 <chSchIsRescRequiredI.4612.4311+0x18>)
 8002948:	699b      	ldr	r3, [r3, #24]
 800294a:	689b      	ldr	r3, [r3, #8]
 800294c:	4293      	cmp	r3, r2
 800294e:	419b      	sbcs	r3, r3
 8002950:	425b      	negs	r3, r3
 8002952:	b2db      	uxtb	r3, r3
}
 8002954:	1c18      	adds	r0, r3, #0
 8002956:	4770      	bx	lr
 8002958:	20000300 	.word	0x20000300
 800295c:	46c0      	nop			; (mov r8, r8)
 800295e:	46c0      	nop			; (mov r8, r8)

08002960 <chSysLockFromISR.4615.4309>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8002960:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8002962:	f7ff ffcd 	bl	8002900 <port_lock_from_isr.4542.4318>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8002966:	bd08      	pop	{r3, pc}
 8002968:	46c0      	nop			; (mov r8, r8)
 800296a:	46c0      	nop			; (mov r8, r8)
 800296c:	46c0      	nop			; (mov r8, r8)
 800296e:	46c0      	nop			; (mov r8, r8)

08002970 <chSysUnlockFromISR.4617.4307>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8002970:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8002972:	f7ff ffcd 	bl	8002910 <port_unlock_from_isr.4544.4316>
}
 8002976:	bd08      	pop	{r3, pc}
 8002978:	46c0      	nop			; (mov r8, r8)
 800297a:	46c0      	nop			; (mov r8, r8)
 800297c:	46c0      	nop			; (mov r8, r8)
 800297e:	46c0      	nop			; (mov r8, r8)

08002980 <chVTIsArmedI.4619.4296>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8002980:	b082      	sub	sp, #8
 8002982:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8002984:	9b01      	ldr	r3, [sp, #4]
 8002986:	68db      	ldr	r3, [r3, #12]
 8002988:	1e5a      	subs	r2, r3, #1
 800298a:	4193      	sbcs	r3, r2
 800298c:	b2db      	uxtb	r3, r3
}
 800298e:	1c18      	adds	r0, r3, #0
 8002990:	b002      	add	sp, #8
 8002992:	4770      	bx	lr
 8002994:	46c0      	nop			; (mov r8, r8)
 8002996:	46c0      	nop			; (mov r8, r8)
 8002998:	46c0      	nop			; (mov r8, r8)
 800299a:	46c0      	nop			; (mov r8, r8)
 800299c:	46c0      	nop			; (mov r8, r8)
 800299e:	46c0      	nop			; (mov r8, r8)

080029a0 <chSemFastSignalI.4633.4291>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 80029a0:	b082      	sub	sp, #8
 80029a2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 80029a4:	9b01      	ldr	r3, [sp, #4]
 80029a6:	689b      	ldr	r3, [r3, #8]
 80029a8:	1c5a      	adds	r2, r3, #1
 80029aa:	9b01      	ldr	r3, [sp, #4]
 80029ac:	609a      	str	r2, [r3, #8]
}
 80029ae:	b002      	add	sp, #8
 80029b0:	4770      	bx	lr
 80029b2:	46c0      	nop			; (mov r8, r8)
 80029b4:	46c0      	nop			; (mov r8, r8)
 80029b6:	46c0      	nop			; (mov r8, r8)
 80029b8:	46c0      	nop			; (mov r8, r8)
 80029ba:	46c0      	nop			; (mov r8, r8)
 80029bc:	46c0      	nop			; (mov r8, r8)
 80029be:	46c0      	nop			; (mov r8, r8)

080029c0 <_scheduler_init.4289>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 80029c0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 80029c2:	4b07      	ldr	r3, [pc, #28]	; (80029e0 <_scheduler_init.4289+0x20>)
 80029c4:	1c18      	adds	r0, r3, #0
 80029c6:	f7ff ffab 	bl	8002920 <queue_init.4546.4313>
  ch.rlist.r_prio = NOPRIO;
 80029ca:	4b05      	ldr	r3, [pc, #20]	; (80029e0 <_scheduler_init.4289+0x20>)
 80029cc:	2200      	movs	r2, #0
 80029ce:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 80029d0:	4b03      	ldr	r3, [pc, #12]	; (80029e0 <_scheduler_init.4289+0x20>)
 80029d2:	4a03      	ldr	r2, [pc, #12]	; (80029e0 <_scheduler_init.4289+0x20>)
 80029d4:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 80029d6:	4b02      	ldr	r3, [pc, #8]	; (80029e0 <_scheduler_init.4289+0x20>)
 80029d8:	4a01      	ldr	r2, [pc, #4]	; (80029e0 <_scheduler_init.4289+0x20>)
 80029da:	615a      	str	r2, [r3, #20]
#endif
}
 80029dc:	bd08      	pop	{r3, pc}
 80029de:	46c0      	nop			; (mov r8, r8)
 80029e0:	20000300 	.word	0x20000300
 80029e4:	46c0      	nop			; (mov r8, r8)
 80029e6:	46c0      	nop			; (mov r8, r8)
 80029e8:	46c0      	nop			; (mov r8, r8)
 80029ea:	46c0      	nop			; (mov r8, r8)
 80029ec:	46c0      	nop			; (mov r8, r8)
 80029ee:	46c0      	nop			; (mov r8, r8)

080029f0 <queue_insert>:
 * @param[in] tp        the pointer to the thread to be inserted in the list
 * @param[in] tqp       the pointer to the threads list header
 *
 * @notapi
 */
void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 80029f0:	b082      	sub	sp, #8
 80029f2:	9001      	str	r0, [sp, #4]
 80029f4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 80029f6:	9b01      	ldr	r3, [sp, #4]
 80029f8:	9a00      	ldr	r2, [sp, #0]
 80029fa:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80029fc:	9b00      	ldr	r3, [sp, #0]
 80029fe:	685a      	ldr	r2, [r3, #4]
 8002a00:	9b01      	ldr	r3, [sp, #4]
 8002a02:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8002a04:	9b01      	ldr	r3, [sp, #4]
 8002a06:	685b      	ldr	r3, [r3, #4]
 8002a08:	9a01      	ldr	r2, [sp, #4]
 8002a0a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8002a0c:	9b00      	ldr	r3, [sp, #0]
 8002a0e:	9a01      	ldr	r2, [sp, #4]
 8002a10:	605a      	str	r2, [r3, #4]
}
 8002a12:	b002      	add	sp, #8
 8002a14:	4770      	bx	lr
 8002a16:	46c0      	nop			; (mov r8, r8)
 8002a18:	46c0      	nop			; (mov r8, r8)
 8002a1a:	46c0      	nop			; (mov r8, r8)
 8002a1c:	46c0      	nop			; (mov r8, r8)
 8002a1e:	46c0      	nop			; (mov r8, r8)

08002a20 <queue_fifo_remove>:
 * @param[in] tqp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002a20:	b084      	sub	sp, #16
 8002a22:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8002a24:	9b01      	ldr	r3, [sp, #4]
 8002a26:	681b      	ldr	r3, [r3, #0]
 8002a28:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8002a2a:	9b03      	ldr	r3, [sp, #12]
 8002a2c:	681a      	ldr	r2, [r3, #0]
 8002a2e:	9b01      	ldr	r3, [sp, #4]
 8002a30:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002a32:	9b01      	ldr	r3, [sp, #4]
 8002a34:	681b      	ldr	r3, [r3, #0]
 8002a36:	9a01      	ldr	r2, [sp, #4]
 8002a38:	605a      	str	r2, [r3, #4]

  return tp;
 8002a3a:	9b03      	ldr	r3, [sp, #12]
}
 8002a3c:	1c18      	adds	r0, r3, #0
 8002a3e:	b004      	add	sp, #16
 8002a40:	4770      	bx	lr
 8002a42:	46c0      	nop			; (mov r8, r8)
 8002a44:	46c0      	nop			; (mov r8, r8)
 8002a46:	46c0      	nop			; (mov r8, r8)
 8002a48:	46c0      	nop			; (mov r8, r8)
 8002a4a:	46c0      	nop			; (mov r8, r8)
 8002a4c:	46c0      	nop			; (mov r8, r8)
 8002a4e:	46c0      	nop			; (mov r8, r8)

08002a50 <queue_dequeue>:
 * @param[in] tp        the pointer to the thread to be removed from the queue
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *queue_dequeue(thread_t *tp) {
 8002a50:	b082      	sub	sp, #8
 8002a52:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8002a54:	9b01      	ldr	r3, [sp, #4]
 8002a56:	685b      	ldr	r3, [r3, #4]
 8002a58:	9a01      	ldr	r2, [sp, #4]
 8002a5a:	6812      	ldr	r2, [r2, #0]
 8002a5c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8002a5e:	9b01      	ldr	r3, [sp, #4]
 8002a60:	681b      	ldr	r3, [r3, #0]
 8002a62:	9a01      	ldr	r2, [sp, #4]
 8002a64:	6852      	ldr	r2, [r2, #4]
 8002a66:	605a      	str	r2, [r3, #4]

  return tp;
 8002a68:	9b01      	ldr	r3, [sp, #4]
}
 8002a6a:	1c18      	adds	r0, r3, #0
 8002a6c:	b002      	add	sp, #8
 8002a6e:	4770      	bx	lr

08002a70 <list_remove.4265>:
 * @param[in] tlp       the pointer to the threads list header
 * @return              The removed thread pointer.
 *
 * @notapi
 */
thread_t *list_remove(threads_list_t *tlp) {
 8002a70:	b084      	sub	sp, #16
 8002a72:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8002a74:	9b01      	ldr	r3, [sp, #4]
 8002a76:	681b      	ldr	r3, [r3, #0]
 8002a78:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8002a7a:	9b03      	ldr	r3, [sp, #12]
 8002a7c:	681a      	ldr	r2, [r3, #0]
 8002a7e:	9b01      	ldr	r3, [sp, #4]
 8002a80:	601a      	str	r2, [r3, #0]

  return tp;
 8002a82:	9b03      	ldr	r3, [sp, #12]
}
 8002a84:	1c18      	adds	r0, r3, #0
 8002a86:	b004      	add	sp, #16
 8002a88:	4770      	bx	lr
 8002a8a:	46c0      	nop			; (mov r8, r8)
 8002a8c:	46c0      	nop			; (mov r8, r8)
 8002a8e:	46c0      	nop			; (mov r8, r8)

08002a90 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8002a90:	b084      	sub	sp, #16
 8002a92:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8002a94:	9b01      	ldr	r3, [sp, #4]
 8002a96:	2200      	movs	r2, #0
 8002a98:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8002a9a:	4b0e      	ldr	r3, [pc, #56]	; (8002ad4 <chSchReadyI+0x44>)
 8002a9c:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8002a9e:	9b03      	ldr	r3, [sp, #12]
 8002aa0:	681b      	ldr	r3, [r3, #0]
 8002aa2:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8002aa4:	9b03      	ldr	r3, [sp, #12]
 8002aa6:	689a      	ldr	r2, [r3, #8]
 8002aa8:	9b01      	ldr	r3, [sp, #4]
 8002aaa:	689b      	ldr	r3, [r3, #8]
 8002aac:	429a      	cmp	r2, r3
 8002aae:	d2f6      	bcs.n	8002a9e <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8002ab0:	9b01      	ldr	r3, [sp, #4]
 8002ab2:	9a03      	ldr	r2, [sp, #12]
 8002ab4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8002ab6:	9b03      	ldr	r3, [sp, #12]
 8002ab8:	685a      	ldr	r2, [r3, #4]
 8002aba:	9b01      	ldr	r3, [sp, #4]
 8002abc:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8002abe:	9b01      	ldr	r3, [sp, #4]
 8002ac0:	685b      	ldr	r3, [r3, #4]
 8002ac2:	9a01      	ldr	r2, [sp, #4]
 8002ac4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8002ac6:	9b03      	ldr	r3, [sp, #12]
 8002ac8:	9a01      	ldr	r2, [sp, #4]
 8002aca:	605a      	str	r2, [r3, #4]

  return tp;
 8002acc:	9b01      	ldr	r3, [sp, #4]
}
 8002ace:	1c18      	adds	r0, r3, #0
 8002ad0:	b004      	add	sp, #16
 8002ad2:	4770      	bx	lr
 8002ad4:	20000300 	.word	0x20000300
 8002ad8:	46c0      	nop			; (mov r8, r8)
 8002ada:	46c0      	nop			; (mov r8, r8)
 8002adc:	46c0      	nop			; (mov r8, r8)
 8002ade:	46c0      	nop			; (mov r8, r8)

08002ae0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8002ae0:	b500      	push	{lr}
 8002ae2:	b085      	sub	sp, #20
 8002ae4:	1c02      	adds	r2, r0, #0
 8002ae6:	466b      	mov	r3, sp
 8002ae8:	3307      	adds	r3, #7
 8002aea:	701a      	strb	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8002aec:	4b0d      	ldr	r3, [pc, #52]	; (8002b24 <chSchGoSleepS+0x44>)
 8002aee:	699b      	ldr	r3, [r3, #24]
 8002af0:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8002af2:	9b03      	ldr	r3, [sp, #12]
 8002af4:	466a      	mov	r2, sp
 8002af6:	3207      	adds	r2, #7
 8002af8:	7812      	ldrb	r2, [r2, #0]
 8002afa:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8002afc:	4b09      	ldr	r3, [pc, #36]	; (8002b24 <chSchGoSleepS+0x44>)
 8002afe:	1c18      	adds	r0, r3, #0
 8002b00:	f7ff ff8e 	bl	8002a20 <queue_fifo_remove>
 8002b04:	1c02      	adds	r2, r0, #0
 8002b06:	4b07      	ldr	r3, [pc, #28]	; (8002b24 <chSchGoSleepS+0x44>)
 8002b08:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8002b0a:	4b06      	ldr	r3, [pc, #24]	; (8002b24 <chSchGoSleepS+0x44>)
 8002b0c:	699b      	ldr	r3, [r3, #24]
 8002b0e:	2201      	movs	r2, #1
 8002b10:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 8002b12:	4b04      	ldr	r3, [pc, #16]	; (8002b24 <chSchGoSleepS+0x44>)
 8002b14:	699a      	ldr	r2, [r3, #24]
 8002b16:	9b03      	ldr	r3, [sp, #12]
 8002b18:	1c10      	adds	r0, r2, #0
 8002b1a:	1c19      	adds	r1, r3, #0
 8002b1c:	f7fd fb38 	bl	8000190 <_port_switch>
}
 8002b20:	b005      	add	sp, #20
 8002b22:	bd00      	pop	{pc}
 8002b24:	20000300 	.word	0x20000300
 8002b28:	46c0      	nop			; (mov r8, r8)
 8002b2a:	46c0      	nop			; (mov r8, r8)
 8002b2c:	46c0      	nop			; (mov r8, r8)
 8002b2e:	46c0      	nop			; (mov r8, r8)

08002b30 <wakeup.4666.4256>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8002b30:	b500      	push	{lr}
 8002b32:	b085      	sub	sp, #20
 8002b34:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8002b36:	9b01      	ldr	r3, [sp, #4]
 8002b38:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8002b3a:	f7ff ff11 	bl	8002960 <chSysLockFromISR.4615.4309>
  switch (tp->p_state) {
 8002b3e:	9b03      	ldr	r3, [sp, #12]
 8002b40:	7f1b      	ldrb	r3, [r3, #28]
 8002b42:	2b07      	cmp	r3, #7
 8002b44:	d815      	bhi.n	8002b72 <wakeup.4666.4256+0x42>
 8002b46:	009a      	lsls	r2, r3, #2
 8002b48:	4b10      	ldr	r3, [pc, #64]	; (8002b8c <wakeup.4666.4256+0x5c>)
 8002b4a:	18d3      	adds	r3, r2, r3
 8002b4c:	681b      	ldr	r3, [r3, #0]
 8002b4e:	469f      	mov	pc, r3
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8002b50:	f7ff ff0e 	bl	8002970 <chSysUnlockFromISR.4617.4307>
 8002b54:	e017      	b.n	8002b86 <wakeup.4666.4256+0x56>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8002b56:	9b03      	ldr	r3, [sp, #12]
 8002b58:	6a1b      	ldr	r3, [r3, #32]
 8002b5a:	2200      	movs	r2, #0
 8002b5c:	601a      	str	r2, [r3, #0]
 8002b5e:	e008      	b.n	8002b72 <wakeup.4666.4256+0x42>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8002b60:	9b03      	ldr	r3, [sp, #12]
 8002b62:	6a1b      	ldr	r3, [r3, #32]
 8002b64:	1c18      	adds	r0, r3, #0
 8002b66:	f7ff ff1b 	bl	80029a0 <chSemFastSignalI.4633.4291>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8002b6a:	9b03      	ldr	r3, [sp, #12]
 8002b6c:	1c18      	adds	r0, r3, #0
 8002b6e:	f7ff ff6f 	bl	8002a50 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8002b72:	9b03      	ldr	r3, [sp, #12]
 8002b74:	2201      	movs	r2, #1
 8002b76:	4252      	negs	r2, r2
 8002b78:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8002b7a:	9b03      	ldr	r3, [sp, #12]
 8002b7c:	1c18      	adds	r0, r3, #0
 8002b7e:	f7ff ff87 	bl	8002a90 <chSchReadyI>
  chSysUnlockFromISR();
 8002b82:	f7ff fef5 	bl	8002970 <chSysUnlockFromISR.4617.4307>
}
 8002b86:	b005      	add	sp, #20
 8002b88:	bd00      	pop	{pc}
 8002b8a:	46c0      	nop			; (mov r8, r8)
 8002b8c:	080031a0 	.word	0x080031a0

08002b90 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8002b90:	b500      	push	{lr}
 8002b92:	b089      	sub	sp, #36	; 0x24
 8002b94:	1c0a      	adds	r2, r1, #0
 8002b96:	466b      	mov	r3, sp
 8002b98:	3307      	adds	r3, #7
 8002b9a:	1c01      	adds	r1, r0, #0
 8002b9c:	7019      	strb	r1, [r3, #0]
 8002b9e:	ab01      	add	r3, sp, #4
 8002ba0:	801a      	strh	r2, [r3, #0]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8002ba2:	ab01      	add	r3, sp, #4
 8002ba4:	881a      	ldrh	r2, [r3, #0]
 8002ba6:	4b14      	ldr	r3, [pc, #80]	; (8002bf8 <chSchGoSleepTimeoutS+0x68>)
 8002ba8:	429a      	cmp	r2, r3
 8002baa:	d019      	beq.n	8002be0 <chSchGoSleepTimeoutS+0x50>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8002bac:	4b13      	ldr	r3, [pc, #76]	; (8002bfc <chSchGoSleepTimeoutS+0x6c>)
 8002bae:	699b      	ldr	r3, [r3, #24]
 8002bb0:	a803      	add	r0, sp, #12
 8002bb2:	aa01      	add	r2, sp, #4
 8002bb4:	8811      	ldrh	r1, [r2, #0]
 8002bb6:	4a12      	ldr	r2, [pc, #72]	; (8002c00 <chSchGoSleepTimeoutS+0x70>)
 8002bb8:	f7ff fd7a 	bl	80026b0 <chVTDoSetI.4328>
    chSchGoSleepS(newstate);
 8002bbc:	466b      	mov	r3, sp
 8002bbe:	3307      	adds	r3, #7
 8002bc0:	781b      	ldrb	r3, [r3, #0]
 8002bc2:	1c18      	adds	r0, r3, #0
 8002bc4:	f7ff ff8c 	bl	8002ae0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8002bc8:	ab03      	add	r3, sp, #12
 8002bca:	1c18      	adds	r0, r3, #0
 8002bcc:	f7ff fed8 	bl	8002980 <chVTIsArmedI.4619.4296>
 8002bd0:	1c03      	adds	r3, r0, #0
 8002bd2:	2b00      	cmp	r3, #0
 8002bd4:	d00a      	beq.n	8002bec <chSchGoSleepTimeoutS+0x5c>
      chVTDoResetI(&vt);
 8002bd6:	ab03      	add	r3, sp, #12
 8002bd8:	1c18      	adds	r0, r3, #0
 8002bda:	f7ff fe09 	bl	80027f0 <chVTDoResetI.4324>
 8002bde:	e005      	b.n	8002bec <chSchGoSleepTimeoutS+0x5c>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8002be0:	466b      	mov	r3, sp
 8002be2:	3307      	adds	r3, #7
 8002be4:	781b      	ldrb	r3, [r3, #0]
 8002be6:	1c18      	adds	r0, r3, #0
 8002be8:	f7ff ff7a 	bl	8002ae0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8002bec:	4b03      	ldr	r3, [pc, #12]	; (8002bfc <chSchGoSleepTimeoutS+0x6c>)
 8002bee:	699b      	ldr	r3, [r3, #24]
 8002bf0:	6a1b      	ldr	r3, [r3, #32]
}
 8002bf2:	1c18      	adds	r0, r3, #0
 8002bf4:	b009      	add	sp, #36	; 0x24
 8002bf6:	bd00      	pop	{pc}
 8002bf8:	0000ffff 	.word	0x0000ffff
 8002bfc:	20000300 	.word	0x20000300
 8002c00:	08002b31 	.word	0x08002b31
 8002c04:	46c0      	nop			; (mov r8, r8)
 8002c06:	46c0      	nop			; (mov r8, r8)
 8002c08:	46c0      	nop			; (mov r8, r8)
 8002c0a:	46c0      	nop			; (mov r8, r8)
 8002c0c:	46c0      	nop			; (mov r8, r8)
 8002c0e:	46c0      	nop			; (mov r8, r8)

08002c10 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8002c10:	b500      	push	{lr}
 8002c12:	b085      	sub	sp, #20
 8002c14:	9001      	str	r0, [sp, #4]
 8002c16:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8002c18:	9b01      	ldr	r3, [sp, #4]
 8002c1a:	9a00      	ldr	r2, [sp, #0]
 8002c1c:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8002c1e:	9b01      	ldr	r3, [sp, #4]
 8002c20:	689a      	ldr	r2, [r3, #8]
 8002c22:	4b0f      	ldr	r3, [pc, #60]	; (8002c60 <chSchWakeupS+0x50>)
 8002c24:	699b      	ldr	r3, [r3, #24]
 8002c26:	689b      	ldr	r3, [r3, #8]
 8002c28:	429a      	cmp	r2, r3
 8002c2a:	d804      	bhi.n	8002c36 <chSchWakeupS+0x26>
    (void) chSchReadyI(ntp);
 8002c2c:	9b01      	ldr	r3, [sp, #4]
 8002c2e:	1c18      	adds	r0, r3, #0
 8002c30:	f7ff ff2e 	bl	8002a90 <chSchReadyI>
 8002c34:	e012      	b.n	8002c5c <chSchWakeupS+0x4c>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8002c36:	4b0a      	ldr	r3, [pc, #40]	; (8002c60 <chSchWakeupS+0x50>)
 8002c38:	699b      	ldr	r3, [r3, #24]
 8002c3a:	1c18      	adds	r0, r3, #0
 8002c3c:	f7ff ff28 	bl	8002a90 <chSchReadyI>
 8002c40:	1c03      	adds	r3, r0, #0
 8002c42:	9303      	str	r3, [sp, #12]
    setcurrp(ntp);
 8002c44:	4b06      	ldr	r3, [pc, #24]	; (8002c60 <chSchWakeupS+0x50>)
 8002c46:	9a01      	ldr	r2, [sp, #4]
 8002c48:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8002c4a:	9b01      	ldr	r3, [sp, #4]
 8002c4c:	2201      	movs	r2, #1
 8002c4e:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8002c50:	9a01      	ldr	r2, [sp, #4]
 8002c52:	9b03      	ldr	r3, [sp, #12]
 8002c54:	1c10      	adds	r0, r2, #0
 8002c56:	1c19      	adds	r1, r3, #0
 8002c58:	f7fd fa9a 	bl	8000190 <_port_switch>
  }
}
 8002c5c:	b005      	add	sp, #20
 8002c5e:	bd00      	pop	{pc}
 8002c60:	20000300 	.word	0x20000300
 8002c64:	46c0      	nop			; (mov r8, r8)
 8002c66:	46c0      	nop			; (mov r8, r8)
 8002c68:	46c0      	nop			; (mov r8, r8)
 8002c6a:	46c0      	nop			; (mov r8, r8)
 8002c6c:	46c0      	nop			; (mov r8, r8)
 8002c6e:	46c0      	nop			; (mov r8, r8)

08002c70 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8002c70:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8002c72:	f7ff fe65 	bl	8002940 <chSchIsRescRequiredI.4612.4311>
 8002c76:	1c03      	adds	r3, r0, #0
 8002c78:	2b00      	cmp	r3, #0
 8002c7a:	d001      	beq.n	8002c80 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 8002c7c:	f000 f820 	bl	8002cc0 <chSchDoRescheduleAhead.4240>
  }
}
 8002c80:	bd08      	pop	{r3, pc}
 8002c82:	46c0      	nop			; (mov r8, r8)
 8002c84:	46c0      	nop			; (mov r8, r8)
 8002c86:	46c0      	nop			; (mov r8, r8)
 8002c88:	46c0      	nop			; (mov r8, r8)
 8002c8a:	46c0      	nop			; (mov r8, r8)
 8002c8c:	46c0      	nop			; (mov r8, r8)
 8002c8e:	46c0      	nop			; (mov r8, r8)

08002c90 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8002c90:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8002c92:	4b08      	ldr	r3, [pc, #32]	; (8002cb4 <chSchIsPreemptionRequired+0x24>)
 8002c94:	681b      	ldr	r3, [r3, #0]
 8002c96:	689b      	ldr	r3, [r3, #8]
 8002c98:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8002c9a:	4b06      	ldr	r3, [pc, #24]	; (8002cb4 <chSchIsPreemptionRequired+0x24>)
 8002c9c:	699b      	ldr	r3, [r3, #24]
 8002c9e:	689b      	ldr	r3, [r3, #8]
 8002ca0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8002ca2:	9b01      	ldr	r3, [sp, #4]
 8002ca4:	9a00      	ldr	r2, [sp, #0]
 8002ca6:	429a      	cmp	r2, r3
 8002ca8:	419b      	sbcs	r3, r3
 8002caa:	425b      	negs	r3, r3
 8002cac:	b2db      	uxtb	r3, r3
#endif
}
 8002cae:	1c18      	adds	r0, r3, #0
 8002cb0:	b002      	add	sp, #8
 8002cb2:	4770      	bx	lr
 8002cb4:	20000300 	.word	0x20000300
 8002cb8:	46c0      	nop			; (mov r8, r8)
 8002cba:	46c0      	nop			; (mov r8, r8)
 8002cbc:	46c0      	nop			; (mov r8, r8)
 8002cbe:	46c0      	nop			; (mov r8, r8)

08002cc0 <chSchDoRescheduleAhead.4240>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8002cc0:	b500      	push	{lr}
 8002cc2:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8002cc4:	4b19      	ldr	r3, [pc, #100]	; (8002d2c <chSchDoRescheduleAhead.4240+0x6c>)
 8002cc6:	699b      	ldr	r3, [r3, #24]
 8002cc8:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8002cca:	4b18      	ldr	r3, [pc, #96]	; (8002d2c <chSchDoRescheduleAhead.4240+0x6c>)
 8002ccc:	1c18      	adds	r0, r3, #0
 8002cce:	f7ff fea7 	bl	8002a20 <queue_fifo_remove>
 8002cd2:	1c02      	adds	r2, r0, #0
 8002cd4:	4b15      	ldr	r3, [pc, #84]	; (8002d2c <chSchDoRescheduleAhead.4240+0x6c>)
 8002cd6:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8002cd8:	4b14      	ldr	r3, [pc, #80]	; (8002d2c <chSchDoRescheduleAhead.4240+0x6c>)
 8002cda:	699b      	ldr	r3, [r3, #24]
 8002cdc:	2201      	movs	r2, #1
 8002cde:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8002ce0:	9b00      	ldr	r3, [sp, #0]
 8002ce2:	2200      	movs	r2, #0
 8002ce4:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8002ce6:	4b11      	ldr	r3, [pc, #68]	; (8002d2c <chSchDoRescheduleAhead.4240+0x6c>)
 8002ce8:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8002cea:	9b01      	ldr	r3, [sp, #4]
 8002cec:	681b      	ldr	r3, [r3, #0]
 8002cee:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8002cf0:	9b01      	ldr	r3, [sp, #4]
 8002cf2:	689a      	ldr	r2, [r3, #8]
 8002cf4:	9b00      	ldr	r3, [sp, #0]
 8002cf6:	689b      	ldr	r3, [r3, #8]
 8002cf8:	429a      	cmp	r2, r3
 8002cfa:	d8f6      	bhi.n	8002cea <chSchDoRescheduleAhead.4240+0x2a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8002cfc:	9b00      	ldr	r3, [sp, #0]
 8002cfe:	9a01      	ldr	r2, [sp, #4]
 8002d00:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8002d02:	9b01      	ldr	r3, [sp, #4]
 8002d04:	685a      	ldr	r2, [r3, #4]
 8002d06:	9b00      	ldr	r3, [sp, #0]
 8002d08:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8002d0a:	9b00      	ldr	r3, [sp, #0]
 8002d0c:	685b      	ldr	r3, [r3, #4]
 8002d0e:	9a00      	ldr	r2, [sp, #0]
 8002d10:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8002d12:	9b01      	ldr	r3, [sp, #4]
 8002d14:	9a00      	ldr	r2, [sp, #0]
 8002d16:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8002d18:	4b04      	ldr	r3, [pc, #16]	; (8002d2c <chSchDoRescheduleAhead.4240+0x6c>)
 8002d1a:	699a      	ldr	r2, [r3, #24]
 8002d1c:	9b00      	ldr	r3, [sp, #0]
 8002d1e:	1c10      	adds	r0, r2, #0
 8002d20:	1c19      	adds	r1, r3, #0
 8002d22:	f7fd fa35 	bl	8000190 <_port_switch>
}
 8002d26:	b003      	add	sp, #12
 8002d28:	bd00      	pop	{pc}
 8002d2a:	46c0      	nop			; (mov r8, r8)
 8002d2c:	20000300 	.word	0x20000300

08002d30 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8002d30:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8002d32:	f7ff ffc5 	bl	8002cc0 <chSchDoRescheduleAhead.4240>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8002d36:	bd08      	pop	{r3, pc}
 8002d38:	46c0      	nop			; (mov r8, r8)
 8002d3a:	46c0      	nop			; (mov r8, r8)
 8002d3c:	46c0      	nop			; (mov r8, r8)
 8002d3e:	46c0      	nop			; (mov r8, r8)

08002d40 <port_lock.4742.4235>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002d40:	b672      	cpsid	i
 * @details In this port this function disables interrupts globally.
 */
static inline void port_lock(void) {

  __disable_irq();
}
 8002d42:	4770      	bx	lr
 8002d44:	46c0      	nop			; (mov r8, r8)
 8002d46:	46c0      	nop			; (mov r8, r8)
 8002d48:	46c0      	nop			; (mov r8, r8)
 8002d4a:	46c0      	nop			; (mov r8, r8)
 8002d4c:	46c0      	nop			; (mov r8, r8)
 8002d4e:	46c0      	nop			; (mov r8, r8)

08002d50 <port_unlock.4745.4233>:
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002d50:	b662      	cpsie	i
 * @details In this port this function enables interrupts globally.
 */
static inline void port_unlock(void) {

  __enable_irq();
}
 8002d52:	4770      	bx	lr
 8002d54:	46c0      	nop			; (mov r8, r8)
 8002d56:	46c0      	nop			; (mov r8, r8)
 8002d58:	46c0      	nop			; (mov r8, r8)
 8002d5a:	46c0      	nop			; (mov r8, r8)
 8002d5c:	46c0      	nop			; (mov r8, r8)
 8002d5e:	46c0      	nop			; (mov r8, r8)

08002d60 <list_init.4754.4226>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8002d60:	b082      	sub	sp, #8
 8002d62:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8002d64:	9b01      	ldr	r3, [sp, #4]
 8002d66:	9a01      	ldr	r2, [sp, #4]
 8002d68:	601a      	str	r2, [r3, #0]
}
 8002d6a:	b002      	add	sp, #8
 8002d6c:	4770      	bx	lr
 8002d6e:	46c0      	nop			; (mov r8, r8)

08002d70 <list_notempty.4820.4223>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8002d70:	b082      	sub	sp, #8
 8002d72:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8002d74:	9b01      	ldr	r3, [sp, #4]
 8002d76:	681a      	ldr	r2, [r3, #0]
 8002d78:	9b01      	ldr	r3, [sp, #4]
 8002d7a:	1ad3      	subs	r3, r2, r3
 8002d7c:	1e5a      	subs	r2, r3, #1
 8002d7e:	4193      	sbcs	r3, r2
 8002d80:	b2db      	uxtb	r3, r3
}
 8002d82:	1c18      	adds	r0, r3, #0
 8002d84:	b002      	add	sp, #8
 8002d86:	4770      	bx	lr
 8002d88:	46c0      	nop			; (mov r8, r8)
 8002d8a:	46c0      	nop			; (mov r8, r8)
 8002d8c:	46c0      	nop			; (mov r8, r8)
 8002d8e:	46c0      	nop			; (mov r8, r8)

08002d90 <queue_notempty.4824.4219>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002d90:	b082      	sub	sp, #8
 8002d92:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002d94:	9b01      	ldr	r3, [sp, #4]
 8002d96:	681a      	ldr	r2, [r3, #0]
 8002d98:	9b01      	ldr	r3, [sp, #4]
 8002d9a:	1ad3      	subs	r3, r2, r3
 8002d9c:	1e5a      	subs	r2, r3, #1
 8002d9e:	4193      	sbcs	r3, r2
 8002da0:	b2db      	uxtb	r3, r3
}
 8002da2:	1c18      	adds	r0, r3, #0
 8002da4:	b002      	add	sp, #8
 8002da6:	4770      	bx	lr
 8002da8:	46c0      	nop			; (mov r8, r8)
 8002daa:	46c0      	nop			; (mov r8, r8)
 8002dac:	46c0      	nop			; (mov r8, r8)
 8002dae:	46c0      	nop			; (mov r8, r8)

08002db0 <chSysLock.4829.4213>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void)  {
 8002db0:	b508      	push	{r3, lr}

  port_lock();
 8002db2:	f7ff ffc5 	bl	8002d40 <port_lock.4742.4235>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002db6:	bd08      	pop	{r3, pc}
 8002db8:	46c0      	nop			; (mov r8, r8)
 8002dba:	46c0      	nop			; (mov r8, r8)
 8002dbc:	46c0      	nop			; (mov r8, r8)
 8002dbe:	46c0      	nop			; (mov r8, r8)

08002dc0 <chSysUnlock.4831.4211>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002dc0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002dc2:	f7ff ffc5 	bl	8002d50 <port_unlock.4745.4233>
}
 8002dc6:	bd08      	pop	{r3, pc}
 8002dc8:	46c0      	nop			; (mov r8, r8)
 8002dca:	46c0      	nop			; (mov r8, r8)
 8002dcc:	46c0      	nop			; (mov r8, r8)
 8002dce:	46c0      	nop			; (mov r8, r8)

08002dd0 <chThdDoDequeueNextI.4850.4191>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b085      	sub	sp, #20
 8002dd4:	9001      	str	r0, [sp, #4]
 8002dd6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 8002dd8:	9b01      	ldr	r3, [sp, #4]
 8002dda:	1c18      	adds	r0, r3, #0
 8002ddc:	f7ff fe20 	bl	8002a20 <queue_fifo_remove>
 8002de0:	1c03      	adds	r3, r0, #0
 8002de2:	9303      	str	r3, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8002de4:	9b03      	ldr	r3, [sp, #12]
 8002de6:	9a00      	ldr	r2, [sp, #0]
 8002de8:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8002dea:	9b03      	ldr	r3, [sp, #12]
 8002dec:	1c18      	adds	r0, r3, #0
 8002dee:	f7ff fe4f 	bl	8002a90 <chSchReadyI>
}
 8002df2:	b005      	add	sp, #20
 8002df4:	bd00      	pop	{pc}
 8002df6:	46c0      	nop			; (mov r8, r8)
 8002df8:	46c0      	nop			; (mov r8, r8)
 8002dfa:	46c0      	nop			; (mov r8, r8)
 8002dfc:	46c0      	nop			; (mov r8, r8)
 8002dfe:	46c0      	nop			; (mov r8, r8)

08002e00 <_thread_init.4187>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8002e00:	b500      	push	{lr}
 8002e02:	b083      	sub	sp, #12
 8002e04:	9001      	str	r0, [sp, #4]
 8002e06:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8002e08:	9b01      	ldr	r3, [sp, #4]
 8002e0a:	9a00      	ldr	r2, [sp, #0]
 8002e0c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 8002e0e:	9b01      	ldr	r3, [sp, #4]
 8002e10:	2202      	movs	r2, #2
 8002e12:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002e14:	9b01      	ldr	r3, [sp, #4]
 8002e16:	2200      	movs	r2, #0
 8002e18:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002e1a:	9b01      	ldr	r3, [sp, #4]
 8002e1c:	9a00      	ldr	r2, [sp, #0]
 8002e1e:	62da      	str	r2, [r3, #44]	; 0x2c
  tp->p_mtxlist = NULL;
 8002e20:	9b01      	ldr	r3, [sp, #4]
 8002e22:	2200      	movs	r2, #0
 8002e24:	629a      	str	r2, [r3, #40]	; 0x28
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002e26:	9b01      	ldr	r3, [sp, #4]
 8002e28:	2200      	movs	r2, #0
 8002e2a:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 8002e2c:	9b01      	ldr	r3, [sp, #4]
 8002e2e:	4a0b      	ldr	r2, [pc, #44]	; (8002e5c <_thread_init.4187+0x5c>)
 8002e30:	611a      	str	r2, [r3, #16]
 8002e32:	4b0a      	ldr	r3, [pc, #40]	; (8002e5c <_thread_init.4187+0x5c>)
 8002e34:	695a      	ldr	r2, [r3, #20]
 8002e36:	9b01      	ldr	r3, [sp, #4]
 8002e38:	615a      	str	r2, [r3, #20]
 8002e3a:	9b01      	ldr	r3, [sp, #4]
 8002e3c:	695b      	ldr	r3, [r3, #20]
 8002e3e:	9a01      	ldr	r2, [sp, #4]
 8002e40:	611a      	str	r2, [r3, #16]
 8002e42:	4b06      	ldr	r3, [pc, #24]	; (8002e5c <_thread_init.4187+0x5c>)
 8002e44:	9a01      	ldr	r2, [sp, #4]
 8002e46:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8002e48:	9b01      	ldr	r3, [sp, #4]
 8002e4a:	3324      	adds	r3, #36	; 0x24
 8002e4c:	1c18      	adds	r0, r3, #0
 8002e4e:	f7ff ff87 	bl	8002d60 <list_init.4754.4226>
  chTMStartMeasurementX(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 8002e52:	9b01      	ldr	r3, [sp, #4]
}
 8002e54:	1c18      	adds	r0, r3, #0
 8002e56:	b003      	add	sp, #12
 8002e58:	bd00      	pop	{pc}
 8002e5a:	46c0      	nop			; (mov r8, r8)
 8002e5c:	20000300 	.word	0x20000300

08002e60 <chThdCreateI.4179>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8002e60:	b500      	push	{lr}
 8002e62:	b087      	sub	sp, #28
 8002e64:	9003      	str	r0, [sp, #12]
 8002e66:	9102      	str	r1, [sp, #8]
 8002e68:	9201      	str	r2, [sp, #4]
 8002e6a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 8002e6c:	9b03      	ldr	r3, [sp, #12]
 8002e6e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002e70:	9b02      	ldr	r3, [sp, #8]
 8002e72:	3b24      	subs	r3, #36	; 0x24
 8002e74:	9a03      	ldr	r2, [sp, #12]
 8002e76:	18d2      	adds	r2, r2, r3
 8002e78:	9b05      	ldr	r3, [sp, #20]
 8002e7a:	60da      	str	r2, [r3, #12]
 8002e7c:	9b05      	ldr	r3, [sp, #20]
 8002e7e:	68db      	ldr	r3, [r3, #12]
 8002e80:	9a00      	ldr	r2, [sp, #0]
 8002e82:	611a      	str	r2, [r3, #16]
 8002e84:	9b05      	ldr	r3, [sp, #20]
 8002e86:	68db      	ldr	r3, [r3, #12]
 8002e88:	9a08      	ldr	r2, [sp, #32]
 8002e8a:	615a      	str	r2, [r3, #20]
 8002e8c:	9b05      	ldr	r3, [sp, #20]
 8002e8e:	68db      	ldr	r3, [r3, #12]
 8002e90:	4a05      	ldr	r2, [pc, #20]	; (8002ea8 <chThdCreateI.4179+0x48>)
 8002e92:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 8002e94:	9a05      	ldr	r2, [sp, #20]
 8002e96:	9b01      	ldr	r3, [sp, #4]
 8002e98:	1c10      	adds	r0, r2, #0
 8002e9a:	1c19      	adds	r1, r3, #0
 8002e9c:	f7ff ffb0 	bl	8002e00 <_thread_init.4187>
 8002ea0:	1c03      	adds	r3, r0, #0
}
 8002ea2:	1c18      	adds	r0, r3, #0
 8002ea4:	b007      	add	sp, #28
 8002ea6:	bd00      	pop	{pc}
 8002ea8:	080001b1 	.word	0x080001b1
 8002eac:	46c0      	nop			; (mov r8, r8)
 8002eae:	46c0      	nop			; (mov r8, r8)

08002eb0 <chThdCreateStatic.4170>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8002eb0:	b510      	push	{r4, lr}
 8002eb2:	b088      	sub	sp, #32
 8002eb4:	9005      	str	r0, [sp, #20]
 8002eb6:	9104      	str	r1, [sp, #16]
 8002eb8:	9203      	str	r2, [sp, #12]
 8002eba:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8002ebc:	f7ff ff78 	bl	8002db0 <chSysLock.4829.4213>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8002ec0:	9805      	ldr	r0, [sp, #20]
 8002ec2:	9904      	ldr	r1, [sp, #16]
 8002ec4:	9a03      	ldr	r2, [sp, #12]
 8002ec6:	9b02      	ldr	r3, [sp, #8]
 8002ec8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8002eca:	9400      	str	r4, [sp, #0]
 8002ecc:	f7ff ffc8 	bl	8002e60 <chThdCreateI.4179>
 8002ed0:	1c03      	adds	r3, r0, #0
 8002ed2:	9307      	str	r3, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8002ed4:	9b07      	ldr	r3, [sp, #28]
 8002ed6:	1c18      	adds	r0, r3, #0
 8002ed8:	2100      	movs	r1, #0
 8002eda:	f7ff fe99 	bl	8002c10 <chSchWakeupS>
  chSysUnlock();
 8002ede:	f7ff ff6f 	bl	8002dc0 <chSysUnlock.4831.4211>

  return tp;
 8002ee2:	9b07      	ldr	r3, [sp, #28]
}
 8002ee4:	1c18      	adds	r0, r3, #0
 8002ee6:	b008      	add	sp, #32
 8002ee8:	bd10      	pop	{r4, pc}
 8002eea:	46c0      	nop			; (mov r8, r8)
 8002eec:	46c0      	nop			; (mov r8, r8)
 8002eee:	46c0      	nop			; (mov r8, r8)

08002ef0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8002ef0:	b500      	push	{lr}
 8002ef2:	b083      	sub	sp, #12
 8002ef4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002ef6:	f7ff ff5b 	bl	8002db0 <chSysLock.4829.4213>
  chThdExitS(msg);
 8002efa:	9b01      	ldr	r3, [sp, #4]
 8002efc:	1c18      	adds	r0, r3, #0
 8002efe:	f000 f807 	bl	8002f10 <chThdExitS.4143>
  /* The thread never returns here.*/
}
 8002f02:	b003      	add	sp, #12
 8002f04:	bd00      	pop	{pc}
 8002f06:	46c0      	nop			; (mov r8, r8)
 8002f08:	46c0      	nop			; (mov r8, r8)
 8002f0a:	46c0      	nop			; (mov r8, r8)
 8002f0c:	46c0      	nop			; (mov r8, r8)
 8002f0e:	46c0      	nop			; (mov r8, r8)

08002f10 <chThdExitS.4143>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8002f10:	b500      	push	{lr}
 8002f12:	b085      	sub	sp, #20
 8002f14:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8002f16:	4b16      	ldr	r3, [pc, #88]	; (8002f70 <chThdExitS.4143+0x60>)
 8002f18:	699b      	ldr	r3, [r3, #24]
 8002f1a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 8002f1c:	9b03      	ldr	r3, [sp, #12]
 8002f1e:	9a01      	ldr	r2, [sp, #4]
 8002f20:	621a      	str	r2, [r3, #32]
 8002f22:	e008      	b.n	8002f36 <chThdExitS.4143+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8002f24:	9b03      	ldr	r3, [sp, #12]
 8002f26:	3324      	adds	r3, #36	; 0x24
 8002f28:	1c18      	adds	r0, r3, #0
 8002f2a:	f7ff fda1 	bl	8002a70 <list_remove.4265>
 8002f2e:	1c03      	adds	r3, r0, #0
 8002f30:	1c18      	adds	r0, r3, #0
 8002f32:	f7ff fdad 	bl	8002a90 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8002f36:	9b03      	ldr	r3, [sp, #12]
 8002f38:	3324      	adds	r3, #36	; 0x24
 8002f3a:	1c18      	adds	r0, r3, #0
 8002f3c:	f7ff ff18 	bl	8002d70 <list_notempty.4820.4223>
 8002f40:	1c03      	adds	r3, r0, #0
 8002f42:	2b00      	cmp	r3, #0
 8002f44:	d1ee      	bne.n	8002f24 <chThdExitS.4143+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8002f46:	9b03      	ldr	r3, [sp, #12]
 8002f48:	7f5b      	ldrb	r3, [r3, #29]
 8002f4a:	1c1a      	adds	r2, r3, #0
 8002f4c:	2303      	movs	r3, #3
 8002f4e:	4013      	ands	r3, r2
 8002f50:	d109      	bne.n	8002f66 <chThdExitS.4143+0x56>
    REG_REMOVE(tp);
 8002f52:	9b03      	ldr	r3, [sp, #12]
 8002f54:	695b      	ldr	r3, [r3, #20]
 8002f56:	9a03      	ldr	r2, [sp, #12]
 8002f58:	6912      	ldr	r2, [r2, #16]
 8002f5a:	611a      	str	r2, [r3, #16]
 8002f5c:	9b03      	ldr	r3, [sp, #12]
 8002f5e:	691b      	ldr	r3, [r3, #16]
 8002f60:	9a03      	ldr	r2, [sp, #12]
 8002f62:	6952      	ldr	r2, [r2, #20]
 8002f64:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8002f66:	200f      	movs	r0, #15
 8002f68:	f7ff fdba 	bl	8002ae0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8002f6c:	b005      	add	sp, #20
 8002f6e:	bd00      	pop	{pc}
 8002f70:	20000300 	.word	0x20000300
 8002f74:	46c0      	nop			; (mov r8, r8)
 8002f76:	46c0      	nop			; (mov r8, r8)
 8002f78:	46c0      	nop			; (mov r8, r8)
 8002f7a:	46c0      	nop			; (mov r8, r8)
 8002f7c:	46c0      	nop			; (mov r8, r8)
 8002f7e:	46c0      	nop			; (mov r8, r8)

08002f80 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8002f80:	b500      	push	{lr}
 8002f82:	b083      	sub	sp, #12
 8002f84:	9001      	str	r0, [sp, #4]
 8002f86:	1c0a      	adds	r2, r1, #0
 8002f88:	466b      	mov	r3, sp
 8002f8a:	3302      	adds	r3, #2
 8002f8c:	801a      	strh	r2, [r3, #0]

  if (TIME_IMMEDIATE == timeout) {
 8002f8e:	466b      	mov	r3, sp
 8002f90:	3302      	adds	r3, #2
 8002f92:	881b      	ldrh	r3, [r3, #0]
 8002f94:	2b00      	cmp	r3, #0
 8002f96:	d102      	bne.n	8002f9e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
 8002f98:	2301      	movs	r3, #1
 8002f9a:	425b      	negs	r3, r3
 8002f9c:	e00e      	b.n	8002fbc <chThdEnqueueTimeoutS+0x3c>
  }

  queue_insert(currp, tqp);
 8002f9e:	4b09      	ldr	r3, [pc, #36]	; (8002fc4 <chThdEnqueueTimeoutS+0x44>)
 8002fa0:	699a      	ldr	r2, [r3, #24]
 8002fa2:	9b01      	ldr	r3, [sp, #4]
 8002fa4:	1c10      	adds	r0, r2, #0
 8002fa6:	1c19      	adds	r1, r3, #0
 8002fa8:	f7ff fd22 	bl	80029f0 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8002fac:	466b      	mov	r3, sp
 8002fae:	3302      	adds	r3, #2
 8002fb0:	881b      	ldrh	r3, [r3, #0]
 8002fb2:	2004      	movs	r0, #4
 8002fb4:	1c19      	adds	r1, r3, #0
 8002fb6:	f7ff fdeb 	bl	8002b90 <chSchGoSleepTimeoutS>
 8002fba:	1c03      	adds	r3, r0, #0
}
 8002fbc:	1c18      	adds	r0, r3, #0
 8002fbe:	b003      	add	sp, #12
 8002fc0:	bd00      	pop	{pc}
 8002fc2:	46c0      	nop			; (mov r8, r8)
 8002fc4:	20000300 	.word	0x20000300
 8002fc8:	46c0      	nop			; (mov r8, r8)
 8002fca:	46c0      	nop			; (mov r8, r8)
 8002fcc:	46c0      	nop			; (mov r8, r8)
 8002fce:	46c0      	nop			; (mov r8, r8)

08002fd0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002fd0:	b500      	push	{lr}
 8002fd2:	b083      	sub	sp, #12
 8002fd4:	9001      	str	r0, [sp, #4]
 8002fd6:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8002fd8:	9b01      	ldr	r3, [sp, #4]
 8002fda:	1c18      	adds	r0, r3, #0
 8002fdc:	f7ff fed8 	bl	8002d90 <queue_notempty.4824.4219>
 8002fe0:	1c03      	adds	r3, r0, #0
 8002fe2:	2b00      	cmp	r3, #0
 8002fe4:	d005      	beq.n	8002ff2 <chThdDequeueNextI+0x22>
    chThdDoDequeueNextI(tqp, msg);
 8002fe6:	9a01      	ldr	r2, [sp, #4]
 8002fe8:	9b00      	ldr	r3, [sp, #0]
 8002fea:	1c10      	adds	r0, r2, #0
 8002fec:	1c19      	adds	r1, r3, #0
 8002fee:	f7ff feef 	bl	8002dd0 <chThdDoDequeueNextI.4850.4191>
  }
}
 8002ff2:	b003      	add	sp, #12
 8002ff4:	bd00      	pop	{pc}
 8002ff6:	46c0      	nop			; (mov r8, r8)
 8002ff8:	46c0      	nop			; (mov r8, r8)
 8002ffa:	46c0      	nop			; (mov r8, r8)
 8002ffc:	46c0      	nop			; (mov r8, r8)
 8002ffe:	46c0      	nop			; (mov r8, r8)

08003000 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8003000:	b500      	push	{lr}
 8003002:	b083      	sub	sp, #12
 8003004:	9001      	str	r0, [sp, #4]
 8003006:	9100      	str	r1, [sp, #0]
 8003008:	e005      	b.n	8003016 <chThdDequeueAllI+0x16>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 800300a:	9a01      	ldr	r2, [sp, #4]
 800300c:	9b00      	ldr	r3, [sp, #0]
 800300e:	1c10      	adds	r0, r2, #0
 8003010:	1c19      	adds	r1, r3, #0
 8003012:	f7ff fedd 	bl	8002dd0 <chThdDoDequeueNextI.4850.4191>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 8003016:	9b01      	ldr	r3, [sp, #4]
 8003018:	1c18      	adds	r0, r3, #0
 800301a:	f7ff feb9 	bl	8002d90 <queue_notempty.4824.4219>
 800301e:	1c03      	adds	r3, r0, #0
 8003020:	2b00      	cmp	r3, #0
 8003022:	d1f2      	bne.n	800300a <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8003024:	b003      	add	sp, #12
 8003026:	bd00      	pop	{pc}
 8003028:	46c0      	nop			; (mov r8, r8)
 800302a:	46c0      	nop			; (mov r8, r8)
 800302c:	46c0      	nop			; (mov r8, r8)
 800302e:	46c0      	nop			; (mov r8, r8)
 8003030:	656c6469 	.word	0x656c6469
	...

08003040 <ch_debug>:
 8003040:	6e69616d 18401600 08300204 1814100c     main..@...0.....
 8003050:	001d1c00 00000000 00000000 00000000     ................

08003060 <vmt.6639>:
 8003060:	08000e21 08000e51 08000e81 08000ec1     !...Q...........
 8003070:	08000ef1 08000f31 08000f61 08000f91     ....1...a.......

08003080 <default_config.7170.4470>:
 8003080:	000004b0 00000000 00004000 00000000     .........@......

08003090 <pal_default_config>:
 8003090:	280000a4 00000000 ffffff57 65555501     ...(....W....UUe
 80030a0:	0000ffff 00001100 00000000 00000000     ................
 80030b0:	00000000 ffffffff 55555555 0000ffff     ........UUUU....
	...
 80030d0:	ffffffff 51555555 0000ffff 00000000     ....UUUQ........
	...
 80030f0:	55555550 0000ffff 00000000 00000000     PUUU............

08003100 <extcfg.7439.4467>:
 8003100:	00000001 08000a91 00000001 08000a91     ................
	...
 8003120:	00000001 08000a91 00000001 08000a91     ................
 8003130:	00000001 08000a91 00000001 08000a91     ................
	...
 8003148:	00000001 08000a91 00000001 08000a91     ................
	...
 80031a0:	08002b50 08002b72 08002b72 08002b56     P+..r+..r+..V+..
 80031b0:	08002b6a 08002b60 08002b72 08002b6a     j+..`+..r+..j+..
